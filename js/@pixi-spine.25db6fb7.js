import{S as t,M as e,A as n,R as s,T as a,C as r,r as i,h as o,a as l,D as h,P as c,G as d,b as u,c as m,E as f,L as g,d as p,s as x,p as w,e as b,f as E,B as y}from"./@pixi.f22f9352.js";import"./eventemitter3.d2f15c83.js";import"./earcut.660a4831.js";import"./url.c099834f.js";var S=(t=>(t[t.Region=0]="Region",t[t.BoundingBox=1]="BoundingBox",t[t.Mesh=2]="Mesh",t[t.LinkedMesh=3]="LinkedMesh",t[t.Path=4]="Path",t[t.Point=5]="Point",t[t.Clipping=6]="Clipping",t))(S||{});class M{constructor(t,e=new Array,n=0,s=new DataView(t.buffer)){this.strings=e,this.index=n,this.buffer=s}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),n=127&e;return 128&e&&(e=this.readByte(),n|=(127&e)<<7,128&e&&(e=this.readByte(),n|=(127&e)<<14,128&e&&(e=this.readByte(),n|=(127&e)<<21,128&e&&(e=this.readByte(),n|=(127&e)<<28)))),t?n:n>>>1^-(1&n)}readStringRef(){const t=this.readInt(!0);return 0==t?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let n=0;n<t;){const t=this.readUnsignedByte();switch(t>>4){case 12:case 13:e+=String.fromCharCode((31&t)<<6|63&this.readByte()),n+=2;break;case 14:e+=String.fromCharCode((15&t)<<12|(63&this.readByte())<<6|63&this.readByte()),n+=3;break;default:e+=String.fromCharCode(t),n++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return 0!=this.readByte()}}var A=(t=>(t[t.setup=0]="setup",t[t.first=1]="first",t[t.replace=2]="replace",t[t.add=3]="add",t))(A||{}),I=(t=>(t[t.mixIn=0]="mixIn",t[t.mixOut=1]="mixOut",t))(I||{}),T=(t=>(t[t.Fixed=0]="Fixed",t[t.Percent=1]="Percent",t))(T||{}),k=(t=>(t[t.Tangent=0]="Tangent",t[t.Chain=1]="Chain",t[t.ChainScale=2]="ChainScale",t))(k||{}),R=(t=>(t[t.Normal=0]="Normal",t[t.OnlyTranslation=1]="OnlyTranslation",t[t.NoRotationOrReflection=2]="NoRotationOrReflection",t[t.NoScale=3]="NoScale",t[t.NoScaleOrReflection=4]="NoScaleOrReflection",t))(R||{});function C(t){switch(t.toLowerCase()){case"nearest":return V.Nearest;case"linear":return V.Linear;case"mipmap":return V.MipMap;case"mipmapnearestnearest":return V.MipMapNearestNearest;case"mipmaplinearnearest":return V.MipMapLinearNearest;case"mipmapnearestlinear":return V.MipMapNearestLinear;case"mipmaplinearlinear":return V.MipMapLinearLinear;default:throw new Error(`Unknown texture filter ${t}`)}}var V=(t=>(t[t.Nearest=9728]="Nearest",t[t.Linear=9729]="Linear",t[t.MipMap=9987]="MipMap",t[t.MipMapNearestNearest=9984]="MipMapNearestNearest",t[t.MipMapLinearNearest=9985]="MipMapLinearNearest",t[t.MipMapNearestLinear=9986]="MipMapNearestLinear",t[t.MipMapLinearLinear=9987]="MipMapLinearLinear",t))(V||{}),v=(t=>(t[t.MirroredRepeat=33648]="MirroredRepeat",t[t.ClampToEdge=33071]="ClampToEdge",t[t.Repeat=10497]="Repeat",t))(v||{});class P{constructor(){this.size=null,this.names=null,this.values=null,this.renderObject=null}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return 0!==this.texture.rotate}get degrees(){return(360-45*this.texture.rotate)%360}}class F{constructor(){this.x=0,this.y=0,this.width=0,this.height=0,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0,this.rotate=0,this.index=0}}class Y{constructor(t,e,n){this.pages=new Array,this.regions=new Array,t&&this.addSpineAtlas(t,e,n)}addTexture(t,e){const n=this.pages;let s=null;for(let r=0;r<n.length;r++)if(n[r].baseTexture===e.baseTexture){s=n[r];break}if(null===s){s=new X,s.name="texturePage";const t=e.baseTexture;s.width=t.realWidth,s.height=t.realHeight,s.baseTexture=t,s.minFilter=s.magFilter=V.Nearest,s.uWrap=v.ClampToEdge,s.vWrap=v.ClampToEdge,n.push(s)}const a=new D;return a.name=t,a.page=s,a.texture=e,a.index=-1,this.regions.push(a),a}addTextureHash(t,e){for(const n in t)t.hasOwnProperty(n)&&this.addTexture(e&&-1!==n.indexOf(".")?n.substr(0,n.lastIndexOf(".")):n,t[n])}addSpineAtlas(t,e,n){return this.load(t,e,n)}load(t,e,r){if(null==e)throw new Error("textureLoader cannot be null.");const i=new N(t),o=new Array(4);let l=null;const h={};let c=null;h.size=()=>{l.width=parseInt(o[1]),l.height=parseInt(o[2])},h.format=()=>{},h.filter=()=>{l.minFilter=C(o[1]),l.magFilter=C(o[2])},h.repeat=()=>{-1!=o[1].indexOf("x")&&(l.uWrap=v.Repeat),-1!=o[1].indexOf("y")&&(l.vWrap=v.Repeat)},h.pma=()=>{l.pma="true"==o[1]};const d={xy:()=>{c.x=parseInt(o[1]),c.y=parseInt(o[2])},size:()=>{c.width=parseInt(o[1]),c.height=parseInt(o[2])},bounds:()=>{c.x=parseInt(o[1]),c.y=parseInt(o[2]),c.width=parseInt(o[3]),c.height=parseInt(o[4])},offset:()=>{c.offsetX=parseInt(o[1]),c.offsetY=parseInt(o[2])},orig:()=>{c.originalWidth=parseInt(o[1]),c.originalHeight=parseInt(o[2])},offsets:()=>{c.offsetX=parseInt(o[1]),c.offsetY=parseInt(o[2]),c.originalWidth=parseInt(o[3]),c.originalHeight=parseInt(o[4])},rotate:()=>{const t=o[1];let e=0;e="true"==t.toLocaleLowerCase()?6:"false"==t.toLocaleLowerCase()?0:(720-parseFloat(t))%360/45,c.rotate=e},index:()=>{c.index=parseInt(o[1])}};let u=i.readLine();for(;null!=u&&0==u.trim().length;)u=i.readLine();for(;null!=u&&0!=u.trim().length&&0!=i.readEntry(o,u);)u=i.readLine();const m=()=>{for(;;){if(null==u)return r&&r(this);if(0==u.trim().length)l=null,u=i.readLine();else{if(null===l){for(l=new X,l.name=u.trim();0!=i.readEntry(o,u=i.readLine());){const t=h[o[0]];t&&t()}this.pages.push(l),e(l.name,(t=>{if(null===t)return this.pages.splice(this.pages.indexOf(l),1),r&&r(null);l.baseTexture=t,l.pma&&(t.alphaMode=n.PMA),t.valid||t.setSize(l.width,l.height),l.setFilters(),l.width&&l.height||(l.width=t.realWidth,l.height=t.realHeight,l.width&&l.height||console.log(`ERROR spine atlas page ${l.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),m()}));break}{c=new F;const t=new D;t.name=u,t.page=l;let e=null,n=null;for(;;){const t=i.readEntry(o,u=i.readLine());if(0==t)break;const s=d[o[0]];if(s)s();else{null==e&&(e=[],n=[]),e.push(o[0]);const s=[];for(let e=0;e<t;e++)s.push(parseInt(o[e+1]));n.push(s)}}0==c.originalWidth&&0==c.originalHeight&&(c.originalWidth=c.width,c.originalHeight=c.height);const r=l.baseTexture.resolution;c.x/=r,c.y/=r,c.width/=r,c.height/=r,c.originalWidth/=r,c.originalHeight/=r,c.offsetX/=r,c.offsetY/=r;const h=c.rotate%4!=0,m=new s(c.x,c.y,h?c.height:c.width,h?c.width:c.height),f=new s(0,0,c.originalWidth,c.originalHeight),g=new s(c.offsetX,c.originalHeight-c.height-c.offsetY,c.width,c.height);t.texture=new a(t.page.baseTexture,m,f,g,c.rotate),t.index=c.index,t.texture.updateUvs(),this.regions.push(t)}}}};m()}findRegion(t){for(let e=0;e<this.regions.length;e++)if(this.regions[e].name==t)return this.regions[e];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].baseTexture.dispose()}}class N{constructor(t){this.index=0,this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,e){if(null==e)return 0;if(0==(e=e.trim()).length)return 0;const n=e.indexOf(":");if(-1==n)return 0;t[0]=e.substr(0,n).trim();for(let s=1,a=n+1;;s++){const n=e.indexOf(",",a);if(-1==n)return t[s]=e.substr(a).trim(),s;if(t[s]=e.substr(a,n-a).trim(),a=n+1,4==s)return 4}}}class X{constructor(){this.minFilter=V.Nearest,this.magFilter=V.Nearest,this.uWrap=v.ClampToEdge,this.vWrap=v.ClampToEdge}setFilters(){const n=this.baseTexture,s=this.minFilter;s==V.Linear?n.scaleMode=t.LINEAR:this.minFilter==V.Nearest?n.scaleMode=t.NEAREST:(n.mipmap=e.POW2,s==V.MipMapNearestNearest?n.scaleMode=t.NEAREST:n.scaleMode=t.LINEAR)}}class D extends P{}class B{constructor(){this.array=new Array}add(t){const e=this.contains(t);return this.array[0|t]=0|t,!e}contains(t){return null!=this.array[0|t]}remove(t){this.array[0|t]=void 0}clear(){this.array.length=0}}class L{constructor(){this.entries={},this.size=0}add(t){const e=this.entries[t];return this.entries[t]=!0,!e&&(this.size++,!0)}addAll(t){const e=this.size;for(let n=0,s=t.length;n<s;n++)this.add(t[n]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}}const _=class{constructor(t=0,e=0,n=0,s=0){this.r=t,this.g=e,this.b=n,this.a=s}set(t,e,n,s){return this.r=t,this.g=e,this.b=n,this.a=s,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t="#"==t.charAt(0)?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=8!=t.length?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,n,s){return this.r+=t,this.g+=e,this.b+=n,this.a+=s,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((4278190080&e)>>>24)/255,t.g=((16711680&e)>>>16)/255,t.b=((65280&e)>>>8)/255,t.a=(255&e)/255}static rgb888ToColor(t,e){t.r=((16711680&e)>>>16)/255,t.g=((65280&e)>>>8)/255,t.b=(255&e)/255}static fromString(t){return(new _).setFromString(t)}};let O=_;O.WHITE=new _(1,1,1,1),O.RED=new _(1,0,0,1),O.GREEN=new _(0,1,0,1),O.BLUE=new _(0,0,1,1),O.MAGENTA=new _(1,0,1,1);const W=class{static clamp(t,e,n){return t<e?e:t>n?n:t}static cosDeg(t){return Math.cos(t*W.degRad)}static sinDeg(t){return Math.sin(t*W.degRad)}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),1/3);return t<0?-e:e}static randomTriangular(t,e){return W.randomTriangularWith(t,e,.5*(t+e))}static randomTriangularWith(t,e,n){const s=Math.random(),a=e-t;return s<=(n-t)/a?t+Math.sqrt(s*a*(n-t)):e-Math.sqrt((1-s)*a*(e-n))}static isPowerOfTwo(t){return t&&!(t&t-1)}};let q=W;q.PI=3.1415927,q.PI2=2*W.PI,q.radiansToDegrees=180/W.PI,q.radDeg=W.radiansToDegrees,q.degreesToRadians=W.PI/180,q.degRad=W.degreesToRadians;class ${apply(t,e,n){return t+(e-t)*this.applyInternal(n)}}class U extends ${constructor(t){super(),this.power=2,this.power=t}applyInternal(t){return t<=.5?Math.pow(2*t,this.power)/2:Math.pow(2*(t-1),this.power)/(this.power%2==0?-2:2)+1}}class z extends U{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}}const H=class{static arrayCopy(t,e,n,s,a){for(let r=e,i=s;r<e+a;r++,i++)n[i]=t[r]}static arrayFill(t,e,n,s){for(let a=e;a<n;a++)t[a]=s}static setArraySize(t,e,n=0){const s=t.length;if(s==e)return t;if(t.length=e,s<e)for(let a=s;a<e;a++)t[a]=n;return t}static ensureArrayCapacity(t,e,n=0){return t.length>=e?t:H.setArraySize(t,e,n)}static newArray(t,e){const n=new Array(t);for(let s=0;s<t;s++)n[s]=e;return n}static newFloatArray(t){if(H.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let n=0;n<e.length;n++)e[n]=0;return e}static newShortArray(t){if(H.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let n=0;n<e.length;n++)e[n]=0;return e}static toFloatArray(t){return H.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return H.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,n=!0){for(let s=0;s<t.length;s++)if(t[s]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};let j=H;j.SUPPORTS_TYPED_ARRAYS="undefined"!=typeof Float32Array;class G{constructor(t){this.items=new Array,this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}}class Z{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return 0!=t&&(this.x/=t,this.y/=t),this}}class Q{constructor(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.boundingBoxes=new Array,this.polygons=new Array,this.polygonPool=new G((()=>j.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const n=this.boundingBoxes,s=this.polygons,a=this.polygonPool,r=t.slots,i=r.length;n.length=0,a.freeAll(s),s.length=0;for(let o=0;o<i;o++){const t=r[o];if(!t.bone.active)continue;const e=t.getAttachment();if(null!=e&&e.type===S.BoundingBox){const r=e;n.push(r);let i=a.obtain();i.length!=r.worldVerticesLength&&(i=j.newFloatArray(r.worldVerticesLength)),s.push(i),r.computeWorldVertices(t,0,r.worldVerticesLength,i,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,s=Number.NEGATIVE_INFINITY;const a=this.polygons;for(let r=0,i=a.length;r<i;r++){const i=a[r],o=i;for(let a=0,r=i.length;a<r;a+=2){const r=o[a],i=o[a+1];t=Math.min(t,r),e=Math.min(e,i),n=Math.max(n,r),s=Math.max(s,i)}}this.minX=t,this.minY=e,this.maxX=n,this.maxY=s}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,n,s){const a=this.minX,r=this.minY,i=this.maxX,o=this.maxY;if(t<=a&&n<=a||e<=r&&s<=r||t>=i&&n>=i||e>=o&&s>=o)return!1;const l=(s-e)/(n-t);let h=l*(a-t)+e;if(h>r&&h<o)return!0;if(h=l*(i-t)+e,h>r&&h<o)return!0;let c=(r-e)/l+t;return c>a&&c<i||(c=(o-e)/l+t,c>a&&c<i)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const n=this.polygons;for(let s=0,a=n.length;s<a;s++)if(this.containsPointPolygon(n[s],t,e))return this.boundingBoxes[s];return null}containsPointPolygon(t,e,n){const s=t,a=t.length;let r=a-2,i=!1;for(let o=0;o<a;o+=2){const t=s[o+1],a=s[r+1];if(t<n&&a>=n||a<n&&t>=n){const l=s[o];l+(n-t)/(a-t)*(s[r]-l)<e&&(i=!i)}r=o}return i}intersectsSegment(t,e,n,s){const a=this.polygons;for(let r=0,i=a.length;r<i;r++)if(this.intersectsSegmentPolygon(a[r],t,e,n,s))return this.boundingBoxes[r];return null}intersectsSegmentPolygon(t,e,n,s,a){const r=t,i=t.length,o=e-s,l=n-a,h=e*a-n*s;let c=r[i-2],d=r[i-1];for(let u=0;u<i;u+=2){const t=r[u],i=r[u+1],m=c*i-d*t,f=c-t,g=d-i,p=o*g-l*f,x=(h*f-o*m)/p;if((x>=c&&x<=t||x>=t&&x<=c)&&(x>=e&&x<=s||x>=s&&x<=e)){const t=(h*g-l*m)/p;if((t>=d&&t<=i||t>=i&&t<=d)&&(t>=n&&t<=a||t>=a&&t<=n))return!0}c=t,d=i}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return-1==e?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}const K=0,J=[0,0,0];class tt extends u{constructor(){super(...arguments),this.region=null,this.attachment=null}}class et extends m{constructor(t,e,n,s,a){super(t,e,n,s,a),this.region=null,this.attachment=null}}const nt=class extends r{constructor(t){if(super(),!t)throw new Error("The spineData param is required.");if("string"==typeof t)throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,n=this.skeleton.slots.length;e<n;e++){const t=this.skeleton.slots[e],n=t.getAttachment(),s=this.newContainer();if(this.slotContainers.push(s),this.addChild(s),this.tempClipContainers.push(null),n)if(n.type===S.Region){const e=n.name,a=this.createSprite(t,n,e);t.currentSprite=a,t.currentSpriteName=e,s.addChild(a)}else if(n.type===S.Mesh){const e=this.createMesh(t,n);t.currentMesh=e,t.currentMeshId=n.id,t.currentMeshName=n.name,s.addChild(e)}else n.type===S.Clipping&&(this.createGraphics(t,n),s.addChild(t.clippingContainer),s.addChild(t.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&(null==(e=this._debug)||e.unregisterSpine(this),null==t||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?nt.prototype.autoUpdateTransform:r.prototype.updateTransform)}get tint(){return i(this.tintRgb)}set tint(t){this.tintRgb=o(t,this.tintRgb)}get delayLimit(){return(void 0!==this.localDelayLimit?this.localDelayLimit:K)||Number.MAX_VALUE}update(t){var e;const n=this.delayLimit;if(t>n&&(t=n),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform();const s=this.skeleton.slots,a=this.color;let r=null,o=null;a?(r=a.light,o=a.dark):r=this.tintRgb;for(let u=0,m=s.length;u<m;u++){const t=s[u],e=t.getAttachment(),n=this.slotContainers[u];if(!e){n.visible=!1;continue}let a=null;e.sequence&&e.sequence.apply(t,e);let h=e.region;const c=e.color;switch(null!=e&&e.type){case S.Region:if(n.transform.setFromMatrix(t.bone.matrix),h=e.region,t.currentMesh&&(t.currentMesh.visible=!1,t.currentMesh=null,t.currentMeshId=void 0,t.currentMeshName=void 0),!h){t.currentSprite&&(t.currentSprite.renderable=!1);break}if(!t.currentSpriteName||t.currentSpriteName!==e.name){const s=e.name;if(t.currentSprite&&(t.currentSprite.visible=!1),t.sprites=t.sprites||{},void 0!==t.sprites[s])t.sprites[s].visible=!0;else{const a=this.createSprite(t,e,s);n.addChild(a)}t.currentSprite=t.sprites[s],t.currentSpriteName=s}t.currentSprite.renderable=!0,t.hackRegion||this.setSpriteRegion(e,t.currentSprite,h),t.currentSprite.color?a=t.currentSprite.color:(J[0]=r[0]*t.color.r*c.r,J[1]=r[1]*t.color.g*c.g,J[2]=r[2]*t.color.b*c.b,t.currentSprite.tint=i(J)),t.currentSprite.blendMode=t.blendMode;break;case S.Mesh:if(t.currentSprite){t.currentSprite.visible=!1,t.currentSprite=null,t.currentSpriteName=void 0;const e=new l;e._parentID=-1,e._worldID=n.transform._worldID,n.transform=e}if(!h){t.currentMesh&&(t.currentMesh.renderable=!1);break}const s=e.id;if(void 0===t.currentMeshId||t.currentMeshId!==s){const a=s;if(t.currentMesh&&(t.currentMesh.visible=!1),t.meshes=t.meshes||{},void 0!==t.meshes[a])t.meshes[a].visible=!0;else{const s=this.createMesh(t,e);n.addChild(s)}t.currentMesh=t.meshes[a],t.currentMeshName=e.name,t.currentMeshId=a}t.currentMesh.renderable=!0,e.computeWorldVerticesOld(t,t.currentMesh.vertices),t.currentMesh.color?a=t.currentMesh.color:(J[0]=r[0]*t.color.r*c.r,J[1]=r[1]*t.color.g*c.g,J[2]=r[2]*t.color.b*c.b,t.currentMesh.tint=i(J)),t.currentMesh.blendMode=t.blendMode,t.hackRegion||this.setMeshRegion(e,t.currentMesh,h);break;case S.Clipping:t.currentGraphics||(this.createGraphics(t,e),n.addChild(t.clippingContainer),n.addChild(t.currentGraphics)),this.updateGraphics(t,e),n.alpha=1,n.visible=!0;continue;default:n.visible=!1;continue}if(n.visible=!0,a){let e=t.color.r*c.r,n=t.color.g*c.g,s=t.color.b*c.b;a.setLight(r[0]*e+o[0]*(1-e),r[1]*n+o[1]*(1-n),r[2]*s+o[2]*(1-s)),t.darkColor?(e=t.darkColor.r,n=t.darkColor.g,s=t.darkColor.b):(e=0,n=0,s=0),a.setDark(r[0]*e+o[0]*(1-e),r[1]*n+o[1]*(1-n),r[2]*s+o[2]*(1-s))}n.alpha=t.color.a}const h=this.skeleton.drawOrder;let c=null,d=null;for(let i=0,l=h.length;i<l;i++){const t=s[h[i].data.index],e=this.slotContainers[h[i].data.index];if(d||null!==e.parent&&e.parent!==this&&(e.parent.removeChild(e),e.parent=this),t.currentGraphics&&t.getAttachment())d=t.clippingContainer,c=t.getAttachment(),d.children.length=0,this.children[i]=e,c.endSlot===t.data&&(c.endSlot=null);else if(d){let n=this.tempClipContainers[i];n||(n=this.tempClipContainers[i]=this.newContainer(),n.visible=!1),this.children[i]=n,e.parent=null,d.addChild(e),c.endSlot==t.data&&(d.renderable=!0,d=null,c=null)}else this.children[i]=e}null==(e=this._debug)||e.renderDebug(this)}setSpriteRegion(t,e,n){e.attachment===t&&e.region===n||(e.region=n,e.attachment=t,e.texture=n.texture,e.rotation=t.rotation*q.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,n.size?(e.scale.x=n.size.width/n.originalWidth,e.scale.y=-n.size.height/n.originalHeight):(e.scale.x=t.scaleX*t.width/n.originalWidth,e.scale.y=-t.scaleY*t.height/n.originalHeight))}setMeshRegion(t,e,n){e.attachment===t&&e.region===n||(e.region=n,e.attachment=t,e.texture=n.texture,n.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=.001*(Date.now()-this.lastTime);this.lastTime=Date.now(),this.update(t)}r.prototype.updateTransform.call(this)}createSprite(t,e,n){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion);const a=s?s.texture:null,r=this.newSprite(a);return r.anchor.set(.5),s&&this.setSpriteRegion(e,r,e.region),t.sprites=t.sprites||{},t.sprites[n]=r,r}createMesh(t,e){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const s=this.newMesh(n?n.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),h.TRIANGLES);return void 0!==s._canvasPadding&&(s._canvasPadding=1.5),s.alpha=e.color.a,s.region=e.region,n&&this.setMeshRegion(e,s,n),t.meshes=t.meshes||{},t.meshes[e.id]=s,s}createGraphics(t,e){const n=this.newGraphics(),s=new c([]);return n.clear(),n.beginFill(16777215,1),n.drawPolygon(s),n.renderable=!1,t.currentGraphics=n,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,n}updateGraphics(t,e){const n=t.currentGraphics.geometry,s=n.graphicsData[0].shape.points,a=e.worldVerticesLength;s.length=a,e.computeWorldVertices(t,0,a,s,0,2),n.invalidate()}hackTextureBySlotIndex(t,e=null,n=null){const s=this.skeleton.slots[t];if(!s)return!1;const a=s.getAttachment();let r=a.region;return e?(r=new P,r.texture=e,r.size=n,s.hackRegion=r,s.hackAttachment=a):(s.hackRegion=null,s.hackAttachment=null),s.currentSprite?this.setSpriteRegion(a,s.currentSprite,r):s.currentMesh&&this.setMeshRegion(a,s.currentMesh,r),!0}hackTextureBySlotName(t,e=null,n=null){const s=this.skeleton.findSlotIndex(t);return-1!=s&&this.hackTextureBySlotIndex(s,e,n)}hackTextureAttachment(t,e,n,s=null){const a=this.skeleton.findSlotIndex(t),r=this.skeleton.getAttachmentByName(t,e);r.region.texture=n;const i=this.skeleton.slots[a];if(!i)return!1;const o=i.getAttachment();if(e===o.name){let t=r.region;return n?(t=new P,t.texture=n,t.size=s,i.hackRegion=t,i.hackAttachment=o):(i.hackRegion=null,i.hackAttachment=null),i.currentSprite&&i.currentSprite.region!=t?(this.setSpriteRegion(o,i.currentSprite,t),i.currentSprite.region=t):i.currentMesh&&i.currentMesh.region!=t&&this.setMeshRegion(o,i.currentMesh,t),!0}return!1}newContainer(){return new r}newSprite(t){return new tt(t)}newGraphics(){return new d}newMesh(t,e,n,s,a){return new et(t,e,n,s,a)}transformHack(){return 1}hackAttachmentGroups(t,e,n){if(!t)return;const s=[],a=[];for(let r=0,i=this.skeleton.slots.length;r<i;r++){const i=this.skeleton.slots[r],o=i.currentSpriteName||i.currentMeshName||"",l=i.currentSprite||i.currentMesh;o.endsWith(t)?(l.parentGroup=e,a.push(l)):n&&l&&(l.parentGroup=n,s.push(l))}return[s,a]}destroy(t){this.debug=null;for(let e=0,n=this.skeleton.slots.length;e<n;e++){const n=this.skeleton.slots[e];for(const e in n.meshes)n.meshes[e].destroy(t);n.meshes=null;for(const e in n.sprites)n.sprites[e].destroy(t);n.sprites=null}for(let e=0,n=this.slotContainers.length;e<n;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};let st=nt;st.clippingPolygon=[],Object.defineProperty(st.prototype,"visible",{get(){return this._visible},set(t){t!==this._visible&&(this._visible=t,t&&(this.lastTime=0))}});const at={extension:f.Asset,loader:{extension:{type:f.LoadParser,priority:g.Normal},test:t=>p(t,".atlas"),async load(t){const e=await x.ADAPTER.fetch(t);return await e.text()},testParse(t,e){const n=p(e.src,".atlas"),s="string"==typeof t;return Promise.resolve(n&&s)},async parse(t,e,n){const s=e.data;let a=w.dirname(e.src);a&&a.lastIndexOf("/")!==a.length-1&&(a+="/");let r=null,i=null;const o=new Promise(((t,e)=>{r=t,i=e}));let l;const h=t=>{t||i("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load."),r(l)};if(s.image||s.images){const e=Object.assign(s.image?{default:s.image}:{},s.images);l=new Y(t,((t,n)=>{const s=e[t]||e.default;s&&s.baseTexture?n(s.baseTexture):n(s)}),h)}else l=new Y(t,rt(n,a,s.imageMetadata),h);return await o},unload(t){t.dispose()}}},rt=(t,e,n)=>async(s,a)=>{const r=w.normalize([...e.split(w.sep),s].join(w.sep));a((await t.load({src:r,data:n})).baseTexture)};function it(t){return t.hasOwnProperty("bones")}b.add(at);class ot{constructor(){}installLoader(){const t=this,e={extension:f.Asset,loader:{extension:{type:f.LoadParser,priority:g.Normal},test:t=>p(t,".skel"),async load(t){const e=await x.ADAPTER.fetch(t);return await e.arrayBuffer()},testParse(t,e){var n;const s=p(e.src,".json")&&it(t),a=p(e.src,".skel")&&t instanceof ArrayBuffer;const r=!1===(null==(n=e.data)?void 0:n.spineAtlas);return Promise.resolve(s&&!r||a)},async parse(e,n,s){const a=w.extname(n.src).toLowerCase(),r=w.basename(n.src,a);let i=w.dirname(n.src);i&&i.lastIndexOf("/")!==i.length-1&&(i+="/");let o=null,l=e;p(n.src,".json")&&it(e)?o=t.createJsonParser():(o=t.createBinaryParser(),l=new Uint8Array(e));const h=n.data||{},c=(null==h?void 0:h.spineSkeletonScale)??null;c&&(o.scale=c);const d=h.spineAtlas;if(d&&d.pages)return t.parseData(o,d,l);const u=h.atlasRawData;if(u){let e=null,n=null;const a=new Promise(((t,s)=>{e=t,n=s})),r=new Y(u,rt(s,i,h.imageMetadata),(t=>{t||n("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load."),e(r)})),c=await a;return t.parseData(o,c,l)}let m=h.spineAtlasFile;m||(m=`${i+r}.atlas`);const f=await s.load({src:m,data:h,alias:h.spineAtlasAlias});return t.parseData(o,f,l)}}};return b.add(e),e}}let lt=class{constructor(t){if(null==t)throw new Error("name cannot be null.");this.name=t}};const ht=class extends lt{constructor(t){super(t),this.id=(65535&ht.nextID++)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,n,s,a,r){n=a+(n>>1)*r;const i=t.bone.skeleton,o=t.deform;let l=this.vertices;const h=this.bones;if(null==h){o.length>0&&(l=o);const i=t.bone.matrix,h=i.tx,c=i.ty,d=i.a,u=i.c,m=i.b,f=i.d;for(let t=e,o=a;o<n;t+=2,o+=r){const e=l[t],n=l[t+1];s[o]=e*d+n*u+h,s[o+1]=e*m+n*f+c}return}let c=0,d=0;for(let m=0;m<e;m+=2){const t=h[c];c+=t+1,d+=t}const u=i.bones;if(0==o.length)for(let m=a,f=3*d;m<n;m+=r){let t=0,e=0,n=h[c++];for(n+=c;c<n;c++,f+=3){const n=u[h[c]].matrix,s=l[f],a=l[f+1],r=l[f+2];t+=(s*n.a+a*n.c+n.tx)*r,e+=(s*n.b+a*n.d+n.ty)*r}s[m]=t,s[m+1]=e}else{const t=o;for(let e=a,i=3*d,o=d<<1;e<n;e+=r){let n=0,a=0,r=h[c++];for(r+=c;c<r;c++,i+=3,o+=2){const e=u[h[c]].matrix,s=l[i]+t[o],r=l[i+1]+t[o+1],d=l[i+2];n+=(s*e.a+r*e.c+e.tx)*d,a+=(s*e.b+r*e.d+e.ty)*d}s[e]=n,s[e+1]=a}}}copyTo(t){null!=this.bones?(t.bones=new Array(this.bones.length),j.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,null!=this.vertices?(t.vertices=j.newFloatArray(this.vertices.length),j.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)):t.vertices=null,t.worldVerticesLength=this.worldVerticesLength,t.deformAttachment=this.deformAttachment}};let ct=ht;ct.nextID=0;let dt=class t extends ct{constructor(t){super(t),this.type=S.BoundingBox,this.color=new O(1,1,1,1)}copy(){const e=new t(this.name);return this.copyTo(e),e.color.setFromColor(this.color),e}},ut=class t extends ct{constructor(t){super(t),this.type=S.Clipping,this.color=new O(.2275,.2275,.8078,1)}copy(){const e=new t(this.name);return this.copyTo(e),e.endSlot=this.endSlot,e.color.setFromColor(this.color),e}},mt=class t extends ct{constructor(t){super(t),this.type=S.Mesh,this.color=new O(1,1,1,1),this.tempColor=new O(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,null!=t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(null!=this.parentMesh)return this.newLinkedMesh();const e=new t(this.name);return e.region=this.region,e.path=this.path,e.color.setFromColor(this.color),this.copyTo(e),e.regionUVs=new Float32Array(this.regionUVs.length),j.arrayCopy(this.regionUVs,0,e.regionUVs,0,this.regionUVs.length),e.triangles=new Array(this.triangles.length),j.arrayCopy(this.triangles,0,e.triangles,0,this.triangles.length),e.hullLength=this.hullLength,null!=this.edges&&(e.edges=new Array(this.edges.length),j.arrayCopy(this.edges,0,e.edges,0,this.edges.length)),e.width=this.width,e.height=this.height,e}newLinkedMesh(){const e=new t(this.name);return e.region=this.region,e.path=this.path,e.color.setFromColor(this.color),e.deformAttachment=this.deformAttachment,e.setParentMesh(null!=this.parentMesh?this.parentMesh:this),e}},ft=class t extends ct{constructor(t){super(t),this.type=S.Path,this.closed=!1,this.constantSpeed=!1,this.color=new O(1,1,1,1)}copy(){const e=new t(this.name);return this.copyTo(e),e.lengths=new Array(this.lengths.length),j.arrayCopy(this.lengths,0,e.lengths,0,this.lengths.length),e.closed=closed,e.constantSpeed=this.constantSpeed,e.color.setFromColor(this.color),e}},gt=class t extends ct{constructor(t){super(t),this.type=S.Point,this.color=new O(.38,.94,0,1)}computeWorldPosition(t,e){const n=t.matrix;return e.x=this.x*n.a+this.y*n.c+t.worldX,e.y=this.x*n.b+this.y*n.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,n=q.cosDeg(this.rotation),s=q.sinDeg(this.rotation),a=n*e.a+s*e.c,r=n*e.b+s*e.d;return Math.atan2(r,a)*q.radDeg}copy(){const e=new t(this.name);return e.x=this.x,e.y=this.y,e.rotation=this.rotation,e.color.setFromColor(this.color),e}},pt=class{constructor(t,e){if(this.deform=new Array,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new O,this.darkColor=null==t.darkColor?null:new O,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),null!=this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),null==this.data.attachmentName?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};const xt=class extends lt{constructor(t){super(t),this.type=S.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new O(1,1,1,1),this.offset=j.newFloatArray(8),this.uvs=j.newFloatArray(8),this.tempColor=new O(1,1,1,1)}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*t,s=-this.height/2*this.scaleY+this.region.offsetY*e,a=n+this.region.width*t,r=s+this.region.height*e,i=this.rotation*Math.PI/180,o=Math.cos(i),l=Math.sin(i),h=n*o+this.x,c=n*l,d=s*o+this.y,u=s*l,m=a*o+this.x,f=a*l,g=r*o+this.y,p=r*l,x=this.offset;x[xt.OX1]=h-u,x[xt.OY1]=d+c,x[xt.OX2]=h-p,x[xt.OY2]=g+c,x[xt.OX3]=m-p,x[xt.OY3]=g+f,x[xt.OX4]=m-u,x[xt.OY4]=d+f}setRegion(t){this.region=t;const e=this.uvs;t.rotate?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,n,s){const a=this.offset,r=t instanceof pt?t.bone.matrix:t.matrix,i=r.tx,o=r.ty,l=r.a,h=r.c,c=r.b,d=r.d;let u=0,m=0;u=a[xt.OX1],m=a[xt.OY1],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[xt.OX2],m=a[xt.OY2],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[xt.OX3],m=a[xt.OY3],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[xt.OX4],m=a[xt.OY4],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o}copy(){const t=new xt(this.name);return t.region=this.region,t.rendererObject=this.rendererObject,t.path=this.path,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,j.arrayCopy(this.uvs,0,t.uvs,0,8),j.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t}};let wt=xt;wt.OX1=0,wt.OY1=1,wt.OX2=2,wt.OY2=3,wt.OX3=4,wt.OY3=5,wt.OX4=6,wt.OY4=7,wt.X1=0,wt.Y1=1,wt.C1R=2,wt.C1G=3,wt.C1B=4,wt.C1A=5,wt.U1=6,wt.V1=7,wt.X2=8,wt.Y2=9,wt.C2R=10,wt.C2G=11,wt.C2B=12,wt.C2A=13,wt.U2=14,wt.V2=15,wt.X3=16,wt.Y3=17,wt.C3R=18,wt.C3G=19,wt.C3B=20,wt.C3A=21,wt.U3=22,wt.V3=23,wt.X4=24,wt.Y4=25,wt.C4R=26,wt.C4G=27,wt.C4B=28,wt.C4A=29,wt.U4=30,wt.V4=31;const bt=class{constructor(t){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,e,n,s){const a=this.angle*q.degreesToRadians,r=t.x-this.worldX,i=t.y-this.worldY,o=Math.sqrt(r*r+i*i);if(o<this.radius){const e=bt.interpolation.apply(0,a,(this.radius-o)/this.radius),n=Math.cos(e),s=Math.sin(e);t.x=n*r-s*i+this.worldX,t.y=s*r+n*i+this.worldY}}end(){}};let Et=bt;Et.interpolation=new z(2);let yt=class{constructor(t,e,n){if(null==t)throw new Error("name cannot be null.");if(null==e)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.timelineIds=[];for(let s=0;s<e.length;s++)this.timelineIds[e[s].getPropertyId()]=!0;this.duration=n}hasTimeline(t){return 1==this.timelineIds[t]}apply(t,e,n,s,a,r,i,o){if(null==t)throw new Error("skeleton cannot be null.");s&&0!=this.duration&&(n%=this.duration,e>0&&(e%=this.duration));const l=this.timelines;for(let h=0,c=l.length;h<c;h++)l[h].apply(t,e,n,a,r,i,o)}static binarySearch(t,e,n=1){let s=0,a=t.length/n-2;if(0==a)return n;let r=a>>>1;for(;;){if(t[(r+1)*n]<=e?s=r+1:a=r,s==a)return(s+1)*n;r=s+a>>>1}}static linearSearch(t,e,n){for(let s=0,a=t.length-n;s<=a;s+=n)if(t[s]>e)return s;return-1}};var St=(t=>(t[t.rotate=0]="rotate",t[t.translate=1]="translate",t[t.scale=2]="scale",t[t.shear=3]="shear",t[t.attachment=4]="attachment",t[t.color=5]="color",t[t.deform=6]="deform",t[t.event=7]="event",t[t.drawOrder=8]="drawOrder",t[t.ikConstraint=9]="ikConstraint",t[t.transformConstraint=10]="transformConstraint",t[t.pathConstraintPosition=11]="pathConstraintPosition",t[t.pathConstraintSpacing=12]="pathConstraintSpacing",t[t.pathConstraintMix=13]="pathConstraintMix",t[t.twoColor=14]="twoColor",t))(St||{});const Mt=class{constructor(t){if(t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=j.newFloatArray((t-1)*Mt.BEZIER_SIZE)}getFrameCount(){return this.curves.length/Mt.BEZIER_SIZE+1}setLinear(t){this.curves[t*Mt.BEZIER_SIZE]=Mt.LINEAR}setStepped(t){this.curves[t*Mt.BEZIER_SIZE]=Mt.STEPPED}getCurveType(t){const e=t*Mt.BEZIER_SIZE;if(e==this.curves.length)return Mt.LINEAR;const n=this.curves[e];return n==Mt.LINEAR?Mt.LINEAR:n==Mt.STEPPED?Mt.STEPPED:Mt.BEZIER}setCurve(t,e,n,s,a){const r=.03*(2*-e+s),i=.03*(2*-n+a),o=.006*(3*(e-s)+1),l=.006*(3*(n-a)+1);let h=2*r+o,c=2*i+l,d=.3*e+r+.16666667*o,u=.3*n+i+.16666667*l,m=t*Mt.BEZIER_SIZE;const f=this.curves;f[m++]=Mt.BEZIER;let g=d,p=u;for(let x=m+Mt.BEZIER_SIZE-1;m<x;m+=2)f[m]=g,f[m+1]=p,d+=h,u+=c,h+=o,c+=l,g+=d,p+=u}getCurvePercent(t,e){e=q.clamp(e,0,1);const n=this.curves;let s=t*Mt.BEZIER_SIZE;const a=n[s];if(a==Mt.LINEAR)return e;if(a==Mt.STEPPED)return 0;s++;let r=0;for(let o=s,l=s+Mt.BEZIER_SIZE-1;s<l;s+=2)if(r=n[s],r>=e){let t,a;return s==o?(t=0,a=0):(t=n[s-2],a=n[s-1]),a+(n[s+1]-a)*(e-t)/(r-t)}const i=n[s-1];return i+(1-i)*(e-r)/(1-r)}};let At=Mt;At.LINEAR=0,At.STEPPED=1,At.BEZIER=2,At.BEZIER_SIZE=19;const It=class extends At{constructor(t){super(t),this.frames=j.newFloatArray(t<<1)}getPropertyId(){return 0+this.boneIndex}setFrame(t,e,n){t<<=1,this.frames[t]=e,this.frames[t+It.ROTATION]=n}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.bones[this.boneIndex];if(!l.active)return;if(n<o[0]){switch(r){case A.setup:return void(l.rotation=l.data.rotation);case A.first:const t=l.data.rotation-l.rotation;l.rotation+=(t-360*(16384-(16384.499999999996-t/360|0)))*a}return}if(n>=o[o.length-It.ENTRIES]){let t=o[o.length+It.PREV_ROTATION];switch(r){case A.setup:l.rotation=l.data.rotation+t*a;break;case A.first:case A.replace:t+=l.data.rotation-l.rotation,t-=360*(16384-(16384.499999999996-t/360|0));case A.add:l.rotation+=t*a}return}const h=yt.binarySearch(o,n,It.ENTRIES),c=o[h+It.PREV_ROTATION],d=o[h],u=this.getCurvePercent((h>>1)-1,1-(n-d)/(o[h+It.PREV_TIME]-d));let m=o[h+It.ROTATION]-c;switch(m=c+(m-360*(16384-(16384.499999999996-m/360|0)))*u,r){case A.setup:l.rotation=l.data.rotation+(m-360*(16384-(16384.499999999996-m/360|0)))*a;break;case A.first:case A.replace:m+=l.data.rotation-l.rotation;case A.add:l.rotation+=(m-360*(16384-(16384.499999999996-m/360|0)))*a}}};let Tt=It;Tt.ENTRIES=2,Tt.PREV_TIME=-2,Tt.PREV_ROTATION=-1,Tt.ROTATION=1;const kt=class extends At{constructor(t){super(t),this.frames=j.newFloatArray(t*kt.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,e,n,s){t*=kt.ENTRIES,this.frames[t]=e,this.frames[t+kt.X]=n,this.frames[t+kt.Y]=s}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.bones[this.boneIndex];if(!l.active)return;if(n<o[0]){switch(r){case A.setup:return l.x=l.data.x,void(l.y=l.data.y);case A.first:l.x+=(l.data.x-l.x)*a,l.y+=(l.data.y-l.y)*a}return}let h=0,c=0;if(n>=o[o.length-kt.ENTRIES])h=o[o.length+kt.PREV_X],c=o[o.length+kt.PREV_Y];else{const t=yt.binarySearch(o,n,kt.ENTRIES);h=o[t+kt.PREV_X],c=o[t+kt.PREV_Y];const e=o[t],s=this.getCurvePercent(t/kt.ENTRIES-1,1-(n-e)/(o[t+kt.PREV_TIME]-e));h+=(o[t+kt.X]-h)*s,c+=(o[t+kt.Y]-c)*s}switch(r){case A.setup:l.x=l.data.x+h*a,l.y=l.data.y+c*a;break;case A.first:case A.replace:l.x+=(l.data.x+h-l.x)*a,l.y+=(l.data.y+c-l.y)*a;break;case A.add:l.x+=h*a,l.y+=c*a}}};let Rt=kt;Rt.ENTRIES=3,Rt.PREV_TIME=-3,Rt.PREV_X=-2,Rt.PREV_Y=-1,Rt.X=1,Rt.Y=2;let Ct=class t extends Rt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(e,n,s,a,r,i,o){const l=this.frames,h=e.bones[this.boneIndex];if(!h.active)return;if(s<l[0]){switch(i){case A.setup:return h.scaleX=h.data.scaleX,void(h.scaleY=h.data.scaleY);case A.first:h.scaleX+=(h.data.scaleX-h.scaleX)*r,h.scaleY+=(h.data.scaleY-h.scaleY)*r}return}let c=0,d=0;if(s>=l[l.length-t.ENTRIES])c=l[l.length+t.PREV_X]*h.data.scaleX,d=l[l.length+t.PREV_Y]*h.data.scaleY;else{const e=yt.binarySearch(l,s,t.ENTRIES);c=l[e+t.PREV_X],d=l[e+t.PREV_Y];const n=l[e],a=this.getCurvePercent(e/t.ENTRIES-1,1-(s-n)/(l[e+t.PREV_TIME]-n));c=(c+(l[e+t.X]-c)*a)*h.data.scaleX,d=(d+(l[e+t.Y]-d)*a)*h.data.scaleY}if(1==r)i==A.add?(h.scaleX+=c-h.data.scaleX,h.scaleY+=d-h.data.scaleY):(h.scaleX=c,h.scaleY=d);else{let t=0,e=0;if(o==I.mixOut)switch(i){case A.setup:t=h.data.scaleX,e=h.data.scaleY,h.scaleX=t+(Math.abs(c)*q.signum(t)-t)*r,h.scaleY=e+(Math.abs(d)*q.signum(e)-e)*r;break;case A.first:case A.replace:t=h.scaleX,e=h.scaleY,h.scaleX=t+(Math.abs(c)*q.signum(t)-t)*r,h.scaleY=e+(Math.abs(d)*q.signum(e)-e)*r;break;case A.add:t=h.scaleX,e=h.scaleY,h.scaleX=t+(Math.abs(c)*q.signum(t)-h.data.scaleX)*r,h.scaleY=e+(Math.abs(d)*q.signum(e)-h.data.scaleY)*r}else switch(i){case A.setup:t=Math.abs(h.data.scaleX)*q.signum(c),e=Math.abs(h.data.scaleY)*q.signum(d),h.scaleX=t+(c-t)*r,h.scaleY=e+(d-e)*r;break;case A.first:case A.replace:t=Math.abs(h.scaleX)*q.signum(c),e=Math.abs(h.scaleY)*q.signum(d),h.scaleX=t+(c-t)*r,h.scaleY=e+(d-e)*r;break;case A.add:t=q.signum(c),e=q.signum(d),h.scaleX=Math.abs(h.scaleX)*t+(c-Math.abs(h.data.scaleX)*t)*r,h.scaleY=Math.abs(h.scaleY)*e+(d-Math.abs(h.data.scaleY)*e)*r}}}},Vt=class t extends Rt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(e,n,s,a,r,i,o){const l=this.frames,h=e.bones[this.boneIndex];if(!h.active)return;if(s<l[0]){switch(i){case A.setup:return h.shearX=h.data.shearX,void(h.shearY=h.data.shearY);case A.first:h.shearX+=(h.data.shearX-h.shearX)*r,h.shearY+=(h.data.shearY-h.shearY)*r}return}let c=0,d=0;if(s>=l[l.length-t.ENTRIES])c=l[l.length+t.PREV_X],d=l[l.length+t.PREV_Y];else{const e=yt.binarySearch(l,s,t.ENTRIES);c=l[e+t.PREV_X],d=l[e+t.PREV_Y];const n=l[e],a=this.getCurvePercent(e/t.ENTRIES-1,1-(s-n)/(l[e+t.PREV_TIME]-n));c+=(l[e+t.X]-c)*a,d+=(l[e+t.Y]-d)*a}switch(i){case A.setup:h.shearX=h.data.shearX+c*r,h.shearY=h.data.shearY+d*r;break;case A.first:case A.replace:h.shearX+=(h.data.shearX+c-h.shearX)*r,h.shearY+=(h.data.shearY+d-h.shearY)*r;break;case A.add:h.shearX+=c*r,h.shearY+=d*r}}};const vt=class extends At{constructor(t){super(t),this.frames=j.newFloatArray(t*vt.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,e,n,s,a,r){t*=vt.ENTRIES,this.frames[t]=e,this.frames[t+vt.R]=n,this.frames[t+vt.G]=s,this.frames[t+vt.B]=a,this.frames[t+vt.A]=r}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;const l=this.frames;if(n<l[0]){switch(r){case A.setup:return void o.color.setFromColor(o.data.color);case A.first:const t=o.color,e=o.data.color;t.add((e.r-t.r)*a,(e.g-t.g)*a,(e.b-t.b)*a,(e.a-t.a)*a)}return}let h=0,c=0,d=0,u=0;if(n>=l[l.length-vt.ENTRIES]){const t=l.length;h=l[t+vt.PREV_R],c=l[t+vt.PREV_G],d=l[t+vt.PREV_B],u=l[t+vt.PREV_A]}else{const t=yt.binarySearch(l,n,vt.ENTRIES);h=l[t+vt.PREV_R],c=l[t+vt.PREV_G],d=l[t+vt.PREV_B],u=l[t+vt.PREV_A];const e=l[t],s=this.getCurvePercent(t/vt.ENTRIES-1,1-(n-e)/(l[t+vt.PREV_TIME]-e));h+=(l[t+vt.R]-h)*s,c+=(l[t+vt.G]-c)*s,d+=(l[t+vt.B]-d)*s,u+=(l[t+vt.A]-u)*s}if(1==a)o.color.set(h,c,d,u);else{const t=o.color;r==A.setup&&t.setFromColor(o.data.color),t.add((h-t.r)*a,(c-t.g)*a,(d-t.b)*a,(u-t.a)*a)}}};let Pt=vt;Pt.ENTRIES=5,Pt.PREV_TIME=-5,Pt.PREV_R=-4,Pt.PREV_G=-3,Pt.PREV_B=-2,Pt.PREV_A=-1,Pt.R=1,Pt.G=2,Pt.B=3,Pt.A=4;const Ft=class extends At{constructor(t){super(t),this.frames=j.newFloatArray(t*Ft.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,e,n,s,a,r,i,o,l){t*=Ft.ENTRIES,this.frames[t]=e,this.frames[t+Ft.R]=n,this.frames[t+Ft.G]=s,this.frames[t+Ft.B]=a,this.frames[t+Ft.A]=r,this.frames[t+Ft.R2]=i,this.frames[t+Ft.G2]=o,this.frames[t+Ft.B2]=l}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;const l=this.frames;if(n<l[0]){switch(r){case A.setup:return o.color.setFromColor(o.data.color),void o.darkColor.setFromColor(o.data.darkColor);case A.first:const t=o.color,e=o.darkColor,n=o.data.color,s=o.data.darkColor;t.add((n.r-t.r)*a,(n.g-t.g)*a,(n.b-t.b)*a,(n.a-t.a)*a),e.add((s.r-e.r)*a,(s.g-e.g)*a,(s.b-e.b)*a,0)}return}let h=0,c=0,d=0,u=0,m=0,f=0,g=0;if(n>=l[l.length-Ft.ENTRIES]){const t=l.length;h=l[t+Ft.PREV_R],c=l[t+Ft.PREV_G],d=l[t+Ft.PREV_B],u=l[t+Ft.PREV_A],m=l[t+Ft.PREV_R2],f=l[t+Ft.PREV_G2],g=l[t+Ft.PREV_B2]}else{const t=yt.binarySearch(l,n,Ft.ENTRIES);h=l[t+Ft.PREV_R],c=l[t+Ft.PREV_G],d=l[t+Ft.PREV_B],u=l[t+Ft.PREV_A],m=l[t+Ft.PREV_R2],f=l[t+Ft.PREV_G2],g=l[t+Ft.PREV_B2];const e=l[t],s=this.getCurvePercent(t/Ft.ENTRIES-1,1-(n-e)/(l[t+Ft.PREV_TIME]-e));h+=(l[t+Ft.R]-h)*s,c+=(l[t+Ft.G]-c)*s,d+=(l[t+Ft.B]-d)*s,u+=(l[t+Ft.A]-u)*s,m+=(l[t+Ft.R2]-m)*s,f+=(l[t+Ft.G2]-f)*s,g+=(l[t+Ft.B2]-g)*s}if(1==a)o.color.set(h,c,d,u),o.darkColor.set(m,f,g,1);else{const t=o.color,e=o.darkColor;r==A.setup&&(t.setFromColor(o.data.color),e.setFromColor(o.data.darkColor)),t.add((h-t.r)*a,(c-t.g)*a,(d-t.b)*a,(u-t.a)*a),e.add((m-e.r)*a,(f-e.g)*a,(g-e.b)*a,0)}}};let Yt=Ft;Yt.ENTRIES=8,Yt.PREV_TIME=-8,Yt.PREV_R=-7,Yt.PREV_G=-6,Yt.PREV_B=-5,Yt.PREV_A=-4,Yt.PREV_R2=-3,Yt.PREV_G2=-2,Yt.PREV_B2=-1,Yt.R=1,Yt.G=2,Yt.B=3,Yt.A=4,Yt.R2=5,Yt.G2=6,Yt.B2=7;let Nt=class{constructor(t){this.frames=j.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.attachmentNames[t]=n}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;if(i==I.mixOut)return void(r==A.setup&&this.setAttachment(t,o,o.data.attachmentName));const l=this.frames;if(n<l[0])return void(r!=A.setup&&r!=A.first||this.setAttachment(t,o,o.data.attachmentName));let h=0;h=n>=l[l.length-1]?l.length-1:yt.binarySearch(l,n,1)-1;const c=this.attachmentNames[h];t.slots[this.slotIndex].setAttachment(null==c?null:t.getAttachment(this.slotIndex,c))}setAttachment(t,e,n){e.setAttachment(null==n?null:t.getAttachment(this.slotIndex,n))}},Xt=null,Dt=class extends At{constructor(t){super(t),this.frames=j.newFloatArray(t),this.frameVertices=new Array(t),null==Xt&&(Xt=j.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,e,n){this.frames[t]=e,this.frameVertices[t]=n}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;const l=o.getAttachment();if(!(l instanceof ct)||l.deformAttachment!=this.attachment)return;const h=o.deform;0==h.length&&(r=A.setup);const c=this.frameVertices,d=c[0].length,u=this.frames;if(n<u[0]){const t=l;switch(r){case A.setup:return void(h.length=0);case A.first:if(1==a){h.length=0;break}const e=j.setArraySize(h,d);if(null==t.bones){const n=t.vertices;for(let t=0;t<d;t++)e[t]+=(n[t]-e[t])*a}else{a=1-a;for(let t=0;t<d;t++)e[t]*=a}}return}const m=j.setArraySize(h,d);if(n>=u[u.length-1]){const t=c[u.length-1];if(1==a)if(r==A.add){const e=l;if(null==e.bones){const n=e.vertices;for(let e=0;e<d;e++)m[e]+=t[e]-n[e]}else for(let n=0;n<d;n++)m[n]+=t[n]}else j.arrayCopy(t,0,m,0,d);else switch(r){case A.setup:{const e=l;if(null==e.bones){const n=e.vertices;for(let e=0;e<d;e++){const s=n[e];m[e]=s+(t[e]-s)*a}}else for(let n=0;n<d;n++)m[n]=t[n]*a;break}case A.first:case A.replace:for(let n=0;n<d;n++)m[n]+=(t[n]-m[n])*a;break;case A.add:const e=l;if(null==e.bones){const n=e.vertices;for(let e=0;e<d;e++)m[e]+=(t[e]-n[e])*a}else for(let n=0;n<d;n++)m[n]+=t[n]*a}return}const f=yt.binarySearch(u,n),g=c[f-1],p=c[f],x=u[f],w=this.getCurvePercent(f-1,1-(n-x)/(u[f-1]-x));if(1==a)if(r==A.add){const t=l;if(null==t.bones){const e=t.vertices;for(let t=0;t<d;t++){const n=g[t];m[t]+=n+(p[t]-n)*w-e[t]}}else for(let e=0;e<d;e++){const t=g[e];m[e]+=t+(p[e]-t)*w}}else for(let b=0;b<d;b++){const t=g[b];m[b]=t+(p[b]-t)*w}else switch(r){case A.setup:{const t=l;if(null==t.bones){const e=t.vertices;for(let t=0;t<d;t++){const n=g[t],s=e[t];m[t]=s+(n+(p[t]-n)*w-s)*a}}else for(let e=0;e<d;e++){const t=g[e];m[e]=(t+(p[e]-t)*w)*a}break}case A.first:case A.replace:for(let e=0;e<d;e++){const t=g[e];m[e]+=(t+(p[e]-t)*w-m[e])*a}break;case A.add:const t=l;if(null==t.bones){const e=t.vertices;for(let t=0;t<d;t++){const n=g[t];m[t]+=(n+(p[t]-n)*w-e[t])*a}}else for(let e=0;e<d;e++){const t=g[e];m[e]+=(t+(p[e]-t)*w)*a}}}},Bt=class{constructor(t){this.frames=j.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,n,s,a,r,i){if(null==s)return;const o=this.frames,l=this.frames.length;if(e>n)this.apply(t,e,Number.MAX_VALUE,s,a,r,i),e=-1;else if(e>=o[l-1])return;if(n<o[0])return;let h=0;if(e<o[0])h=0;else{h=yt.binarySearch(o,e);const t=o[h];for(;h>0&&o[h-1]==t;)h--}for(;h<l&&n>=o[h];h++)s.push(this.events[h])}},Lt=class{constructor(t){this.frames=j.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.drawOrders[t]=n}apply(t,e,n,s,a,r,i){const o=t.drawOrder,l=t.slots;if(i==I.mixOut&&r==A.setup)return void j.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);const h=this.frames;if(n<h[0])return void(r!=A.setup&&r!=A.first||j.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length));let c=0;c=n>=h[h.length-1]?h.length-1:yt.binarySearch(h,n)-1;const d=this.drawOrders[c];if(null==d)j.arrayCopy(l,0,o,0,l.length);else for(let u=0,m=d.length;u<m;u++)o[u]=l[d[u]]}};const _t=class extends At{constructor(t){super(t),this.frames=j.newFloatArray(t*_t.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,e,n,s,a,r,i){t*=_t.ENTRIES,this.frames[t]=e,this.frames[t+_t.MIX]=n,this.frames[t+_t.SOFTNESS]=s,this.frames[t+_t.BEND_DIRECTION]=a,this.frames[t+_t.COMPRESS]=r?1:0,this.frames[t+_t.STRETCH]=i?1:0}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.ikConstraints[this.ikConstraintIndex];if(!l.active)return;if(n<o[0]){switch(r){case A.setup:return l.mix=l.data.mix,l.softness=l.data.softness,l.bendDirection=l.data.bendDirection,l.compress=l.data.compress,void(l.stretch=l.data.stretch);case A.first:l.mix+=(l.data.mix-l.mix)*a,l.softness+=(l.data.softness-l.softness)*a,l.bendDirection=l.data.bendDirection,l.compress=l.data.compress,l.stretch=l.data.stretch}return}if(n>=o[o.length-_t.ENTRIES])return void(r==A.setup?(l.mix=l.data.mix+(o[o.length+_t.PREV_MIX]-l.data.mix)*a,l.softness=l.data.softness+(o[o.length+_t.PREV_SOFTNESS]-l.data.softness)*a,i==I.mixOut?(l.bendDirection=l.data.bendDirection,l.compress=l.data.compress,l.stretch=l.data.stretch):(l.bendDirection=o[o.length+_t.PREV_BEND_DIRECTION],l.compress=0!=o[o.length+_t.PREV_COMPRESS],l.stretch=0!=o[o.length+_t.PREV_STRETCH])):(l.mix+=(o[o.length+_t.PREV_MIX]-l.mix)*a,l.softness+=(o[o.length+_t.PREV_SOFTNESS]-l.softness)*a,i==I.mixIn&&(l.bendDirection=o[o.length+_t.PREV_BEND_DIRECTION],l.compress=0!=o[o.length+_t.PREV_COMPRESS],l.stretch=0!=o[o.length+_t.PREV_STRETCH])));const h=yt.binarySearch(o,n,_t.ENTRIES),c=o[h+_t.PREV_MIX],d=o[h+_t.PREV_SOFTNESS],u=o[h],m=this.getCurvePercent(h/_t.ENTRIES-1,1-(n-u)/(o[h+_t.PREV_TIME]-u));r==A.setup?(l.mix=l.data.mix+(c+(o[h+_t.MIX]-c)*m-l.data.mix)*a,l.softness=l.data.softness+(d+(o[h+_t.SOFTNESS]-d)*m-l.data.softness)*a,i==I.mixOut?(l.bendDirection=l.data.bendDirection,l.compress=l.data.compress,l.stretch=l.data.stretch):(l.bendDirection=o[h+_t.PREV_BEND_DIRECTION],l.compress=0!=o[h+_t.PREV_COMPRESS],l.stretch=0!=o[h+_t.PREV_STRETCH])):(l.mix+=(c+(o[h+_t.MIX]-c)*m-l.mix)*a,l.softness+=(d+(o[h+_t.SOFTNESS]-d)*m-l.softness)*a,i==I.mixIn&&(l.bendDirection=o[h+_t.PREV_BEND_DIRECTION],l.compress=0!=o[h+_t.PREV_COMPRESS],l.stretch=0!=o[h+_t.PREV_STRETCH]))}};let Ot=_t;Ot.ENTRIES=6,Ot.PREV_TIME=-6,Ot.PREV_MIX=-5,Ot.PREV_SOFTNESS=-4,Ot.PREV_BEND_DIRECTION=-3,Ot.PREV_COMPRESS=-2,Ot.PREV_STRETCH=-1,Ot.MIX=1,Ot.SOFTNESS=2,Ot.BEND_DIRECTION=3,Ot.COMPRESS=4,Ot.STRETCH=5;const Wt=class extends At{constructor(t){super(t),this.frames=j.newFloatArray(t*Wt.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,e,n,s,a,r){t*=Wt.ENTRIES,this.frames[t]=e,this.frames[t+Wt.ROTATE]=n,this.frames[t+Wt.TRANSLATE]=s,this.frames[t+Wt.SCALE]=a,this.frames[t+Wt.SHEAR]=r}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.transformConstraints[this.transformConstraintIndex];if(!l.active)return;if(n<o[0]){const t=l.data;switch(r){case A.setup:return l.rotateMix=t.rotateMix,l.translateMix=t.translateMix,l.scaleMix=t.scaleMix,void(l.shearMix=t.shearMix);case A.first:l.rotateMix+=(t.rotateMix-l.rotateMix)*a,l.translateMix+=(t.translateMix-l.translateMix)*a,l.scaleMix+=(t.scaleMix-l.scaleMix)*a,l.shearMix+=(t.shearMix-l.shearMix)*a}return}let h=0,c=0,d=0,u=0;if(n>=o[o.length-Wt.ENTRIES]){const t=o.length;h=o[t+Wt.PREV_ROTATE],c=o[t+Wt.PREV_TRANSLATE],d=o[t+Wt.PREV_SCALE],u=o[t+Wt.PREV_SHEAR]}else{const t=yt.binarySearch(o,n,Wt.ENTRIES);h=o[t+Wt.PREV_ROTATE],c=o[t+Wt.PREV_TRANSLATE],d=o[t+Wt.PREV_SCALE],u=o[t+Wt.PREV_SHEAR];const e=o[t],s=this.getCurvePercent(t/Wt.ENTRIES-1,1-(n-e)/(o[t+Wt.PREV_TIME]-e));h+=(o[t+Wt.ROTATE]-h)*s,c+=(o[t+Wt.TRANSLATE]-c)*s,d+=(o[t+Wt.SCALE]-d)*s,u+=(o[t+Wt.SHEAR]-u)*s}if(r==A.setup){const t=l.data;l.rotateMix=t.rotateMix+(h-t.rotateMix)*a,l.translateMix=t.translateMix+(c-t.translateMix)*a,l.scaleMix=t.scaleMix+(d-t.scaleMix)*a,l.shearMix=t.shearMix+(u-t.shearMix)*a}else l.rotateMix+=(h-l.rotateMix)*a,l.translateMix+=(c-l.translateMix)*a,l.scaleMix+=(d-l.scaleMix)*a,l.shearMix+=(u-l.shearMix)*a}};let qt=Wt;qt.ENTRIES=5,qt.PREV_TIME=-5,qt.PREV_ROTATE=-4,qt.PREV_TRANSLATE=-3,qt.PREV_SCALE=-2,qt.PREV_SHEAR=-1,qt.ROTATE=1,qt.TRANSLATE=2,qt.SCALE=3,qt.SHEAR=4;const $t=class extends At{constructor(t){super(t),this.frames=j.newFloatArray(t*$t.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,e,n){t*=$t.ENTRIES,this.frames[t]=e,this.frames[t+$t.VALUE]=n}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.pathConstraints[this.pathConstraintIndex];if(!l.active)return;if(n<o[0]){switch(r){case A.setup:return void(l.position=l.data.position);case A.first:l.position+=(l.data.position-l.position)*a}return}let h=0;if(n>=o[o.length-$t.ENTRIES])h=o[o.length+$t.PREV_VALUE];else{const t=yt.binarySearch(o,n,$t.ENTRIES);h=o[t+$t.PREV_VALUE];const e=o[t],s=this.getCurvePercent(t/$t.ENTRIES-1,1-(n-e)/(o[t+$t.PREV_TIME]-e));h+=(o[t+$t.VALUE]-h)*s}r==A.setup?l.position=l.data.position+(h-l.data.position)*a:l.position+=(h-l.position)*a}};let Ut=$t;Ut.ENTRIES=2,Ut.PREV_TIME=-2,Ut.PREV_VALUE=-1,Ut.VALUE=1;let zt=class t extends Ut{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(e,n,s,a,r,i,o){const l=this.frames,h=e.pathConstraints[this.pathConstraintIndex];if(!h.active)return;if(s<l[0]){switch(i){case A.setup:return void(h.spacing=h.data.spacing);case A.first:h.spacing+=(h.data.spacing-h.spacing)*r}return}let c=0;if(s>=l[l.length-t.ENTRIES])c=l[l.length+t.PREV_VALUE];else{const e=yt.binarySearch(l,s,t.ENTRIES);c=l[e+t.PREV_VALUE];const n=l[e],a=this.getCurvePercent(e/t.ENTRIES-1,1-(s-n)/(l[e+t.PREV_TIME]-n));c+=(l[e+t.VALUE]-c)*a}i==A.setup?h.spacing=h.data.spacing+(c-h.data.spacing)*r:h.spacing+=(c-h.spacing)*r}};const Ht=class extends At{constructor(t){super(t),this.frames=j.newFloatArray(t*Ht.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,e,n,s){t*=Ht.ENTRIES,this.frames[t]=e,this.frames[t+Ht.ROTATE]=n,this.frames[t+Ht.TRANSLATE]=s}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.pathConstraints[this.pathConstraintIndex];if(!l.active)return;if(n<o[0]){switch(r){case A.setup:return l.rotateMix=l.data.rotateMix,void(l.translateMix=l.data.translateMix);case A.first:l.rotateMix+=(l.data.rotateMix-l.rotateMix)*a,l.translateMix+=(l.data.translateMix-l.translateMix)*a}return}let h=0,c=0;if(n>=o[o.length-Ht.ENTRIES])h=o[o.length+Ht.PREV_ROTATE],c=o[o.length+Ht.PREV_TRANSLATE];else{const t=yt.binarySearch(o,n,Ht.ENTRIES);h=o[t+Ht.PREV_ROTATE],c=o[t+Ht.PREV_TRANSLATE];const e=o[t],s=this.getCurvePercent(t/Ht.ENTRIES-1,1-(n-e)/(o[t+Ht.PREV_TIME]-e));h+=(o[t+Ht.ROTATE]-h)*s,c+=(o[t+Ht.TRANSLATE]-c)*s}r==A.setup?(l.rotateMix=l.data.rotateMix+(h-l.data.rotateMix)*a,l.translateMix=l.data.translateMix+(c-l.data.translateMix)*a):(l.rotateMix+=(h-l.rotateMix)*a,l.translateMix+=(c-l.translateMix)*a)}};let jt=Ht;jt.ENTRIES=3,jt.PREV_TIME=-3,jt.PREV_ROTATE=-2,jt.PREV_TRANSLATE=-1,jt.ROTATE=1,jt.TRANSLATE=2;const Gt=class{constructor(t){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new te(this),this.propertyIDs=new B,this.animationsChanged=!1,this.trackEntryPool=new G((()=>new Kt)),this.data=t}update(t){t*=this.timeScale;const e=this.tracks;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(null==s)continue;s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast;let a=t*s.timeScale;if(s.delay>0){if(s.delay-=a,s.delay>0)continue;a=-s.delay,s.delay=0}let r=s.next;if(null!=r){const e=s.trackLast-r.delay;if(e>=0){for(r.delay=0,r.trackTime+=0==s.timeScale?0:(e/s.timeScale+t)*r.timeScale,s.trackTime+=a,this.setCurrent(n,r,!0);null!=r.mixingFrom;)r.mixTime+=t,r=r.mixingFrom;continue}}else if(s.trackLast>=s.trackEnd&&null==s.mixingFrom){e[n]=null,this.queue.end(s),this.disposeNext(s);continue}if(null!=s.mixingFrom&&this.updateMixingFrom(s,t)){let t=s.mixingFrom;for(s.mixingFrom=null,null!=t&&(t.mixingTo=null);null!=t;)this.queue.end(t),t=t.mixingFrom}s.trackTime+=a}this.queue.drain()}updateMixingFrom(t,e){const n=t.mixingFrom;if(null==n)return!0;const s=this.updateMixingFrom(n,e);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?(0!=n.totalAlpha&&0!=t.mixDuration||(t.mixingFrom=n.mixingFrom,null!=n.mixingFrom&&(n.mixingFrom.mixingTo=t),t.interruptAlpha=n.interruptAlpha,this.queue.end(n)),s):(n.trackTime+=e*n.timeScale,t.mixTime+=e,!1)}apply(t){if(null==t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,n=this.tracks;let s=!1;for(let i=0,o=n.length;i<o;i++){const a=n[i];if(null==a||a.delay>0)continue;s=!0;const r=0==i?A.first:a.mixBlend;let o=a.alpha;null!=a.mixingFrom?o*=this.applyMixingFrom(a,t,r):a.trackTime>=a.trackEnd&&null==a.next&&(o=0);const l=a.animationLast,h=a.getAnimationTime(),c=a.animation.timelines.length,d=a.animation.timelines;if(0==i&&1==o||r==A.add)for(let n=0;n<c;n++){const s=d[n];s instanceof Nt?this.applyAttachmentTimeline(s,t,h,r,!0):s.apply(t,l,h,e,o,r,I.mixIn)}else{const n=a.timelineMode,s=0==a.timelinesRotation.length;s&&j.setArraySize(a.timelinesRotation,c<<1,null);const i=a.timelinesRotation;for(let a=0;a<c;a++){const c=d[a],u=n[a]==Gt.SUBSEQUENT?r:A.setup;c instanceof Tt?this.applyRotateTimeline(c,t,h,o,u,i,a<<1,s):c instanceof Nt?this.applyAttachmentTimeline(c,t,h,r,!0):c.apply(t,l,h,e,o,u,I.mixIn)}}this.queueEvents(a,h),e.length=0,a.nextAnimationLast=h,a.nextTrackLast=a.trackTime}const a=this.unkeyedState+Gt.SETUP,r=t.slots;for(let i=0,o=t.slots.length;i<o;i++){const e=r[i];if(e.attachmentState==a){const n=e.data.attachmentName;e.setAttachment(null==n?null:t.getAttachment(e.data.index,n))}}return this.unkeyedState+=2,this.queue.drain(),s}applyMixingFrom(t,e,n){const s=t.mixingFrom;null!=s.mixingFrom&&this.applyMixingFrom(s,e,n);let a=0;0==t.mixDuration?(a=1,n==A.first&&(n=A.setup)):(a=t.mixTime/t.mixDuration,a>1&&(a=1),n!=A.first&&(n=s.mixBlend));const r=a<s.eventThreshold?this.events:null,i=a<s.attachmentThreshold,o=a<s.drawOrderThreshold,l=s.animationLast,h=s.getAnimationTime(),c=s.animation.timelines.length,d=s.animation.timelines,u=s.alpha*t.interruptAlpha,m=u*(1-a);if(n==A.add)for(let f=0;f<c;f++)d[f].apply(e,l,h,r,m,n,I.mixOut);else{const t=s.timelineMode,a=s.timelineHoldMix,f=0==s.timelinesRotation.length;f&&j.setArraySize(s.timelinesRotation,c<<1,null);const g=s.timelinesRotation;s.totalAlpha=0;for(let p=0;p<c;p++){const c=d[p];let x,w=I.mixOut,b=0;switch(t[p]){case Gt.SUBSEQUENT:if(!o&&c instanceof Lt)continue;x=n,b=m;break;case Gt.FIRST:x=A.setup,b=m;break;case Gt.HOLD_SUBSEQUENT:x=n,b=u;break;case Gt.HOLD_FIRST:x=A.setup,b=u;break;default:x=A.setup;const t=a[p];b=u*Math.max(0,1-t.mixTime/t.mixDuration)}s.totalAlpha+=b,c instanceof Tt?this.applyRotateTimeline(c,e,h,b,x,g,p<<1,f):c instanceof Nt?this.applyAttachmentTimeline(c,e,h,x,i):(o&&c instanceof Lt&&x==A.setup&&(w=I.mixIn),c.apply(e,l,h,r,b,x,w))}}return t.mixDuration>0&&this.queueEvents(s,h),this.events.length=0,s.nextAnimationLast=h,s.nextTrackLast=s.trackTime,a}applyAttachmentTimeline(t,e,n,s,a){const r=e.slots[t.slotIndex];if(!r.bone.active)return;const i=t.frames;if(n<i[0])s!=A.setup&&s!=A.first||this.setAttachment(e,r,r.data.attachmentName,a);else{let s;s=n>=i[i.length-1]?i.length-1:yt.binarySearch(i,n)-1,this.setAttachment(e,r,t.attachmentNames[s],a)}r.attachmentState<=this.unkeyedState&&(r.attachmentState=this.unkeyedState+Gt.SETUP)}setAttachment(t,e,n,s){e.setAttachment(null==n?null:t.getAttachment(e.data.index,n)),s&&(e.attachmentState=this.unkeyedState+Gt.CURRENT)}applyRotateTimeline(t,e,n,s,a,r,i,o){if(o&&(r[i]=0),1==s)return void t.apply(e,0,n,null,1,a,I.mixIn);const l=t,h=l.frames,c=e.bones[l.boneIndex];if(!c.active)return;let d=0,u=0;if(n<h[0])switch(a){case A.setup:c.rotation=c.data.rotation;default:return;case A.first:d=c.rotation,u=c.data.rotation}else if(d=a==A.setup?c.data.rotation:c.rotation,n>=h[h.length-Tt.ENTRIES])u=c.data.rotation+h[h.length+Tt.PREV_ROTATION];else{const t=yt.binarySearch(h,n,Tt.ENTRIES),e=h[t+Tt.PREV_ROTATION],s=h[t],a=l.getCurvePercent((t>>1)-1,1-(n-s)/(h[t+Tt.PREV_TIME]-s));u=h[t+Tt.ROTATION]-e,u-=360*(16384-(16384.499999999996-u/360|0)),u=e+u*a+c.data.rotation,u-=360*(16384-(16384.499999999996-u/360|0))}let m=0,f=u-d;if(f-=360*(16384-(16384.499999999996-f/360|0)),0==f)m=r[i];else{let t=0,e=0;o?(t=0,e=f):(t=r[i],e=r[i+1]);const n=f>0;let s=t>=0;q.signum(e)!=q.signum(f)&&Math.abs(e)<=90&&(Math.abs(t)>180&&(t+=360*q.signum(t)),s=n),m=f+t-t%360,s!=n&&(m+=360*q.signum(t)),r[i]=m}r[i+1]=f,d+=m*s,c.rotation=d-360*(16384-(16384.499999999996-d/360|0))}queueEvents(t,e){const n=t.animationStart,s=t.animationEnd,a=s-n,r=t.trackLast%a,i=this.events;let o=0;const l=i.length;for(;o<l;o++){const e=i[o];if(e.time<r)break;e.time>s||this.queue.event(t,e)}let h=!1;for(h=t.loop?0==a||r>t.trackTime%a:e>=s&&t.animationLast<s,h&&this.queue.complete(t);o<l;o++){i[o].time<n||this.queue.event(t,i[o])}}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,n=this.tracks.length;e<n;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(null==e)return;this.queue.end(e),this.disposeNext(e);let n=e;for(;;){const t=n.mixingFrom;if(null==t)break;this.queue.end(t),n.mixingFrom=null,n.mixingTo=null,n=t}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,n){const s=this.expandToIndex(t);this.tracks[t]=e,null!=s&&(n&&this.queue.interrupt(s),e.mixingFrom=s,s.mixingTo=e,e.mixTime=0,null!=s.mixingFrom&&s.mixDuration>0&&(e.interruptAlpha*=Math.min(1,s.mixTime/s.mixDuration)),s.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,n){const s=this.data.skeletonData.findAnimation(e);if(null==s)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,s,n)}setAnimationWith(t,e,n){if(null==e)throw new Error("animation cannot be null.");let s=!0,a=this.expandToIndex(t);null!=a&&(-1==a.nextTrackLast?(this.tracks[t]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.disposeNext(a),a=a.mixingFrom,s=!1):this.disposeNext(a));const r=this.trackEntry(t,e,n,a);return this.setCurrent(t,r,s),this.queue.drain(),r}addAnimation(t,e,n,s){const a=this.data.skeletonData.findAnimation(e);if(null==a)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,a,n,s)}addAnimationWith(t,e,n,s){if(null==e)throw new Error("animation cannot be null.");let a=this.expandToIndex(t);if(null!=a)for(;null!=a.next;)a=a.next;const r=this.trackEntry(t,e,n,a);if(null==a)this.setCurrent(t,r,!0),this.queue.drain();else if(a.next=r,s<=0){const t=a.animationEnd-a.animationStart;0!=t?(a.loop?s+=t*(1+(a.trackTime/t|0)):s+=Math.max(t,a.trackTime),s-=this.data.getMix(a.animation,e)):s=a.trackTime}return r.delay=s,r}setEmptyAnimation(t,e){const n=this.setAnimationWith(t,Gt.emptyAnimation,!1);return n.mixDuration=e,n.trackEnd=e,n}addEmptyAnimation(t,e,n){n<=0&&(n-=e);const s=this.addAnimationWith(t,Gt.emptyAnimation,!1,n);return s.mixDuration=e,s.trackEnd=e,s}setEmptyAnimations(t){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,s=this.tracks.length;n<s;n++){const e=this.tracks[n];null!=e&&this.setEmptyAnimation(e.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(j.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,n,s){const a=this.trackEntryPool.obtain();return a.trackIndex=t,a.animation=e,a.loop=n,a.holdPrevious=!1,a.eventThreshold=0,a.attachmentThreshold=0,a.drawOrderThreshold=0,a.animationStart=0,a.animationEnd=e.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.interruptAlpha=1,a.mixTime=0,a.mixDuration=null==s?0:this.data.getMix(s.animation,e),a.mixBlend=A.replace,a}disposeNext(t){let e=t.next;for(;null!=e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,e=this.tracks.length;t<e;t++){let e=this.tracks[t];if(null!=e){for(;null!=e.mixingFrom;)e=e.mixingFrom;do{null!=e.mixingFrom&&e.mixBlend==A.add||this.computeHold(e),e=e.mixingTo}while(null!=e)}}}computeHold(t){const e=t.mixingTo,n=t.animation.timelines,s=t.animation.timelines.length,a=j.setArraySize(t.timelineMode,s);t.timelineHoldMix.length=0;const r=j.setArraySize(t.timelineHoldMix,s),i=this.propertyIDs;if(null!=e&&e.holdPrevious)for(let o=0;o<s;o++)a[o]=i.add(n[o].getPropertyId())?Gt.HOLD_FIRST:Gt.HOLD_SUBSEQUENT;else t:for(let o=0;o<s;o++){const s=n[o],l=s.getPropertyId();if(i.add(l))if(null==e||s instanceof Nt||s instanceof Lt||s instanceof Bt||!e.animation.hasTimeline(l))a[o]=Gt.FIRST;else{for(let n=e.mixingTo;null!=n;n=n.mixingTo)if(!n.animation.hasTimeline(l)){if(t.mixDuration>0){a[o]=Gt.HOLD_MIX,r[o]=n;continue t}break}a[o]=Gt.HOLD_FIRST}else a[o]=Gt.SUBSEQUENT}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(null==t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,n){Gt.deprecatedWarning1||(Gt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,n)}addAnimationByName(t,e,n,s){Gt.deprecatedWarning2||(Gt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,n,s)}hasAnimation(t){return null!==this.data.skeletonData.findAnimation(t)}hasAnimationByName(t){return Gt.deprecatedWarning3||(Gt.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};let Zt=Gt;Zt.emptyAnimation=new yt("<empty>",[],0),Zt.SUBSEQUENT=0,Zt.FIRST=1,Zt.HOLD_SUBSEQUENT=2,Zt.HOLD_FIRST=3,Zt.HOLD_MIX=4,Zt.SETUP=1,Zt.CURRENT=2,Zt.deprecatedWarning1=!1,Zt.deprecatedWarning2=!1,Zt.deprecatedWarning3=!1;const Qt=class{constructor(){this.mixBlend=A.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return 0==t?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Qt.deprecatedWarning1||(Qt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Qt.deprecatedWarning1||(Qt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Qt.deprecatedWarning2||(Qt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Qt.deprecatedWarning2||(Qt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Kt=Qt;Kt.deprecatedWarning1=!1,Kt.deprecatedWarning2=!1;const Jt=class{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(ee.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(ee.interrupt),this.objects.push(t)}end(t){this.objects.push(ee.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(ee.dispose),this.objects.push(t)}complete(t){this.objects.push(ee.complete),this.objects.push(t)}event(t,e){this.objects.push(ee.event),this.objects.push(t),this.objects.push(e)}deprecateStuff(){return Jt.deprecatedWarning1||(Jt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let n=0;n<t.length;n+=2){const s=t[n],a=t[n+1];switch(s){case ee.start:null!=a.listener&&a.listener.start&&a.listener.start(a);for(let t=0;t<e.length;t++)e[t].start&&e[t].start(a);a.onStart&&this.deprecateStuff()&&a.onStart(a.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(a.trackIndex);break;case ee.interrupt:null!=a.listener&&a.listener.interrupt&&a.listener.interrupt(a);for(let t=0;t<e.length;t++)e[t].interrupt&&e[t].interrupt(a);break;case ee.end:null!=a.listener&&a.listener.end&&a.listener.end(a);for(let t=0;t<e.length;t++)e[t].end&&e[t].end(a);a.onEnd&&this.deprecateStuff()&&a.onEnd(a.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(a.trackIndex);case ee.dispose:null!=a.listener&&a.listener.dispose&&a.listener.dispose(a);for(let t=0;t<e.length;t++)e[t].dispose&&e[t].dispose(a);this.animState.trackEntryPool.free(a);break;case ee.complete:null!=a.listener&&a.listener.complete&&a.listener.complete(a);for(let t=0;t<e.length;t++)e[t].complete&&e[t].complete(a);const s=q.toInt(a.loopsCount());a.onComplete&&this.deprecateStuff()&&a.onComplete(a.trackIndex,s),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(a.trackIndex,s);break;case ee.event:const r=t[2+n++];null!=a.listener&&a.listener.event&&a.listener.event(a,r);for(let t=0;t<e.length;t++)e[t].event&&e[t].event(a,r);a.onEvent&&this.deprecateStuff()&&a.onEvent(a.trackIndex,r),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(a.trackIndex,r)}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let te=Jt;te.deprecatedWarning1=!1;var ee=(t=>(t[t.start=0]="start",t[t.interrupt=1]="interrupt",t[t.end=2]="end",t[t.dispose=3]="dispose",t[t.complete=4]="complete",t[t.event=5]="event",t))(ee||{});const ne=class{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,null==t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,n){const s=this.skeletonData.findAnimation(t);if(null==s)throw new Error(`Animation not found: ${t}`);const a=this.skeletonData.findAnimation(e);if(null==a)throw new Error(`Animation not found: ${e}`);this.setMixWith(s,a,n)}setMixByName(t,e,n){ne.deprecatedWarning1||(ne.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(t,e,n)}setMixWith(t,e,n){if(null==t)throw new Error("from cannot be null.");if(null==e)throw new Error("to cannot be null.");const s=`${t.name}.${e.name}`;this.animationToMixTime[s]=n}getMix(t,e){const n=`${t.name}.${e.name}`,s=this.animationToMixTime[n];return void 0===s?this.defaultMix:s}};let se=ne;se.deprecatedWarning1=!1;let ae=class{constructor(t){this.atlas=t}newRegionAttachment(t,e,n){const s=this.atlas.findRegion(n);if(null==s)throw new Error(`Region not found in atlas: ${n} (region attachment: ${e})`);const a=new wt(e);return a.region=s,a}newMeshAttachment(t,e,n){const s=this.atlas.findRegion(n);if(null==s)throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${e})`);const a=new mt(e);return a.region=s,a}newBoundingBoxAttachment(t,e){return new dt(e)}newPathAttachment(t,e){return new ft(e)}newPointAttachment(t,e){return new gt(e)}newClippingAttachment(t,e){return new ut(e)}},re=class{constructor(t,e,n){if(this.matrix=new E,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=n,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,n,s,a,r,i){this.ax=t,this.ay=e,this.arotation=n,this.ascaleX=s,this.ascaleY=a,this.ashearX=r,this.ashearY=i,this.appliedValid=!0;const o=this.parent,l=this.matrix,h=this.skeleton.scaleX,c=-this.skeleton.scaleY;if(null==o){const o=this.skeleton,d=n+90+i;return l.a=q.cosDeg(n+r)*s*h,l.c=q.cosDeg(d)*a*h,l.b=q.sinDeg(n+r)*s*c,l.d=q.sinDeg(d)*a*c,l.tx=t*h+o.x,void(l.ty=e*c+o.y)}let d=o.matrix.a,u=o.matrix.c,m=o.matrix.b,f=o.matrix.d;switch(l.tx=d*t+u*e+o.matrix.tx,l.ty=m*t+f*e+o.matrix.ty,this.data.transformMode){case R.Normal:{const t=n+90+i,e=q.cosDeg(n+r)*s,o=q.cosDeg(t)*a,h=q.sinDeg(n+r)*s,c=q.sinDeg(t)*a;return l.a=d*e+u*h,l.c=d*o+u*c,l.b=m*e+f*h,void(l.d=m*o+f*c)}case R.OnlyTranslation:{const t=n+90+i;l.a=q.cosDeg(n+r)*s,l.c=q.cosDeg(t)*a,l.b=q.sinDeg(n+r)*s,l.d=q.sinDeg(t)*a;break}case R.NoRotationOrReflection:{let t=d*d+m*m,e=0;t>1e-4?(t=Math.abs(d*f-u*m)/t,d/=this.skeleton.scaleX,m/=this.skeleton.scaleY,u=m*t,f=d*t,e=Math.atan2(m,d)*q.radDeg):(d=0,m=0,e=90-Math.atan2(f,u)*q.radDeg);const o=n+r-e,h=n+i-e+90,c=q.cosDeg(o)*s,g=q.cosDeg(h)*a,p=q.sinDeg(o)*s,x=q.sinDeg(h)*a;l.a=d*c-u*p,l.c=d*g-u*x,l.b=m*c+f*p,l.d=m*g+f*x;break}case R.NoScale:case R.NoScaleOrReflection:{const t=q.cosDeg(n),e=q.sinDeg(n);let o=(d*t+u*e)/h,g=(m*t+f*e)/c,p=Math.sqrt(o*o+g*g);p>1e-5&&(p=1/p),o*=p,g*=p,p=Math.sqrt(o*o+g*g),this.data.transformMode==R.NoScale&&d*f-u*m<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY>0)&&(p=-p);const x=Math.PI/2+Math.atan2(g,o),w=Math.cos(x)*p,b=Math.sin(x)*p,E=q.cosDeg(r)*s,y=q.cosDeg(90+i)*a,S=q.sinDeg(r)*s,M=q.sinDeg(90+i)*a;l.a=o*E+w*S,l.c=o*y+w*M,l.b=g*E+b*S,l.d=g*y+b*M;break}}l.a*=h,l.c*=h,l.b*=c,l.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*q.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*q.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,e=this.matrix;if(null==t)return this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*q.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,void(this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*q.radDeg);const n=t.matrix,s=1/(n.a*n.d-n.b*n.c),a=e.tx-n.tx,r=e.ty-n.ty;this.ax=a*n.d*s-r*n.c*s,this.ay=r*n.a*s-a*n.b*s;const i=s*n.d,o=s*n.a,l=s*n.c,h=s*n.b,c=i*e.a-l*e.b,d=i*e.c-l*e.d,u=o*e.b-h*e.a,m=o*e.d-h*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+u*u),this.ascaleX>1e-4){const t=c*m-d*u;this.ascaleY=t/this.ascaleX,this.ashearY=Math.atan2(c*d+u*m,t)*q.radDeg,this.arotation=Math.atan2(u,c)*q.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(d*d+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,d)*q.radDeg}worldToLocal(t){const e=this.matrix,n=e.a,s=e.c,a=e.b,r=e.d,i=1/(n*r-s*a),o=t.x-e.tx,l=t.y-e.ty;return t.x=o*r*i-l*s*i,t.y=l*n*i-o*a*i,t}localToWorld(t){const e=this.matrix,n=t.x,s=t.y;return t.x=n*e.a+s*e.c+e.tx,t.y=n*e.b+s*e.d+e.ty,t}worldToLocalRotation(t){const e=q.sinDeg(t),n=q.cosDeg(t),s=this.matrix;return Math.atan2(s.a*e-s.b*n,s.d*n-s.c*e)*q.radDeg}localToWorldRotation(t){const e=q.sinDeg(t),n=q.cosDeg(t),s=this.matrix;return Math.atan2(n*s.b+e*s.d,n*s.a+e*s.c)*q.radDeg}rotateWorld(t){const e=this.matrix,n=e.a,s=e.c,a=e.b,r=e.d,i=q.cosDeg(t),o=q.sinDeg(t);e.a=i*n-o*a,e.c=i*s-o*r,e.b=o*n+i*a,e.d=o*s+i*r,this.appliedValid=!1}},ie=class{constructor(t,e,n){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=R.Normal,this.skinRequired=!1,this.color=new O,t<0)throw new Error("index must be >= 0.");if(null==e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=n}},oe=class{constructor(t,e,n){this.name=t,this.order=e,this.skinRequired=n}},le=class{constructor(t,e){if(null==e)throw new Error("data cannot be null.");this.time=t,this.data=e}},he=class{constructor(t){this.name=t}},ce=class{constructor(t,e){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix)}}apply1(t,e,n,s,a,r,i){t.appliedValid||t.updateAppliedTransform();const o=t.parent.matrix,l=o.a;let h=o.c;const c=o.b;let d=o.d,u=-t.ashearX-t.arotation,m=0,f=0;switch(t.data.transformMode){case R.OnlyTranslation:m=e-t.worldX,f=n-t.worldY;break;case R.NoRotationOrReflection:const s=Math.abs(l*d-h*c)/(l*l+c*c),a=l/t.skeleton.scaleX,r=c/t.skeleton.scaleY;h=-r*s*t.skeleton.scaleX,d=a*s*t.skeleton.scaleY,u+=Math.atan2(r,a)*q.radDeg;default:const i=e-o.tx,g=n-o.ty,p=l*d-h*c;m=(i*d-g*h)/p-t.ax,f=(g*l-i*c)/p-t.ay}u+=Math.atan2(f,m)*q.radDeg,t.ascaleX<0&&(u+=180),u>180?u-=360:u<-180&&(u+=360);let g=t.ascaleX,p=t.ascaleY;if(s||a){switch(t.data.transformMode){case R.NoScale:case R.NoScaleOrReflection:m=e-t.worldX,f=n-t.worldY}const o=t.data.length*g,l=Math.sqrt(m*m+f*f);if(s&&l<o||a&&l>o&&o>1e-4){const t=(l/o-1)*i+1;g*=t,r&&(p*=t)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*i,g,p,t.ashearX,t.ashearY)}apply2(t,e,n,s,a,r,i,o){if(0==o)return void e.updateWorldTransform();t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();const l=t.ax,h=t.ay;let c=t.ascaleX,d=c,u=t.ascaleY,m=e.ascaleX;const f=t.matrix;let g=0,p=0,x=0;c<0?(c=-c,g=180,x=-1):(g=0,x=1),u<0&&(u=-u,x=-x),m<0?(m=-m,p=180):p=0;const w=e.ax;let b=0,E=0,y=0,S=f.a,M=f.c,A=f.b,I=f.d;const T=Math.abs(c-u)<=1e-4;T?(b=e.ay,E=S*w+M*b+f.tx,y=A*w+I*b+f.ty):(b=0,E=S*w+f.tx,y=A*w+f.ty);const k=t.parent.matrix;S=k.a,M=k.c,A=k.b,I=k.d;const R=1/(S*I-M*A);let C=E-k.tx,V=y-k.ty;const v=(C*I-V*M)*R-l,P=(V*S-C*A)*R-h,F=Math.sqrt(v*v+P*P);let Y,N,X=e.data.length*m;if(F<1e-4)return this.apply1(t,n,s,!1,r,!1,o),void e.updateWorldTransformWith(w,b,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);C=n-k.tx,V=s-k.ty;let D=(C*I-V*M)*R-l,B=(V*S-C*A)*R-h,L=D*D+B*B;if(0!=i){i*=c*(m+1)/2;const t=Math.sqrt(L),e=t-F-X*c+i;if(e>0){let n=Math.min(1,e/(2*i))-1;n=(e-i*(1-n*n))/t,D-=n*D,B-=n*B,L=D*D+B*B}}t:if(T){X*=c;let t=(L-F*F-X*X)/(2*F*X);t<-1?t=-1:t>1&&(t=1,r&&(d*=(Math.sqrt(L)/(F+X)-1)*o+1)),N=Math.acos(t)*a,S=F+X*t,M=X*Math.sin(N),Y=Math.atan2(B*S-D*M,D*S+B*M)}else{S=c*X,M=u*X;const t=S*S,e=M*M,n=Math.atan2(B,D);A=e*F*F+t*L-t*e;const s=-2*e*F,r=e-t;if(I=s*s-4*r*A,I>=0){let t=Math.sqrt(I);s<0&&(t=-t),t=-(s+t)/2;const e=t/r,i=A/t,o=Math.abs(e)<Math.abs(i)?e:i;if(o*o<=L){V=Math.sqrt(L-o*o)*a,Y=n-Math.atan2(V,o),N=Math.atan2(V/u,(o-F)/c);break t}}let i=q.PI,o=F-S,l=o*o,h=0,d=0,m=F+S,f=m*m,g=0;A=-S*F/(t-e),A>=-1&&A<=1&&(A=Math.acos(A),C=S*Math.cos(A)+F,V=M*Math.sin(A),I=C*C+V*V,I<l&&(i=A,l=I,o=C,h=V),I>f&&(d=A,f=I,m=C,g=V)),L<=(l+f)/2?(Y=n-Math.atan2(h*a,o),N=i*a):(Y=n-Math.atan2(g*a,m),N=d*a)}const _=Math.atan2(b,w)*x;let O=t.arotation;Y=(Y-_)*q.radDeg+g-O,Y>180?Y-=360:Y<-180&&(Y+=360),t.updateWorldTransformWith(l,h,O+Y*o,d,t.ascaleY,0,0),O=e.arotation,N=((N+_)*q.radDeg-e.ashearX)*x+p-O,N>180?N-=360:N<-180&&(N+=360),e.updateWorldTransformWith(w,b,O+N*o,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}},de=class extends oe{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}},ue=class extends oe{constructor(t){super(t,0,!1),this.bones=new Array}};var me=(t=>(t[t.Length=0]="Length",t[t.Fixed=1]="Fixed",t[t.Percent=2]="Percent",t))(me||{});const fe=class{constructor(t,e){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,s=t.bones.length;n<s;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}isActive(){return this.active}apply(){this.update()}update(){const t=this.target.getAttachment();if(!(t instanceof ft))return;const e=this.rotateMix,n=this.translateMix,s=e>0;if(!(n>0)&&!s)return;const a=this.data,r=a.spacingMode,i=r==me.Length,o=a.rotateMode,l=o==k.Tangent,h=o==k.ChainScale,c=this.bones.length,d=l?c:c+1,u=this.bones,m=j.setArraySize(this.spaces,d);let f=null;const g=this.spacing;if(h||i){h&&(f=j.setArraySize(this.lengths,c));for(let t=0,e=d-1;t<e;){const e=u[t],n=e.data.length;if(n<fe.epsilon)h&&(f[t]=0),m[++t]=0;else{const s=n*e.matrix.a,a=n*e.matrix.b,r=Math.sqrt(s*s+a*a);h&&(f[t]=r),m[++t]=(i?n+g:g)*r/n}}}else for(let y=1;y<d;y++)m[y]=g;const p=this.computeWorldPositions(t,d,l,a.positionMode==T.Percent,r==me.Percent);let x=p[0],w=p[1],b=a.offsetRotation,E=!1;if(0==b)E=o==k.Chain;else{E=!1;const t=this.target.bone.matrix;b*=t.a*t.d-t.b*t.c>0?q.degRad:-q.degRad}for(let y=0,S=3;y<c;y++,S+=3){const t=u[y],a=t.matrix;a.tx+=(x-a.tx)*n,a.ty+=(w-a.ty)*n;const r=p[S],i=p[S+1],o=r-x,c=i-w;if(h){const t=f[y];if(0!=t){const n=(Math.sqrt(o*o+c*c)/t-1)*e+1;a.a*=n,a.b*=n}}if(x=r,w=i,s){const n=a.a,s=a.c,r=a.b,i=a.d;let h=0,d=0,u=0;if(l&&(h=l?p[S-1]:0==m[y+1]?p[S+2]:Math.atan2(c,o)),h-=Math.atan2(r,n),E){d=Math.cos(h),u=Math.sin(h);const s=t.data.length;x+=(s*(d*n-u*r)-o)*e,w+=(s*(u*n+d*r)-c)*e}else h+=b;h>q.PI?h-=q.PI2:h<-q.PI&&(h+=q.PI2),h*=e,d=Math.cos(h),u=Math.sin(h),a.a=d*n-u*r,a.c=d*s-u*i,a.b=u*n+d*r,a.d=u*s+d*i}t.appliedValid=!1}}computeWorldPositions(t,e,n,s,a){const r=this.target;let i=this.position;const o=this.spaces,l=j.setArraySize(this.positions,3*e+2);let h=null;const c=t.closed;let d=t.worldVerticesLength,u=d/6,m=fe.NONE;if(!t.constantSpeed){const f=t.lengths;u-=c?1:2;const g=f[u];if(s&&(i*=g),a)for(let t=0;t<e;t++)o[t]*=g;h=j.setArraySize(this.world,8);for(let s=0,a=0,p=0;s<e;s++,a+=3){const e=o[s];i+=e;let x=i;if(c)x%=g,x<0&&(x+=g),p=0;else{if(x<0){m!=fe.BEFORE&&(m=fe.BEFORE,t.computeWorldVertices(r,2,4,h,0,2)),this.addBeforePosition(x,h,0,l,a);continue}if(x>g){m!=fe.AFTER&&(m=fe.AFTER,t.computeWorldVertices(r,d-6,4,h,0,2)),this.addAfterPosition(x-g,h,0,l,a);continue}}for(;;p++){const t=f[p];if(!(x>t)){if(0==p)x/=t;else{const e=f[p-1];x=(x-e)/(t-e)}break}}p!=m&&(m=p,c&&p==u?(t.computeWorldVertices(r,d-4,4,h,0,2),t.computeWorldVertices(r,0,4,h,4,2)):t.computeWorldVertices(r,6*p+2,8,h,0,2)),this.addCurvePosition(x,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],l,a,n||s>0&&0==e)}return l}c?(d+=2,h=j.setArraySize(this.world,d),t.computeWorldVertices(r,2,d-4,h,0,2),t.computeWorldVertices(r,0,2,h,d-4,2),h[d-2]=h[0],h[d-1]=h[1]):(u--,d-=4,h=j.setArraySize(this.world,d),t.computeWorldVertices(r,2,d,h,0,2));const f=j.setArraySize(this.curves,u);let g=0,p=h[0],x=h[1],w=0,b=0,E=0,y=0,S=0,M=0,A=0,I=0,T=0,k=0,R=0,C=0,V=0,v=0;for(let Y=0,N=2;Y<u;Y++,N+=6)w=h[N],b=h[N+1],E=h[N+2],y=h[N+3],S=h[N+4],M=h[N+5],A=.1875*(p-2*w+E),I=.1875*(x-2*b+y),T=.09375*(3*(w-E)-p+S),k=.09375*(3*(b-y)-x+M),R=2*A+T,C=2*I+k,V=.75*(w-p)+A+.16666667*T,v=.75*(b-x)+I+.16666667*k,g+=Math.sqrt(V*V+v*v),V+=R,v+=C,R+=T,C+=k,g+=Math.sqrt(V*V+v*v),V+=R,v+=C,g+=Math.sqrt(V*V+v*v),V+=R+T,v+=C+k,g+=Math.sqrt(V*V+v*v),f[Y]=g,p=S,x=M;if(s&&(i*=g),a)for(let Y=0;Y<e;Y++)o[Y]*=g;const P=this.segments;let F=0;for(let Y=0,N=0,X=0,D=0;Y<e;Y++,N+=3){const t=o[Y];i+=t;let e=i;if(c)e%=g,e<0&&(e+=g),X=0;else{if(e<0){this.addBeforePosition(e,h,0,l,N);continue}if(e>g){this.addAfterPosition(e-g,h,d-4,l,N);continue}}for(;;X++){const t=f[X];if(!(e>t)){if(0==X)e/=t;else{const n=f[X-1];e=(e-n)/(t-n)}break}}if(X!=m){m=X;let t=6*X;for(p=h[t],x=h[t+1],w=h[t+2],b=h[t+3],E=h[t+4],y=h[t+5],S=h[t+6],M=h[t+7],A=.03*(p-2*w+E),I=.03*(x-2*b+y),T=.006*(3*(w-E)-p+S),k=.006*(3*(b-y)-x+M),R=2*A+T,C=2*I+k,V=.3*(w-p)+A+.16666667*T,v=.3*(b-x)+I+.16666667*k,F=Math.sqrt(V*V+v*v),P[0]=F,t=1;t<8;t++)V+=R,v+=C,R+=T,C+=k,F+=Math.sqrt(V*V+v*v),P[t]=F;V+=R,v+=C,F+=Math.sqrt(V*V+v*v),P[8]=F,V+=R+T,v+=C+k,F+=Math.sqrt(V*V+v*v),P[9]=F,D=0}for(e*=F;;D++){const t=P[D];if(!(e>t)){if(0==D)e/=t;else{const n=P[D-1];e=D+(e-n)/(t-n)}break}}this.addCurvePosition(.1*e,p,x,w,b,E,y,S,M,l,N,n||Y>0&&0==t)}return l}addBeforePosition(t,e,n,s,a){const r=e[n],i=e[n+1],o=e[n+2]-r,l=e[n+3]-i,h=Math.atan2(l,o);s[a]=r+t*Math.cos(h),s[a+1]=i+t*Math.sin(h),s[a+2]=h}addAfterPosition(t,e,n,s,a){const r=e[n+2],i=e[n+3],o=r-e[n],l=i-e[n+1],h=Math.atan2(l,o);s[a]=r+t*Math.cos(h),s[a+1]=i+t*Math.sin(h),s[a+2]=h}addCurvePosition(t,e,n,s,a,r,i,o,l,h,c,d){(0==t||isNaN(t))&&(t=1e-4);const u=t*t,m=u*t,f=1-t,g=f*f,p=g*f,x=f*t,w=3*x,b=f*w,E=w*t,y=e*p+s*b+r*E+o*m,S=n*p+a*b+i*E+l*m;h[c]=y,h[c+1]=S,d&&(h[c+2]=Math.atan2(S-(n*g+a*x*2+i*u),y-(e*g+s*x*2+r*u)))}};let ge=fe;ge.NONE=-1,ge.BEFORE=-2,ge.AFTER=-3,ge.epsilon=1e-5;let pe=class{constructor(t,e){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new Z,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target,r=a.matrix,i=r.a,o=r.c,l=r.b,h=r.d,c=i*h-o*l>0?q.degRad:-q.degRad,d=this.data.offsetRotation*c,u=this.data.offsetShearY*c,m=this.bones;for(let f=0,g=m.length;f<g;f++){const r=m[f];let c=!1;const g=r.matrix;if(0!=t){const e=g.a,n=g.c,s=g.b,a=g.d;let r=Math.atan2(l,i)-Math.atan2(s,e)+d;r>q.PI?r-=q.PI2:r<-q.PI&&(r+=q.PI2),r*=t;const o=Math.cos(r),h=Math.sin(r);g.a=o*e-h*s,g.c=o*n-h*a,g.b=h*e+o*s,g.d=h*n+o*a,c=!0}if(0!=e){const t=this.temp;a.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),g.tx+=(t.x-g.tx)*e,g.ty+=(t.y-g.ty)*e,c=!0}if(n>0){let t=Math.sqrt(g.a*g.a+g.b*g.b),e=Math.sqrt(i*i+l*l);t>1e-5&&(t=(t+(e-t+this.data.offsetScaleX)*n)/t),g.a*=t,g.b*=t,t=Math.sqrt(g.c*g.c+g.d*g.d),e=Math.sqrt(o*o+h*h),t>1e-5&&(t=(t+(e-t+this.data.offsetScaleY)*n)/t),g.c*=t,g.d*=t,c=!0}if(s>0){const t=g.c,e=g.d,n=Math.atan2(e,t);let a=Math.atan2(h,o)-Math.atan2(l,i)-(n-Math.atan2(g.b,g.a));a>q.PI?a-=q.PI2:a<-q.PI&&(a+=q.PI2),a=n+(a+u)*s;const r=Math.sqrt(t*t+e*e);g.c=Math.cos(a)*r,g.d=Math.sin(a)*r,c=!0}c&&(r.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target,r=a.matrix,i=r.a,o=r.c,l=r.b,h=r.d,c=i*h-o*l>0?q.degRad:-q.degRad,d=this.data.offsetRotation*c,u=this.data.offsetShearY*c,m=this.bones;for(let f=0,g=m.length;f<g;f++){const r=m[f];let c=!1;const g=r.matrix;if(0!=t){const e=g.a,n=g.c,s=g.b,a=g.d;let r=Math.atan2(l,i)+d;r>q.PI?r-=q.PI2:r<-q.PI&&(r+=q.PI2),r*=t;const o=Math.cos(r),h=Math.sin(r);g.a=o*e-h*s,g.c=o*n-h*a,g.b=h*e+o*s,g.d=h*n+o*a,c=!0}if(0!=e){const t=this.temp;a.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),g.tx+=t.x*e,g.ty+=t.y*e,c=!0}if(n>0){let t=(Math.sqrt(i*i+l*l)-1+this.data.offsetScaleX)*n+1;g.a*=t,g.b*=t,t=(Math.sqrt(o*o+h*h)-1+this.data.offsetScaleY)*n+1,g.c*=t,g.d*=t,c=!0}if(s>0){let t=Math.atan2(h,o)-Math.atan2(l,i);t>q.PI?t-=q.PI2:t<-q.PI&&(t+=q.PI2);const e=g.c,n=g.d;t=Math.atan2(n,e)+(t-q.PI/2+u)*s;const a=Math.sqrt(e*e+n*n);g.c=Math.cos(t)*a,g.d=Math.sin(t)*a,c=!0}c&&(r.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target;a.appliedValid||a.updateAppliedTransform();const r=this.bones;for(let i=0,o=r.length;i<o;i++){const o=r[i];o.appliedValid||o.updateAppliedTransform();let l=o.arotation;if(0!=t){let e=a.arotation-l+this.data.offsetRotation;e-=360*(16384-(16384.499999999996-e/360|0)),l+=e*t}let h=o.ax,c=o.ay;0!=e&&(h+=(a.ax-h+this.data.offsetX)*e,c+=(a.ay-c+this.data.offsetY)*e);let d=o.ascaleX,u=o.ascaleY;n>0&&(d>1e-5&&(d=(d+(a.ascaleX-d+this.data.offsetScaleX)*n)/d),u>1e-5&&(u=(u+(a.ascaleY-u+this.data.offsetScaleY)*n)/u));const m=o.ashearY;if(s>0){let t=a.ashearY-m+this.data.offsetShearY;t-=360*(16384-(16384.499999999996-t/360|0)),o.shearY+=t*s}o.updateWorldTransformWith(h,c,l,d,u,o.ashearX,m)}}applyRelativeLocal(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target;a.appliedValid||a.updateAppliedTransform();const r=this.bones;for(let i=0,o=r.length;i<o;i++){const o=r[i];o.appliedValid||o.updateAppliedTransform();let l=o.arotation;0!=t&&(l+=(a.arotation+this.data.offsetRotation)*t);let h=o.ax,c=o.ay;0!=e&&(h+=(a.ax+this.data.offsetX)*e,c+=(a.ay+this.data.offsetY)*e);let d=o.ascaleX,u=o.ascaleY;n>0&&(d>1e-5&&(d*=(a.ascaleX-1+this.data.offsetScaleX)*n+1),u>1e-5&&(u*=(a.ascaleY-1+this.data.offsetScaleY)*n+1));let m=o.ashearY;s>0&&(m+=(a.ashearY+this.data.offsetShearY)*s),o.updateWorldTransformWith(h,c,l,d,u,o.ashearX,m)}}};const xe=class{constructor(t){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,null==t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const n=t.bones[e];let s;if(null==n.parent)s=new re(n,this,null);else{const t=this.bones[n.parent.index];s=new re(n,this,t),t.children.push(s)}this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const n=t.slots[e],s=this.bones[n.boneData.index],a=new pt(n,s);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const n=t.ikConstraints[e];this.ikConstraints.push(new ce(n,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const n=t.transformConstraints[e];this.transformConstraints.push(new pe(n,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const n=t.pathConstraints[e];this.pathConstraints.push(new ge(n,this))}this.color=new O(1,1,1,1),this.updateCache()}updateCache(){this._updateCache.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let l=0,h=t.length;l<h;l++){const e=t[l];e.sorted=e.data.skinRequired,e.active=!e.sorted}if(null!=this.skin){const t=this.skin.bones;for(let e=0,n=this.skin.bones.length;e<n;e++){let n=this.bones[t[e].index];do{n.sorted=!1,n.active=!0,n=n.parent}while(null!=n)}}const e=this.ikConstraints,n=this.transformConstraints,s=this.pathConstraints,a=e.length,r=n.length,i=s.length,o=a+r+i;t:for(let l=0;l<o;l++){for(let t=0;t<a;t++){const n=e[t];if(n.data.order==l){this.sortIkConstraint(n);continue t}}for(let t=0;t<r;t++){const e=n[t];if(e.data.order==l){this.sortTransformConstraint(e);continue t}}for(let t=0;t<i;t++){const e=s[t];if(e.data.order==l){this.sortPathConstraint(e);continue t}}}for(let l=0,h=t.length;l<h;l++)this.sortBone(t[l])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||null!=this.skin&&j.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const n=t.bones,s=n[0];if(this.sortBone(s),n.length>1){const t=n[n.length-1];this._updateCache.indexOf(t)>-1||this.updateCacheReset.push(t)}this._updateCache.push(t),this.sortReset(s.children),n[n.length-1].sorted=!0}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||null!=this.skin&&j.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,n=e.data.index,s=e.bone;null!=this.skin&&this.sortPathConstraintAttachment(this.skin,n,s),null!=this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,s);for(let o=0,l=this.data.skins.length;o<l;o++)this.sortPathConstraintAttachment(this.data.skins[o],n,s);const a=e.getAttachment();a instanceof ft&&this.sortPathConstraintAttachmentWith(a,s);const r=t.bones,i=r.length;for(let o=0;o<i;o++)this.sortBone(r[o]);this._updateCache.push(t);for(let o=0;o<i;o++)this.sortReset(r[o].children);for(let o=0;o<i;o++)r[o].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||null!=this.skin&&j.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,n=e.length;if(t.data.local)for(let s=0;s<n;s++){const t=e[s];this.sortBone(t.parent),this._updateCache.indexOf(t)>-1||this.updateCacheReset.push(t)}else for(let s=0;s<n;s++)this.sortBone(e[s]);this._updateCache.push(t);for(let s=0;s<n;s++)this.sortReset(e[s].children);for(let s=0;s<n;s++)e[s].sorted=!0}sortPathConstraintAttachment(t,e,n){const s=t.attachments[e];if(s)for(const a in s)this.sortPathConstraintAttachmentWith(s[a],n)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof ft))return;const n=t.bones;if(null==n)this.sortBone(e);else{const t=this.bones;let e=0;for(;e<n.length;){const s=n[e++];for(let a=e+s;e<a;e++){const s=n[e];this.sortBone(t[s])}}}}sortBone(t){if(t.sorted)return;const e=t.parent;null!=e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,n=t.length;e<n;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const t=this.updateCacheReset;for(let n=0,s=t.length;n<s;n++){const e=t[n];e.ax=e.x,e.ay=e.y,e.arotation=e.rotation,e.ascaleX=e.scaleX,e.ascaleY=e.scaleY,e.ashearX=e.shearX,e.ashearY=e.shearY,e.appliedValid=!0}const e=this._updateCache;for(let n=0,s=e.length;n<s;n++)e[n].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let a=0,r=t.length;a<r;a++)t[a].setToSetupPose();const e=this.ikConstraints;for(let a=0,r=e.length;a<r;a++){const t=e[a];t.mix=t.data.mix,t.softness=t.data.softness,t.bendDirection=t.data.bendDirection,t.compress=t.data.compress,t.stretch=t.data.stretch}const n=this.transformConstraints;for(let a=0,r=n.length;a<r;a++){const t=n[a],e=t.data;t.rotateMix=e.rotateMix,t.translateMix=e.translateMix,t.scaleMix=e.scaleMix,t.shearMix=e.shearMix}const s=this.pathConstraints;for(let a=0,r=s.length;a<r;a++){const t=s[a],e=t.data;t.position=e.position,t.spacing=e.spacing,t.rotateMix=e.rotateMix,t.translateMix=e.translateMix}}setSlotsToSetupPose(){const t=this.slots;j.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,n=t.length;e<n;e++)t[e].setToSetupPose()}getRootBone(){return 0==this.bones.length?null:this.bones[0]}findBone(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findBoneIndex(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++)if(e[n].data.name==t)return n;return-1}findSlot(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findSlotIndex(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++)if(e[n].data.name==t)return n;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(null==e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(null!=t)if(null!=this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n],a=s.data.attachmentName;if(null!=a){const e=t.getAttachment(n,a);null!=e&&s.setAttachment(e)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){return this.getAttachment(this.data.findSlotIndex(t),e)}getAttachment(t,e){if(null==e)throw new Error("attachmentName cannot be null.");if(null!=this.skin){const n=this.skin.getAttachment(t,e);if(null!=n)return n}return null!=this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(null==t)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++){const a=n[s];if(a.data.name==t){let n=null;if(null!=e&&(n=this.getAttachment(s,e),null==n))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);return void a.setAttachment(n)}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findTransformConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findPathConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}getBounds(t,e,n=new Array(2)){if(null==t)throw new Error("offset cannot be null.");if(null==e)throw new Error("size cannot be null.");const s=this.drawOrder;let a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let l=0,h=s.length;l<h;l++){const t=s[l];if(!t.bone.active)continue;let e=0,h=null;const c=t.getAttachment();if(c instanceof wt)e=8,h=j.setArraySize(n,e,0),c.computeWorldVertices(t.bone,h,0,2);else if(c instanceof mt){const s=c;e=s.worldVerticesLength,h=j.setArraySize(n,e,0),s.computeWorldVertices(t,0,e,h,0,2)}if(null!=h)for(let n=0,s=h.length;n<s;n+=2){const t=h[n],e=h[n+1];a=Math.min(a,t),r=Math.min(r,e),i=Math.max(i,t),o=Math.max(o,e)}}t.set(a,r),e.set(i-a,o-r)}update(t){this.time+=t}get flipX(){return-1==this.scaleX}set flipX(t){xe.deprecatedWarning1||(xe.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return-1==this.scaleY}set flipY(t){xe.deprecatedWarning1||(xe.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};let we=xe;we.deprecatedWarning1=!1;let be=class{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findBoneIndex(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}findSlot(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findSlotIndex(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}findSkin(t){if(null==t)throw new Error("skinName cannot be null.");const e=this.skins;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findEvent(t){if(null==t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findAnimation(t){if(null==t)throw new Error("animationName cannot be null.");const e=this.animations;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findIkConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findTransformConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findPathConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findPathConstraintIndex(t){if(null==t)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}},Ee=class{constructor(t,e,n){if(this.color=new O(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(null==e)throw new Error("name cannot be null.");if(null==n)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=n}},ye=class extends oe{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}},Se=class{constructor(t,e,n){this.slotIndex=t,this.name=e,this.attachment=n}},Me=class{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,null==t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,n){if(null==n)throw new Error("attachment cannot be null.");const s=this.attachments;t>=s.length&&(s.length=t+1),s[t]||(s[t]={}),s[t][e]=n}addSkin(t){for(let n=0;n<t.bones.length;n++){const e=t.bones[n];let s=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==e){s=!0;break}s||this.bones.push(e)}for(let n=0;n<t.constraints.length;n++){const e=t.constraints[n];let s=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==e){s=!0;break}s||this.constraints.push(e)}const e=t.getAttachments();for(let n=0;n<e.length;n++){const t=e[n];this.setAttachment(t.slotIndex,t.name,t.attachment)}}copySkin(t){for(let n=0;n<t.bones.length;n++){const e=t.bones[n];let s=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==e){s=!0;break}s||this.bones.push(e)}for(let n=0;n<t.constraints.length;n++){const e=t.constraints[n];let s=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==e){s=!0;break}s||this.constraints.push(e)}const e=t.getAttachments();for(let n=0;n<e.length;n++){const t=e[n];null!=t.attachment&&(t.attachment instanceof mt?(t.attachment=t.attachment.newLinkedMesh(),this.setAttachment(t.slotIndex,t.name,t.attachment)):(t.attachment=t.attachment.copy(),this.setAttachment(t.slotIndex,t.name,t.attachment)))}}getAttachment(t,e){const n=this.attachments[t];return n?n[e]:null}removeAttachment(t,e){const n=this.attachments[t];n&&(n[e]=null)}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const n=this.attachments[e];if(n)for(const s in n){const a=n[s];a&&t.push(new Se(e,s,a))}}return t}getAttachmentsForSlot(t,e){const n=this.attachments[t];if(n)for(const s in n){const a=n[s];a&&e.push(new Se(t,s,a))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let n=0;for(let s=0;s<t.slots.length;s++){const a=t.slots[s],r=a.getAttachment();if(r&&n<e.attachments.length){const t=e.attachments[n];for(const e in t){if(r==t[e]){const t=this.getAttachment(n,e);null!=t&&a.setAttachment(t);break}}}n++}}};const Ae=class{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,n=new be;n.name="";const s=new M(t);if(n.hash=s.readString(),n.version=s.readString(),"3.8.75"===n.version){const t="Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.";console.error(t)}n.x=s.readFloat(),n.y=s.readFloat(),n.width=s.readFloat(),n.height=s.readFloat();const a=s.readBoolean();a&&(n.fps=s.readFloat(),n.imagesPath=s.readString(),n.audioPath=s.readString());let r=0;r=s.readInt(!0);for(let o=0;o<r;o++)s.strings.push(s.readString());r=s.readInt(!0);for(let o=0;o<r;o++){const t=s.readString(),r=0==o?null:n.bones[s.readInt(!0)],i=new ie(o,t,r);i.rotation=s.readFloat(),i.x=s.readFloat()*e,i.y=s.readFloat()*e,i.scaleX=s.readFloat(),i.scaleY=s.readFloat(),i.shearX=s.readFloat(),i.shearY=s.readFloat(),i.length=s.readFloat()*e,i.transformMode=Ae.TransformModeValues[s.readInt(!0)],i.skinRequired=s.readBoolean(),a&&O.rgba8888ToColor(i.color,s.readInt32()),n.bones.push(i)}r=s.readInt(!0);for(let o=0;o<r;o++){const t=s.readString(),e=n.bones[s.readInt(!0)],a=new Ee(o,t,e);O.rgba8888ToColor(a.color,s.readInt32());const r=s.readInt32();-1!=r&&O.rgb888ToColor(a.darkColor=new O,r),a.attachmentName=s.readStringRef(),a.blendMode=Ae.BlendModeValues[s.readInt(!0)],n.slots.push(a)}r=s.readInt(!0);for(let o,l=0;l<r;l++){const t=new de(s.readString());t.order=s.readInt(!0),t.skinRequired=s.readBoolean(),o=s.readInt(!0);for(let e=0;e<o;e++)t.bones.push(n.bones[s.readInt(!0)]);t.target=n.bones[s.readInt(!0)],t.mix=s.readFloat(),t.softness=s.readFloat()*e,t.bendDirection=s.readByte(),t.compress=s.readBoolean(),t.stretch=s.readBoolean(),t.uniform=s.readBoolean(),n.ikConstraints.push(t)}r=s.readInt(!0);for(let o,l=0;l<r;l++){const t=new ye(s.readString());t.order=s.readInt(!0),t.skinRequired=s.readBoolean(),o=s.readInt(!0);for(let e=0;e<o;e++)t.bones.push(n.bones[s.readInt(!0)]);t.target=n.bones[s.readInt(!0)],t.local=s.readBoolean(),t.relative=s.readBoolean(),t.offsetRotation=s.readFloat(),t.offsetX=s.readFloat()*e,t.offsetY=s.readFloat()*e,t.offsetScaleX=s.readFloat(),t.offsetScaleY=s.readFloat(),t.offsetShearY=s.readFloat(),t.rotateMix=s.readFloat(),t.translateMix=s.readFloat(),t.scaleMix=s.readFloat(),t.shearMix=s.readFloat(),n.transformConstraints.push(t)}r=s.readInt(!0);for(let o,l=0;l<r;l++){const t=new ue(s.readString());t.order=s.readInt(!0),t.skinRequired=s.readBoolean(),o=s.readInt(!0);for(let e=0;e<o;e++)t.bones.push(n.bones[s.readInt(!0)]);t.target=n.slots[s.readInt(!0)],t.positionMode=Ae.PositionModeValues[s.readInt(!0)],t.spacingMode=Ae.SpacingModeValues[s.readInt(!0)],t.rotateMode=Ae.RotateModeValues[s.readInt(!0)],t.offsetRotation=s.readFloat(),t.position=s.readFloat(),t.positionMode==T.Fixed&&(t.position*=e),t.spacing=s.readFloat(),t.spacingMode!=me.Length&&t.spacingMode!=me.Fixed||(t.spacing*=e),t.rotateMix=s.readFloat(),t.translateMix=s.readFloat(),n.pathConstraints.push(t)}const i=this.readSkin(s,n,!0,a);null!=i&&(n.defaultSkin=i,n.skins.push(i));{let t=n.skins.length;for(j.setArraySize(n.skins,r=t+s.readInt(!0));t<r;t++)n.skins[t]=this.readSkin(s,n,!1,a)}r=this.linkedMeshes.length;for(let o=0;o<r;o++){const t=this.linkedMeshes[o],e=null==t.skin?n.defaultSkin:n.findSkin(t.skin);if(null==e)throw new Error(`Skin not found: ${t.skin}`);const s=e.getAttachment(t.slotIndex,t.parent);if(null==s)throw new Error(`Parent mesh not found: ${t.parent}`);t.mesh.deformAttachment=t.inheritDeform?s:t.mesh,t.mesh.setParentMesh(s)}this.linkedMeshes.length=0,r=s.readInt(!0);for(let o=0;o<r;o++){const t=new he(s.readStringRef());t.intValue=s.readInt(!1),t.floatValue=s.readFloat(),t.stringValue=s.readString(),t.audioPath=s.readString(),null!=t.audioPath&&(t.volume=s.readFloat(),t.balance=s.readFloat()),n.events.push(t)}r=s.readInt(!0);for(let o=0;o<r;o++)n.animations.push(this.readAnimation(s,s.readString(),n));return n}readSkin(t,e,n,s){let a=null,r=0;if(n){if(r=t.readInt(!0),0==r)return null;a=new Me("default")}else{a=new Me(t.readStringRef()),a.bones.length=t.readInt(!0);for(let n=0,s=a.bones.length;n<s;n++)a.bones[n]=e.bones[t.readInt(!0)];for(let n=0,s=t.readInt(!0);n<s;n++)a.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let n=0,s=t.readInt(!0);n<s;n++)a.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let n=0,s=t.readInt(!0);n<s;n++)a.constraints.push(e.pathConstraints[t.readInt(!0)]);r=t.readInt(!0)}for(let i=0;i<r;i++){const n=t.readInt(!0);for(let r=0,i=t.readInt(!0);r<i;r++){const r=t.readStringRef(),i=this.readAttachment(t,e,a,n,r,s);null!=i&&a.setAttachment(n,r,i)}}return a}readAttachment(t,e,n,s,a,r){const i=this.scale;let o=t.readStringRef();null==o&&(o=a);const l=t.readByte();switch(Ae.AttachmentTypeValues[l]){case S.Region:{let e=t.readStringRef();const s=t.readFloat(),a=t.readFloat(),r=t.readFloat(),l=t.readFloat(),h=t.readFloat(),c=t.readFloat(),d=t.readFloat(),u=t.readInt32();null==e&&(e=o);const m=this.attachmentLoader.newRegionAttachment(n,o,e);return null==m?null:(m.path=e,m.x=a*i,m.y=r*i,m.scaleX=l,m.scaleY=h,m.rotation=s,m.width=c*i,m.height=d*i,O.rgba8888ToColor(m.color,u),m)}case S.BoundingBox:{const e=t.readInt(!0),s=this.readVertices(t,e),a=r?t.readInt32():0,i=this.attachmentLoader.newBoundingBoxAttachment(n,o);return null==i?null:(i.worldVerticesLength=e<<1,i.vertices=s.vertices,i.bones=s.bones,r&&O.rgba8888ToColor(i.color,a),i)}case S.Mesh:{let e=t.readStringRef();const s=t.readInt32(),a=t.readInt(!0),l=this.readFloatArray(t,a<<1,1),h=this.readShortArray(t),c=this.readVertices(t,a),d=t.readInt(!0);let u=null,m=0,f=0;r&&(u=this.readShortArray(t),m=t.readFloat(),f=t.readFloat()),null==e&&(e=o);const g=this.attachmentLoader.newMeshAttachment(n,o,e);return null==g?null:(g.path=e,O.rgba8888ToColor(g.color,s),g.bones=c.bones,g.vertices=c.vertices,g.worldVerticesLength=a<<1,g.triangles=h,g.regionUVs=new Float32Array(l),g.hullLength=d<<1,r&&(g.edges=u,g.width=m*i,g.height=f*i),g)}case S.LinkedMesh:{let e=t.readStringRef();const a=t.readInt32(),l=t.readStringRef(),h=t.readStringRef(),c=t.readBoolean();let d=0,u=0;r&&(d=t.readFloat(),u=t.readFloat()),null==e&&(e=o);const m=this.attachmentLoader.newMeshAttachment(n,o,e);return null==m?null:(m.path=e,O.rgba8888ToColor(m.color,a),r&&(m.width=d*i,m.height=u*i),this.linkedMeshes.push(new Te(m,l,s,h,c)),m)}case S.Path:{const e=t.readBoolean(),s=t.readBoolean(),a=t.readInt(!0),l=this.readVertices(t,a),h=j.newArray(a/3,0);for(let n=0,r=h.length;n<r;n++)h[n]=t.readFloat()*i;const c=r?t.readInt32():0,d=this.attachmentLoader.newPathAttachment(n,o);return null==d?null:(d.closed=e,d.constantSpeed=s,d.worldVerticesLength=a<<1,d.vertices=l.vertices,d.bones=l.bones,d.lengths=h,r&&O.rgba8888ToColor(d.color,c),d)}case S.Point:{const e=t.readFloat(),s=t.readFloat(),a=t.readFloat(),l=r?t.readInt32():0,h=this.attachmentLoader.newPointAttachment(n,o);return null==h?null:(h.x=s*i,h.y=a*i,h.rotation=e,r&&O.rgba8888ToColor(h.color,l),h)}case S.Clipping:{const s=t.readInt(!0),a=t.readInt(!0),i=this.readVertices(t,a),l=r?t.readInt32():0,h=this.attachmentLoader.newClippingAttachment(n,o);return null==h?null:(h.endSlot=e.slots[s],h.worldVerticesLength=a<<1,h.vertices=i.vertices,h.bones=i.bones,r&&O.rgba8888ToColor(h.color,l),h)}}return null}readVertices(t,e){const n=e<<1,s=new ke,a=this.scale;if(!t.readBoolean())return s.vertices=this.readFloatArray(t,n,a),s;const r=new Array,i=new Array;for(let o=0;o<e;o++){const e=t.readInt(!0);i.push(e);for(let n=0;n<e;n++)i.push(t.readInt(!0)),r.push(t.readFloat()*a),r.push(t.readFloat()*a),r.push(t.readFloat())}return s.vertices=j.toFloatArray(r),s.bones=i,s}readFloatArray(t,e,n){const s=new Array(e);if(1==n)for(let a=0;a<e;a++)s[a]=t.readFloat();else for(let a=0;a<e;a++)s[a]=t.readFloat()*n;return s}readShortArray(t){const e=t.readInt(!0),n=new Array(e);for(let s=0;s<e;s++)n[s]=t.readShort();return n}readAnimation(t,e,n){const s=new Array,a=this.scale;let r=0;const i=new O,o=new O;for(let c=0,d=t.readInt(!0);c<d;c++){const e=t.readInt(!0);for(let n=0,a=t.readInt(!0);n<a;n++){const n=t.readByte(),a=t.readInt(!0);switch(n){case Ae.SLOT_ATTACHMENT:{const n=new Nt(a);n.slotIndex=e;for(let e=0;e<a;e++)n.setFrame(e,t.readFloat(),t.readStringRef());s.push(n),r=Math.max(r,n.frames[a-1]);break}case Ae.SLOT_COLOR:{const n=new Pt(a);n.slotIndex=e;for(let e=0;e<a;e++){const s=t.readFloat();O.rgba8888ToColor(i,t.readInt32()),n.setFrame(e,s,i.r,i.g,i.b,i.a),e<a-1&&this.readCurve(t,e,n)}s.push(n),r=Math.max(r,n.frames[(a-1)*Pt.ENTRIES]);break}case Ae.SLOT_TWO_COLOR:{const n=new Yt(a);n.slotIndex=e;for(let e=0;e<a;e++){const s=t.readFloat();O.rgba8888ToColor(i,t.readInt32()),O.rgb888ToColor(o,t.readInt32()),n.setFrame(e,s,i.r,i.g,i.b,i.a,o.r,o.g,o.b),e<a-1&&this.readCurve(t,e,n)}s.push(n),r=Math.max(r,n.frames[(a-1)*Yt.ENTRIES]);break}}}}for(let c=0,d=t.readInt(!0);c<d;c++){const e=t.readInt(!0);for(let n=0,i=t.readInt(!0);n<i;n++){const n=t.readByte(),i=t.readInt(!0);switch(n){case Ae.BONE_ROTATE:{const n=new Tt(i);n.boneIndex=e;for(let e=0;e<i;e++)n.setFrame(e,t.readFloat(),t.readFloat()),e<i-1&&this.readCurve(t,e,n);s.push(n),r=Math.max(r,n.frames[(i-1)*Tt.ENTRIES]);break}case Ae.BONE_TRANSLATE:case Ae.BONE_SCALE:case Ae.BONE_SHEAR:{let o,l=1;n==Ae.BONE_SCALE?o=new Ct(i):n==Ae.BONE_SHEAR?o=new Vt(i):(o=new Rt(i),l=a),o.boneIndex=e;for(let e=0;e<i;e++)o.setFrame(e,t.readFloat(),t.readFloat()*l,t.readFloat()*l),e<i-1&&this.readCurve(t,e,o);s.push(o),r=Math.max(r,o.frames[(i-1)*Rt.ENTRIES]);break}}}}for(let c=0,d=t.readInt(!0);c<d;c++){const e=t.readInt(!0),n=t.readInt(!0),i=new Ot(n);i.ikConstraintIndex=e;for(let s=0;s<n;s++)i.setFrame(s,t.readFloat(),t.readFloat(),t.readFloat()*a,t.readByte(),t.readBoolean(),t.readBoolean()),s<n-1&&this.readCurve(t,s,i);s.push(i),r=Math.max(r,i.frames[(n-1)*Ot.ENTRIES])}for(let c=0,d=t.readInt(!0);c<d;c++){const e=t.readInt(!0),n=t.readInt(!0),a=new qt(n);a.transformConstraintIndex=e;for(let s=0;s<n;s++)a.setFrame(s,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat()),s<n-1&&this.readCurve(t,s,a);s.push(a),r=Math.max(r,a.frames[(n-1)*qt.ENTRIES])}for(let c=0,d=t.readInt(!0);c<d;c++){const e=t.readInt(!0),i=n.pathConstraints[e];for(let n=0,o=t.readInt(!0);n<o;n++){const n=t.readByte(),o=t.readInt(!0);switch(n){case Ae.PATH_POSITION:case Ae.PATH_SPACING:{let l,h=1;n==Ae.PATH_SPACING?(l=new zt(o),i.spacingMode!=me.Length&&i.spacingMode!=me.Fixed||(h=a)):(l=new Ut(o),i.positionMode==T.Fixed&&(h=a)),l.pathConstraintIndex=e;for(let e=0;e<o;e++)l.setFrame(e,t.readFloat(),t.readFloat()*h),e<o-1&&this.readCurve(t,e,l);s.push(l),r=Math.max(r,l.frames[(o-1)*Ut.ENTRIES]);break}case Ae.PATH_MIX:{const n=new jt(o);n.pathConstraintIndex=e;for(let e=0;e<o;e++)n.setFrame(e,t.readFloat(),t.readFloat(),t.readFloat()),e<o-1&&this.readCurve(t,e,n);s.push(n),r=Math.max(r,n.frames[(o-1)*jt.ENTRIES]);break}}}}for(let c=0,d=t.readInt(!0);c<d;c++){const e=n.skins[t.readInt(!0)];for(let n=0,i=t.readInt(!0);n<i;n++){const n=t.readInt(!0);for(let i=0,o=t.readInt(!0);i<o;i++){const i=e.getAttachment(n,t.readStringRef()),o=null!=i.bones,l=i.vertices,h=o?l.length/3*2:l.length,c=t.readInt(!0),d=new Dt(c);d.slotIndex=n,d.attachment=i;for(let e=0;e<c;e++){const n=t.readFloat();let s,r=t.readInt(!0);if(0==r)s=o?j.newFloatArray(h):l;else{s=j.newFloatArray(h);const e=t.readInt(!0);if(r+=e,1==a)for(let n=e;n<r;n++)s[n]=t.readFloat();else for(let n=e;n<r;n++)s[n]=t.readFloat()*a;if(!o)for(let t=0,n=s.length;t<n;t++)s[t]+=l[t]}d.setFrame(e,n,s),e<c-1&&this.readCurve(t,e,d)}s.push(d),r=Math.max(r,d.frames[c-1])}}}const l=t.readInt(!0);if(l>0){const e=new Lt(l),a=n.slots.length;for(let n=0;n<l;n++){const s=t.readFloat(),r=t.readInt(!0),i=j.newArray(a,0);for(let t=a-1;t>=0;t--)i[t]=-1;const o=j.newArray(a-r,0);let l=0,h=0;for(let e=0;e<r;e++){const e=t.readInt(!0);for(;l!=e;)o[h++]=l++;i[l+t.readInt(!0)]=l++}for(;l<a;)o[h++]=l++;for(let t=a-1;t>=0;t--)-1==i[t]&&(i[t]=o[--h]);e.setFrame(n,s,i)}s.push(e),r=Math.max(r,e.frames[l-1])}const h=t.readInt(!0);if(h>0){const e=new Bt(h);for(let s=0;s<h;s++){const a=t.readFloat(),r=n.events[t.readInt(!0)],i=new le(a,r);i.intValue=t.readInt(!1),i.floatValue=t.readFloat(),i.stringValue=t.readBoolean()?t.readString():r.stringValue,null!=i.data.audioPath&&(i.volume=t.readFloat(),i.balance=t.readFloat()),e.setFrame(s,i)}s.push(e),r=Math.max(r,e.frames[h-1])}return new yt(e,s,r)}readCurve(t,e,n){switch(t.readByte()){case Ae.CURVE_STEPPED:n.setStepped(e);break;case Ae.CURVE_BEZIER:this.setCurve(n,e,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat())}}setCurve(t,e,n,s,a,r){t.setCurve(e,n,s,a,r)}};let Ie=Ae;Ie.AttachmentTypeValues=[0,1,2,3,4,5,6],Ie.TransformModeValues=[R.Normal,R.OnlyTranslation,R.NoRotationOrReflection,R.NoScale,R.NoScaleOrReflection],Ie.PositionModeValues=[T.Fixed,T.Percent],Ie.SpacingModeValues=[me.Length,me.Fixed,me.Percent],Ie.RotateModeValues=[k.Tangent,k.Chain,k.ChainScale],Ie.BlendModeValues=[y.NORMAL,y.ADD,y.MULTIPLY,y.SCREEN],Ie.BONE_ROTATE=0,Ie.BONE_TRANSLATE=1,Ie.BONE_SCALE=2,Ie.BONE_SHEAR=3,Ie.SLOT_ATTACHMENT=0,Ie.SLOT_COLOR=1,Ie.SLOT_TWO_COLOR=2,Ie.PATH_POSITION=0,Ie.PATH_SPACING=1,Ie.PATH_MIX=2,Ie.CURVE_LINEAR=0,Ie.CURVE_STEPPED=1,Ie.CURVE_BEZIER=2;let Te=class{constructor(t,e,n,s,a){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=s,this.inheritDeform=a}},ke=class{constructor(t=null,e=null){this.bones=t,this.vertices=e}},Re=class t{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(e){const n=this.scale,s=new be,a="string"==typeof e?JSON.parse(e):e,r=a.skeleton;if(null!=r){if(s.hash=r.hash,s.version=r.spine,"3.8"!==s.version.substr(0,3)){const t=`Spine 3.8 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(t)}if("3.8.75"===s.version){const t="Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.";console.error(t)}s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images}if(a.bones)for(let i=0;i<a.bones.length;i++){const e=a.bones[i];let r=null;const o=this.getValue(e,"parent",null);if(null!=o&&(r=s.findBone(o),null==r))throw new Error(`Parent bone not found: ${o}`);const l=new ie(s.bones.length,e.name,r);l.length=this.getValue(e,"length",0)*n,l.x=this.getValue(e,"x",0)*n,l.y=this.getValue(e,"y",0)*n,l.rotation=this.getValue(e,"rotation",0),l.scaleX=this.getValue(e,"scaleX",1),l.scaleY=this.getValue(e,"scaleY",1),l.shearX=this.getValue(e,"shearX",0),l.shearY=this.getValue(e,"shearY",0),l.transformMode=t.transformModeFromString(this.getValue(e,"transform","normal")),l.skinRequired=this.getValue(e,"skin",!1),s.bones.push(l)}if(a.slots)for(let i=0;i<a.slots.length;i++){const e=a.slots[i],n=e.name,r=e.bone,o=s.findBone(r);if(null==o)throw new Error(`Slot bone not found: ${r}`);const l=new Ee(s.slots.length,n,o),h=this.getValue(e,"color",null);null!=h&&l.color.setFromString(h);const c=this.getValue(e,"dark",null);null!=c&&(l.darkColor=new O(1,1,1,1),l.darkColor.setFromString(c)),l.attachmentName=this.getValue(e,"attachment",null),l.blendMode=t.blendModeFromString(this.getValue(e,"blend","normal")),s.slots.push(l)}if(a.ik)for(let t=0;t<a.ik.length;t++){const e=a.ik[t],r=new de(e.name);r.order=this.getValue(e,"order",0),r.skinRequired=this.getValue(e,"skin",!1);for(let t=0;t<e.bones.length;t++){const n=e.bones[t],a=s.findBone(n);if(null==a)throw new Error(`IK bone not found: ${n}`);r.bones.push(a)}const i=e.target;if(r.target=s.findBone(i),null==r.target)throw new Error(`IK target bone not found: ${i}`);r.mix=this.getValue(e,"mix",1),r.softness=this.getValue(e,"softness",0)*n,r.bendDirection=this.getValue(e,"bendPositive",!0)?1:-1,r.compress=this.getValue(e,"compress",!1),r.stretch=this.getValue(e,"stretch",!1),r.uniform=this.getValue(e,"uniform",!1),s.ikConstraints.push(r)}if(a.transform)for(let t=0;t<a.transform.length;t++){const e=a.transform[t],r=new ye(e.name);r.order=this.getValue(e,"order",0),r.skinRequired=this.getValue(e,"skin",!1);for(let t=0;t<e.bones.length;t++){const n=e.bones[t],a=s.findBone(n);if(null==a)throw new Error(`Transform constraint bone not found: ${n}`);r.bones.push(a)}const i=e.target;if(r.target=s.findBone(i),null==r.target)throw new Error(`Transform constraint target bone not found: ${i}`);r.local=this.getValue(e,"local",!1),r.relative=this.getValue(e,"relative",!1),r.offsetRotation=this.getValue(e,"rotation",0),r.offsetX=this.getValue(e,"x",0)*n,r.offsetY=this.getValue(e,"y",0)*n,r.offsetScaleX=this.getValue(e,"scaleX",0),r.offsetScaleY=this.getValue(e,"scaleY",0),r.offsetShearY=this.getValue(e,"shearY",0),r.rotateMix=this.getValue(e,"rotateMix",1),r.translateMix=this.getValue(e,"translateMix",1),r.scaleMix=this.getValue(e,"scaleMix",1),r.shearMix=this.getValue(e,"shearMix",1),s.transformConstraints.push(r)}if(a.path)for(let i=0;i<a.path.length;i++){const e=a.path[i],r=new ue(e.name);r.order=this.getValue(e,"order",0),r.skinRequired=this.getValue(e,"skin",!1);for(let t=0;t<e.bones.length;t++){const n=e.bones[t],a=s.findBone(n);if(null==a)throw new Error(`Transform constraint bone not found: ${n}`);r.bones.push(a)}const o=e.target;if(r.target=s.findSlot(o),null==r.target)throw new Error(`Path target slot not found: ${o}`);r.positionMode=t.positionModeFromString(this.getValue(e,"positionMode","percent")),r.spacingMode=t.spacingModeFromString(this.getValue(e,"spacingMode","length")),r.rotateMode=t.rotateModeFromString(this.getValue(e,"rotateMode","tangent")),r.offsetRotation=this.getValue(e,"rotation",0),r.position=this.getValue(e,"position",0),r.positionMode==T.Fixed&&(r.position*=n),r.spacing=this.getValue(e,"spacing",0),r.spacingMode!=me.Length&&r.spacingMode!=me.Fixed||(r.spacing*=n),r.rotateMix=this.getValue(e,"rotateMix",1),r.translateMix=this.getValue(e,"translateMix",1),s.pathConstraints.push(r)}if(a.skins)for(let t=0;t<a.skins.length;t++){const e=a.skins[t],n=new Me(e.name);if(e.bones)for(let a=0;a<e.bones.length;a++){const r=s.findBone(e.bones[a]);if(null==r)throw new Error(`Skin bone not found: ${e.bones[t]}`);n.bones.push(r)}if(e.ik)for(let a=0;a<e.ik.length;a++){const r=s.findIkConstraint(e.ik[a]);if(null==r)throw new Error(`Skin IK constraint not found: ${e.ik[t]}`);n.constraints.push(r)}if(e.transform)for(let a=0;a<e.transform.length;a++){const r=s.findTransformConstraint(e.transform[a]);if(null==r)throw new Error(`Skin transform constraint not found: ${e.transform[t]}`);n.constraints.push(r)}if(e.path)for(let a=0;a<e.path.length;a++){const r=s.findPathConstraint(e.path[a]);if(null==r)throw new Error(`Skin path constraint not found: ${e.path[t]}`);n.constraints.push(r)}for(const t in e.attachments){const a=s.findSlot(t);if(null==a)throw new Error(`Slot not found: ${t}`);const r=e.attachments[t];for(const t in r){const e=this.readAttachment(r[t],n,a.index,t,s);null!=e&&n.setAttachment(a.index,t,e)}}s.skins.push(n),"default"==n.name&&(s.defaultSkin=n)}for(let t=0,i=this.linkedMeshes.length;t<i;t++){const e=this.linkedMeshes[t],n=null==e.skin?s.defaultSkin:s.findSkin(e.skin);if(null==n)throw new Error(`Skin not found: ${e.skin}`);const a=n.getAttachment(e.slotIndex,e.parent);if(null==a)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.deformAttachment=e.inheritDeform?a:e.mesh,e.mesh.setParentMesh(a)}if(this.linkedMeshes.length=0,a.events)for(const t in a.events){const e=a.events[t],n=new he(t);n.intValue=this.getValue(e,"int",0),n.floatValue=this.getValue(e,"float",0),n.stringValue=this.getValue(e,"string",""),n.audioPath=this.getValue(e,"audio",null),null!=n.audioPath&&(n.volume=this.getValue(e,"volume",1),n.balance=this.getValue(e,"balance",0)),s.events.push(n)}if(a.animations)for(const t in a.animations){const e=a.animations[t];this.readAnimation(e,t,s)}return s}readAttachment(t,e,n,s,a){const r=this.scale;s=this.getValue(t,"name",s);switch(this.getValue(t,"type","region")){case"region":{const n=this.getValue(t,"path",s),a=this.attachmentLoader.newRegionAttachment(e,s,n);if(null==a)return null;a.path=n,a.x=this.getValue(t,"x",0)*r,a.y=this.getValue(t,"y",0)*r,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*r,a.height=t.height*r;const i=this.getValue(t,"color",null);return null!=i&&a.color.setFromString(i),a}case"boundingbox":{const n=this.attachmentLoader.newBoundingBoxAttachment(e,s);if(null==n)return null;this.readVertices(t,n,t.vertexCount<<1);const a=this.getValue(t,"color",null);return null!=a&&n.color.setFromString(a),n}case"mesh":case"linkedmesh":{const a=this.getValue(t,"path",s),i=this.attachmentLoader.newMeshAttachment(e,s,a);if(null==i)return null;i.path=a;const o=this.getValue(t,"color",null);null!=o&&i.color.setFromString(o),i.width=this.getValue(t,"width",0)*r,i.height=this.getValue(t,"height",0)*r;const l=this.getValue(t,"parent",null);if(null!=l)return this.linkedMeshes.push(new Ce(i,this.getValue(t,"skin",null),n,l,this.getValue(t,"deform",!0))),i;const h=t.uvs;return this.readVertices(t,i,h.length),i.triangles=t.triangles,i.regionUVs=new Float32Array(h),i.edges=this.getValue(t,"edges",null),i.hullLength=2*this.getValue(t,"hull",0),i}case"path":{const n=this.attachmentLoader.newPathAttachment(e,s);if(null==n)return null;n.closed=this.getValue(t,"closed",!1),n.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,n,a<<1);const i=j.newArray(a/3,0);for(let e=0;e<t.lengths.length;e++)i[e]=t.lengths[e]*r;n.lengths=i;const o=this.getValue(t,"color",null);return null!=o&&n.color.setFromString(o),n}case"point":{const n=this.attachmentLoader.newPointAttachment(e,s);if(null==n)return null;n.x=this.getValue(t,"x",0)*r,n.y=this.getValue(t,"y",0)*r,n.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return null!=a&&n.color.setFromString(a),n}case"clipping":{const n=this.attachmentLoader.newClippingAttachment(e,s);if(null==n)return null;const r=this.getValue(t,"end",null);if(null!=r){const t=a.findSlot(r);if(null==t)throw new Error(`Clipping end slot not found: ${r}`);n.endSlot=t}const i=t.vertexCount;this.readVertices(t,n,i<<1);const o=this.getValue(t,"color",null);return null!=o&&n.color.setFromString(o),n}}return null}readVertices(t,e,n){const s=this.scale;e.worldVerticesLength=n;const a=t.vertices;if(n==a.length){const t=j.toFloatArray(a);if(1!=s)for(let e=0,n=a.length;e<n;e++)t[e]*=s;return void(e.vertices=t)}const r=new Array,i=new Array;for(let o=0,l=a.length;o<l;){const t=a[o++];i.push(t);for(let e=o+4*t;o<e;o+=4)i.push(a[o]),r.push(a[o+1]*s),r.push(a[o+2]*s),r.push(a[o+3])}e.bones=i,e.vertices=j.toFloatArray(r)}readAnimation(t,e,n){const s=this.scale,a=new Array;let r=0;if(t.slots)for(const o in t.slots){const e=t.slots[o],s=n.findSlotIndex(o);if(-1==s)throw new Error(`Slot not found: ${o}`);for(const t in e){const n=e[t];if("attachment"==t){const t=new Nt(n.length);t.slotIndex=s;let e=0;for(let s=0;s<n.length;s++){const a=n[s];t.setFrame(e++,this.getValue(a,"time",0),a.name)}a.push(t),r=Math.max(r,t.frames[t.getFrameCount()-1])}else if("color"==t){const t=new Pt(n.length);t.slotIndex=s;let e=0;for(let s=0;s<n.length;s++){const a=n[s],r=new O;r.setFromString(a.color||"ffffffff"),t.setFrame(e,this.getValue(a,"time",0),r.r,r.g,r.b,r.a),this.readCurve(a,t,e),e++}a.push(t),r=Math.max(r,t.frames[(t.getFrameCount()-1)*Pt.ENTRIES])}else{if("twoColor"!=t)throw new Error(`Invalid timeline type for a slot: ${t} (${o})`);{const t=new Yt(n.length);t.slotIndex=s;let e=0;for(let s=0;s<n.length;s++){const a=n[s],r=new O,i=new O;r.setFromString(a.light),i.setFromString(a.dark),t.setFrame(e,this.getValue(a,"time",0),r.r,r.g,r.b,r.a,i.r,i.g,i.b),this.readCurve(a,t,e),e++}a.push(t),r=Math.max(r,t.frames[(t.getFrameCount()-1)*Yt.ENTRIES])}}}}if(t.bones)for(const o in t.bones){const e=t.bones[o],i=n.findBoneIndex(o);if(-1==i)throw new Error(`Bone not found: ${o}`);for(const t in e){const n=e[t];if("rotate"===t){const t=new Tt(n.length);t.boneIndex=i;let e=0;for(let s=0;s<n.length;s++){const a=n[s];t.setFrame(e,this.getValue(a,"time",0),this.getValue(a,"angle",0)),this.readCurve(a,t,e),e++}a.push(t),r=Math.max(r,t.frames[(t.getFrameCount()-1)*Tt.ENTRIES])}else{if("translate"!==t&&"scale"!==t&&"shear"!==t)throw new Error(`Invalid timeline type for a bone: ${t} (${o})`);{let e=null,o=1,l=0;"scale"===t?(e=new Ct(n.length),l=1):"shear"===t?e=new Vt(n.length):(e=new Rt(n.length),o=s),e.boneIndex=i;let h=0;for(let t=0;t<n.length;t++){const s=n[t],a=this.getValue(s,"x",l),r=this.getValue(s,"y",l);e.setFrame(h,this.getValue(s,"time",0),a*o,r*o),this.readCurve(s,e,h),h++}a.push(e),r=Math.max(r,e.frames[(e.getFrameCount()-1)*Rt.ENTRIES])}}}}if(t.ik)for(const o in t.ik){const e=t.ik[o],i=n.findIkConstraint(o),l=new Ot(e.length);l.ikConstraintIndex=n.ikConstraints.indexOf(i);let h=0;for(let t=0;t<e.length;t++){const n=e[t];l.setFrame(h,this.getValue(n,"time",0),this.getValue(n,"mix",1),this.getValue(n,"softness",0)*s,this.getValue(n,"bendPositive",!0)?1:-1,this.getValue(n,"compress",!1),this.getValue(n,"stretch",!1)),this.readCurve(n,l,h),h++}a.push(l),r=Math.max(r,l.frames[(l.getFrameCount()-1)*Ot.ENTRIES])}if(t.transform)for(const o in t.transform){const e=t.transform[o],s=n.findTransformConstraint(o),i=new qt(e.length);i.transformConstraintIndex=n.transformConstraints.indexOf(s);let l=0;for(let t=0;t<e.length;t++){const n=e[t];i.setFrame(l,this.getValue(n,"time",0),this.getValue(n,"rotateMix",1),this.getValue(n,"translateMix",1),this.getValue(n,"scaleMix",1),this.getValue(n,"shearMix",1)),this.readCurve(n,i,l),l++}a.push(i),r=Math.max(r,i.frames[(i.getFrameCount()-1)*qt.ENTRIES])}if(t.path)for(const o in t.path){const e=t.path[o],i=n.findPathConstraintIndex(o);if(-1==i)throw new Error(`Path constraint not found: ${o}`);const l=n.pathConstraints[i];for(const t in e){const n=e[t];if("position"===t||"spacing"===t){let e=null,o=1;"spacing"===t?(e=new zt(n.length),l.spacingMode!=me.Length&&l.spacingMode!=me.Fixed||(o=s)):(e=new Ut(n.length),l.positionMode==T.Fixed&&(o=s)),e.pathConstraintIndex=i;let h=0;for(let s=0;s<n.length;s++){const a=n[s];e.setFrame(h,this.getValue(a,"time",0),this.getValue(a,t,0)*o),this.readCurve(a,e,h),h++}a.push(e),r=Math.max(r,e.frames[(e.getFrameCount()-1)*Ut.ENTRIES])}else if("mix"===t){const t=new jt(n.length);t.pathConstraintIndex=i;let e=0;for(let s=0;s<n.length;s++){const a=n[s];t.setFrame(e,this.getValue(a,"time",0),this.getValue(a,"rotateMix",1),this.getValue(a,"translateMix",1)),this.readCurve(a,t,e),e++}a.push(t),r=Math.max(r,t.frames[(t.getFrameCount()-1)*jt.ENTRIES])}}}if(t.deform)for(const o in t.deform){const e=t.deform[o],i=n.findSkin(o);if(null!=i)for(const t in e){const o=e[t],l=n.findSlotIndex(t);if(-1==l)throw new Error(`Slot not found: ${o.name}`);for(const t in o){const e=o[t],n=i.getAttachment(l,t);if(null==n)throw new Error(`Deform attachment not found: ${e.name}`);const h=null!=n.bones,c=n.vertices,d=h?c.length/3*2:c.length,u=new Dt(e.length);u.slotIndex=l,u.attachment=n;let m=0;for(let t=0;t<e.length;t++){const n=e[t];let a;const r=this.getValue(n,"vertices",null);if(null==r)a=h?j.newFloatArray(d):c;else{a=j.newFloatArray(d);const t=this.getValue(n,"offset",0);if(j.arrayCopy(r,0,a,t,r.length),1!=s)for(let e=t,n=e+r.length;e<n;e++)a[e]*=s;if(!h)for(let e=0;e<d;e++)a[e]+=c[e]}u.setFrame(m,this.getValue(n,"time",0),a),this.readCurve(n,u,m),m++}a.push(u),r=Math.max(r,u.frames[u.getFrameCount()-1])}}}let i=t.drawOrder;if(null==i&&(i=t.draworder),null!=i){const t=new Lt(i.length),e=n.slots.length;let s=0;for(let a=0;a<i.length;a++){const r=i[a];let o=null;const l=this.getValue(r,"offsets",null);if(null!=l){o=j.newArray(e,-1);const t=j.newArray(e-l.length,0);let s=0,a=0;for(let e=0;e<l.length;e++){const r=l[e],i=n.findSlotIndex(r.slot);if(-1==i)throw new Error(`Slot not found: ${r.slot}`);for(;s!=i;)t[a++]=s++;o[s+r.offset]=s++}for(;s<e;)t[a++]=s++;for(let n=e-1;n>=0;n--)-1==o[n]&&(o[n]=t[--a])}t.setFrame(s++,this.getValue(r,"time",0),o)}a.push(t),r=Math.max(r,t.frames[t.getFrameCount()-1])}if(t.events){const e=new Bt(t.events.length);let s=0;for(let a=0;a<t.events.length;a++){const r=t.events[a],i=n.findEvent(r.name);if(null==i)throw new Error(`Event not found: ${r.name}`);const o=new le(j.toSinglePrecision(this.getValue(r,"time",0)),i);o.intValue=this.getValue(r,"int",i.intValue),o.floatValue=this.getValue(r,"float",i.floatValue),o.stringValue=this.getValue(r,"string",i.stringValue),null!=o.data.audioPath&&(o.volume=this.getValue(r,"volume",1),o.balance=this.getValue(r,"balance",0)),e.setFrame(s++,o)}a.push(e),r=Math.max(r,e.frames[e.getFrameCount()-1])}if(isNaN(r))throw new Error("Error while parsing animation, duration is NaN");n.animations.push(new yt(e,a,r))}readCurve(t,e,n){if(t.hasOwnProperty("curve"))if("stepped"===t.curve)e.setStepped(n);else{const s=t.curve;e.setCurve(n,s,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,e,n){return void 0!==t[e]?t[e]:n}static blendModeFromString(t){if("normal"==(t=t.toLowerCase()))return y.NORMAL;if("additive"==t)return y.ADD;if("multiply"==t)return y.MULTIPLY;if("screen"==t)return y.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if("fixed"==(t=t.toLowerCase()))return T.Fixed;if("percent"==t)return T.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if("length"==(t=t.toLowerCase()))return me.Length;if("fixed"==t)return me.Fixed;if("percent"==t)return me.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if("tangent"==(t=t.toLowerCase()))return k.Tangent;if("chain"==t)return k.Chain;if("chainscale"==t)return k.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if("normal"==(t=t.toLowerCase()))return R.Normal;if("onlytranslation"==t)return R.OnlyTranslation;if("norotationorreflection"==t)return R.NoRotationOrReflection;if("noscale"==t)return R.NoScale;if("noscaleorreflection"==t)return R.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}},Ce=class{constructor(t,e,n,s,a){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=s,this.inheritDeform=a}};const Ve=Object.freeze(Object.defineProperty({__proto__:null,Animation:yt,AnimationState:Zt,AnimationStateAdapter:class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}},AnimationStateData:se,AtlasAttachmentLoader:ae,Attachment:lt,AttachmentTimeline:Nt,Bone:re,BoneData:ie,BoundingBoxAttachment:dt,ClippingAttachment:ut,ColorTimeline:Pt,ConstraintData:oe,CurveTimeline:At,DeformTimeline:Dt,DrawOrderTimeline:Lt,Event:le,EventData:he,EventQueue:te,EventTimeline:Bt,EventType:ee,IkConstraint:ce,IkConstraintData:de,IkConstraintTimeline:Ot,JitterEffect:class{constructor(t,e){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,n,s){t.x+=q.randomTriangular(-this.jitterX,this.jitterY),t.y+=q.randomTriangular(-this.jitterX,this.jitterY)}end(){}},MeshAttachment:mt,PathAttachment:ft,PathConstraint:ge,PathConstraintData:ue,PathConstraintMixTimeline:jt,PathConstraintPositionTimeline:Ut,PathConstraintSpacingTimeline:zt,PointAttachment:gt,RegionAttachment:wt,RotateTimeline:Tt,ScaleTimeline:Ct,ShearTimeline:Vt,Skeleton:we,SkeletonBinary:Ie,SkeletonBounds:class extends Q{},SkeletonData:be,SkeletonJson:Re,Skin:Me,SkinEntry:Se,Slot:pt,SlotData:Ee,SpacingMode:me,Spine:class extends st{createSkeleton(t){this.skeleton=new we(t),this.skeleton.updateWorldTransform(),this.stateData=new se(t),this.state=new Zt(this.stateData)}},SwirlEffect:Et,TimelineType:St,TrackEntry:Kt,TransformConstraint:pe,TransformConstraintData:ye,TransformConstraintTimeline:qt,TranslateTimeline:Rt,TwoColorTimeline:Yt,VertexAttachment:ct},Symbol.toStringTag,{value:"Module"}));let ve=class{constructor(t){if(null==t)throw new Error("name cannot be null.");this.name=t}};const Pe=class extends ve{constructor(t){super(t),this.id=(65535&Pe.nextID++)<<11,this.worldVerticesLength=0}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,n,s,a,r){n=a+(n>>1)*r;const i=t.bone.skeleton,o=t.attachmentVertices;let l=this.vertices;const h=this.bones;if(null==h){o.length>0&&(l=o);const i=t.bone.matrix,h=i.tx,c=i.ty,d=i.a,u=i.c,m=i.b,f=i.d;for(let t=e,o=a;o<n;t+=2,o+=r){const e=l[t],n=l[t+1];s[o]=e*d+n*u+h,s[o+1]=e*m+n*f+c}return}let c=0,d=0;for(let m=0;m<e;m+=2){const t=h[c];c+=t+1,d+=t}const u=i.bones;if(0==o.length)for(let m=a,f=3*d;m<n;m+=r){let t=0,e=0,n=h[c++];for(n+=c;c<n;c++,f+=3){const n=u[h[c]].matrix,s=l[f],a=l[f+1],r=l[f+2];t+=(s*n.a+a*n.c+n.tx)*r,e+=(s*n.b+a*n.d+n.ty)*r}s[m]=t,s[m+1]=e}else{const t=o;for(let e=a,i=3*d,o=d<<1;e<n;e+=r){let n=0,a=0,r=h[c++];for(r+=c;c<r;c++,i+=3,o+=2){const e=u[h[c]].matrix,s=l[i]+t[o],r=l[i+1]+t[o+1],d=l[i+2];n+=(s*e.a+r*e.c+e.tx)*d,a+=(s*e.b+r*e.d+e.ty)*d}s[e]=n,s[e+1]=a}}}applyDeform(t){return this==t}};let Fe=Pe;Fe.nextID=0;let Ye=class extends Fe{constructor(t){super(t),this.type=S.BoundingBox,this.color=new O(1,1,1,1)}},Ne=class extends Fe{constructor(t){super(t),this.type=S.Clipping,this.color=new O(.2275,.2275,.8078,1)}},Xe=class extends Fe{constructor(t){super(t),this.type=S.Mesh,this.color=new O(1,1,1,1),this.inheritDeform=!1,this.tempColor=new O(0,0,0,0)}applyDeform(t){return this==t||this.inheritDeform&&this.parentMesh==t}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,null!=t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}},De=class extends Fe{constructor(t){super(t),this.type=S.Path,this.closed=!1,this.constantSpeed=!1,this.color=new O(1,1,1,1)}},Be=class extends Fe{constructor(t){super(t),this.type=S.Point,this.color=new O(.38,.94,0,1)}computeWorldPosition(t,e){const n=t.matrix;return e.x=this.x*n.a+this.y*n.c+t.worldX,e.y=this.x*n.b+this.y*n.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,n=q.cosDeg(this.rotation),s=q.sinDeg(this.rotation),a=n*e.a+s*e.c,r=n*e.b+s*e.d;return Math.atan2(r,a)*q.radDeg}},Le=class{constructor(t,e){if(this.attachmentVertices=new Array,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new O,this.darkColor=null==t.darkColor?null:new O,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.attachmentVertices.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),null!=this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),null==this.data.attachmentName?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};const _e=class extends ve{constructor(t){super(t),this.type=S.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new O(1,1,1,1),this.offset=j.newFloatArray(8),this.uvs=j.newFloatArray(8),this.tempColor=new O(1,1,1,1)}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*t,s=-this.height/2*this.scaleY+this.region.offsetY*e,a=n+this.region.width*t,r=s+this.region.height*e,i=this.rotation*Math.PI/180,o=Math.cos(i),l=Math.sin(i),h=n*o+this.x,c=n*l,d=s*o+this.y,u=s*l,m=a*o+this.x,f=a*l,g=r*o+this.y,p=r*l,x=this.offset;x[_e.OX1]=h-u,x[_e.OY1]=d+c,x[_e.OX2]=h-p,x[_e.OY2]=g+c,x[_e.OX3]=m-p,x[_e.OY3]=g+f,x[_e.OX4]=m-u,x[_e.OY4]=d+f}setRegion(t){this.region=t;const e=this.uvs;t.rotate?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,n,s){const a=this.offset,r=t instanceof Le?t.bone.matrix:t.matrix,i=r.tx,o=r.ty,l=r.a,h=r.c,c=r.b,d=r.d;let u=0,m=0;u=a[_e.OX1],m=a[_e.OY1],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[_e.OX2],m=a[_e.OY2],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[_e.OX3],m=a[_e.OY3],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o,n+=s,u=a[_e.OX4],m=a[_e.OY4],e[n]=u*l+m*h+i,e[n+1]=u*c+m*d+o}};let Oe=_e;Oe.OX1=0,Oe.OY1=1,Oe.OX2=2,Oe.OY2=3,Oe.OX3=4,Oe.OY3=5,Oe.OX4=6,Oe.OY4=7,Oe.X1=0,Oe.Y1=1,Oe.C1R=2,Oe.C1G=3,Oe.C1B=4,Oe.C1A=5,Oe.U1=6,Oe.V1=7,Oe.X2=8,Oe.Y2=9,Oe.C2R=10,Oe.C2G=11,Oe.C2B=12,Oe.C2A=13,Oe.U2=14,Oe.V2=15,Oe.X3=16,Oe.Y3=17,Oe.C3R=18,Oe.C3G=19,Oe.C3B=20,Oe.C3A=21,Oe.U3=22,Oe.V3=23,Oe.X4=24,Oe.Y4=25,Oe.C4R=26,Oe.C4G=27,Oe.C4B=28,Oe.C4A=29,Oe.U4=30,Oe.V4=31;const We=class{constructor(t){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,e,n,s){const a=this.angle*q.degreesToRadians,r=t.x-this.worldX,i=t.y-this.worldY,o=Math.sqrt(r*r+i*i);if(o<this.radius){const e=We.interpolation.apply(0,a,(this.radius-o)/this.radius),n=Math.cos(e),s=Math.sin(e);t.x=n*r-s*i+this.worldX,t.y=s*r+n*i+this.worldY}}end(){}};let qe=We;qe.interpolation=new z(2);let $e=class{constructor(t,e,n){if(null==t)throw new Error("name cannot be null.");if(null==e)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.duration=n}apply(t,e,n,s,a,r,i,o){if(null==t)throw new Error("skeleton cannot be null.");s&&0!=this.duration&&(n%=this.duration,e>0&&(e%=this.duration));const l=this.timelines;for(let h=0,c=l.length;h<c;h++)l[h].apply(t,e,n,a,r,i,o)}static binarySearch(t,e,n=1){let s=0,a=t.length/n-2;if(0==a)return n;let r=a>>>1;for(;;){if(t[(r+1)*n]<=e?s=r+1:a=r,s==a)return(s+1)*n;r=s+a>>>1}}static linearSearch(t,e,n){for(let s=0,a=t.length-n;s<=a;s+=n)if(t[s]>e)return s;return-1}};var Ue=(t=>(t[t.rotate=0]="rotate",t[t.translate=1]="translate",t[t.scale=2]="scale",t[t.shear=3]="shear",t[t.attachment=4]="attachment",t[t.color=5]="color",t[t.deform=6]="deform",t[t.event=7]="event",t[t.drawOrder=8]="drawOrder",t[t.ikConstraint=9]="ikConstraint",t[t.transformConstraint=10]="transformConstraint",t[t.pathConstraintPosition=11]="pathConstraintPosition",t[t.pathConstraintSpacing=12]="pathConstraintSpacing",t[t.pathConstraintMix=13]="pathConstraintMix",t[t.twoColor=14]="twoColor",t))(Ue||{});const ze=class{constructor(t){if(t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=j.newFloatArray((t-1)*ze.BEZIER_SIZE)}getFrameCount(){return this.curves.length/ze.BEZIER_SIZE+1}setLinear(t){this.curves[t*ze.BEZIER_SIZE]=ze.LINEAR}setStepped(t){this.curves[t*ze.BEZIER_SIZE]=ze.STEPPED}getCurveType(t){const e=t*ze.BEZIER_SIZE;if(e==this.curves.length)return ze.LINEAR;const n=this.curves[e];return n==ze.LINEAR?ze.LINEAR:n==ze.STEPPED?ze.STEPPED:ze.BEZIER}setCurve(t,e,n,s,a){const r=.03*(2*-e+s),i=.03*(2*-n+a),o=.006*(3*(e-s)+1),l=.006*(3*(n-a)+1);let h=2*r+o,c=2*i+l,d=.3*e+r+.16666667*o,u=.3*n+i+.16666667*l,m=t*ze.BEZIER_SIZE;const f=this.curves;f[m++]=ze.BEZIER;let g=d,p=u;for(let x=m+ze.BEZIER_SIZE-1;m<x;m+=2)f[m]=g,f[m+1]=p,d+=h,u+=c,h+=o,c+=l,g+=d,p+=u}getCurvePercent(t,e){e=q.clamp(e,0,1);const n=this.curves;let s=t*ze.BEZIER_SIZE;const a=n[s];if(a==ze.LINEAR)return e;if(a==ze.STEPPED)return 0;s++;let r=0;for(let o=s,l=s+ze.BEZIER_SIZE-1;s<l;s+=2)if(r=n[s],r>=e){let t,a;return s==o?(t=0,a=0):(t=n[s-2],a=n[s-1]),a+(n[s+1]-a)*(e-t)/(r-t)}const i=n[s-1];return i+(1-i)*(e-r)/(1-r)}};let He=ze;He.LINEAR=0,He.STEPPED=1,He.BEZIER=2,He.BEZIER_SIZE=19;const je=class extends He{constructor(t){super(t),this.frames=j.newFloatArray(t<<1)}getPropertyId(){return 0+this.boneIndex}setFrame(t,e,n){t<<=1,this.frames[t]=e,this.frames[t+je.ROTATION]=n}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.bones[this.boneIndex];if(n<o[0]){switch(r){case A.setup:return void(l.rotation=l.data.rotation);case A.first:const t=l.data.rotation-l.rotation;l.rotation+=(t-360*(16384-(16384.499999999996-t/360|0)))*a}return}if(n>=o[o.length-je.ENTRIES]){let t=o[o.length+je.PREV_ROTATION];switch(r){case A.setup:l.rotation=l.data.rotation+t*a;break;case A.first:case A.replace:t+=l.data.rotation-l.rotation,t-=360*(16384-(16384.499999999996-t/360|0));case A.add:l.rotation+=t*a}return}const h=$e.binarySearch(o,n,je.ENTRIES),c=o[h+je.PREV_ROTATION],d=o[h],u=this.getCurvePercent((h>>1)-1,1-(n-d)/(o[h+je.PREV_TIME]-d));let m=o[h+je.ROTATION]-c;switch(m=c+(m-360*(16384-(16384.499999999996-m/360|0)))*u,r){case A.setup:l.rotation=l.data.rotation+(m-360*(16384-(16384.499999999996-m/360|0)))*a;break;case A.first:case A.replace:m+=l.data.rotation-l.rotation;case A.add:l.rotation+=(m-360*(16384-(16384.499999999996-m/360|0)))*a}}};let Ge=je;Ge.ENTRIES=2,Ge.PREV_TIME=-2,Ge.PREV_ROTATION=-1,Ge.ROTATION=1;const Ze=class extends He{constructor(t){super(t),this.frames=j.newFloatArray(t*Ze.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,e,n,s){t*=Ze.ENTRIES,this.frames[t]=e,this.frames[t+Ze.X]=n,this.frames[t+Ze.Y]=s}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.bones[this.boneIndex];if(n<o[0]){switch(r){case A.setup:return l.x=l.data.x,void(l.y=l.data.y);case A.first:l.x+=(l.data.x-l.x)*a,l.y+=(l.data.y-l.y)*a}return}let h=0,c=0;if(n>=o[o.length-Ze.ENTRIES])h=o[o.length+Ze.PREV_X],c=o[o.length+Ze.PREV_Y];else{const t=$e.binarySearch(o,n,Ze.ENTRIES);h=o[t+Ze.PREV_X],c=o[t+Ze.PREV_Y];const e=o[t],s=this.getCurvePercent(t/Ze.ENTRIES-1,1-(n-e)/(o[t+Ze.PREV_TIME]-e));h+=(o[t+Ze.X]-h)*s,c+=(o[t+Ze.Y]-c)*s}switch(r){case A.setup:l.x=l.data.x+h*a,l.y=l.data.y+c*a;break;case A.first:case A.replace:l.x+=(l.data.x+h-l.x)*a,l.y+=(l.data.y+c-l.y)*a;break;case A.add:l.x+=h*a,l.y+=c*a}}};let Qe=Ze;Qe.ENTRIES=3,Qe.PREV_TIME=-3,Qe.PREV_X=-2,Qe.PREV_Y=-1,Qe.X=1,Qe.Y=2;let Ke=class t extends Qe{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(e,n,s,a,r,i,o){const l=this.frames,h=e.bones[this.boneIndex];if(s<l[0]){switch(i){case A.setup:return h.scaleX=h.data.scaleX,void(h.scaleY=h.data.scaleY);case A.first:h.scaleX+=(h.data.scaleX-h.scaleX)*r,h.scaleY+=(h.data.scaleY-h.scaleY)*r}return}let c=0,d=0;if(s>=l[l.length-t.ENTRIES])c=l[l.length+t.PREV_X]*h.data.scaleX,d=l[l.length+t.PREV_Y]*h.data.scaleY;else{const e=$e.binarySearch(l,s,t.ENTRIES);c=l[e+t.PREV_X],d=l[e+t.PREV_Y];const n=l[e],a=this.getCurvePercent(e/t.ENTRIES-1,1-(s-n)/(l[e+t.PREV_TIME]-n));c=(c+(l[e+t.X]-c)*a)*h.data.scaleX,d=(d+(l[e+t.Y]-d)*a)*h.data.scaleY}if(1==r)i==A.add?(h.scaleX+=c-h.data.scaleX,h.scaleY+=d-h.data.scaleY):(h.scaleX=c,h.scaleY=d);else{let t=0,e=0;if(o==I.mixOut)switch(i){case A.setup:t=h.data.scaleX,e=h.data.scaleY,h.scaleX=t+(Math.abs(c)*q.signum(t)-t)*r,h.scaleY=e+(Math.abs(d)*q.signum(e)-e)*r;break;case A.first:case A.replace:t=h.scaleX,e=h.scaleY,h.scaleX=t+(Math.abs(c)*q.signum(t)-t)*r,h.scaleY=e+(Math.abs(d)*q.signum(e)-e)*r;break;case A.add:t=h.scaleX,e=h.scaleY,h.scaleX=t+(Math.abs(c)*q.signum(t)-h.data.scaleX)*r,h.scaleY=e+(Math.abs(d)*q.signum(e)-h.data.scaleY)*r}else switch(i){case A.setup:t=Math.abs(h.data.scaleX)*q.signum(c),e=Math.abs(h.data.scaleY)*q.signum(d),h.scaleX=t+(c-t)*r,h.scaleY=e+(d-e)*r;break;case A.first:case A.replace:t=Math.abs(h.scaleX)*q.signum(c),e=Math.abs(h.scaleY)*q.signum(d),h.scaleX=t+(c-t)*r,h.scaleY=e+(d-e)*r;break;case A.add:t=q.signum(c),e=q.signum(d),h.scaleX=Math.abs(h.scaleX)*t+(c-Math.abs(h.data.scaleX)*t)*r,h.scaleY=Math.abs(h.scaleY)*e+(d-Math.abs(h.data.scaleY)*e)*r}}}},Je=class t extends Qe{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(e,n,s,a,r,i,o){const l=this.frames,h=e.bones[this.boneIndex];if(s<l[0]){switch(i){case A.setup:return h.shearX=h.data.shearX,void(h.shearY=h.data.shearY);case A.first:h.shearX+=(h.data.shearX-h.shearX)*r,h.shearY+=(h.data.shearY-h.shearY)*r}return}let c=0,d=0;if(s>=l[l.length-t.ENTRIES])c=l[l.length+t.PREV_X],d=l[l.length+t.PREV_Y];else{const e=$e.binarySearch(l,s,t.ENTRIES);c=l[e+t.PREV_X],d=l[e+t.PREV_Y];const n=l[e],a=this.getCurvePercent(e/t.ENTRIES-1,1-(s-n)/(l[e+t.PREV_TIME]-n));c+=(l[e+t.X]-c)*a,d+=(l[e+t.Y]-d)*a}switch(i){case A.setup:h.shearX=h.data.shearX+c*r,h.shearY=h.data.shearY+d*r;break;case A.first:case A.replace:h.shearX+=(h.data.shearX+c-h.shearX)*r,h.shearY+=(h.data.shearY+d-h.shearY)*r;break;case A.add:h.shearX+=c*r,h.shearY+=d*r}}};const tn=class extends He{constructor(t){super(t),this.frames=j.newFloatArray(t*tn.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,e,n,s,a,r){t*=tn.ENTRIES,this.frames[t]=e,this.frames[t+tn.R]=n,this.frames[t+tn.G]=s,this.frames[t+tn.B]=a,this.frames[t+tn.A]=r}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex],l=this.frames;if(n<l[0]){switch(r){case A.setup:return void o.color.setFromColor(o.data.color);case A.first:const t=o.color,e=o.data.color;t.add((e.r-t.r)*a,(e.g-t.g)*a,(e.b-t.b)*a,(e.a-t.a)*a)}return}let h=0,c=0,d=0,u=0;if(n>=l[l.length-tn.ENTRIES]){const t=l.length;h=l[t+tn.PREV_R],c=l[t+tn.PREV_G],d=l[t+tn.PREV_B],u=l[t+tn.PREV_A]}else{const t=$e.binarySearch(l,n,tn.ENTRIES);h=l[t+tn.PREV_R],c=l[t+tn.PREV_G],d=l[t+tn.PREV_B],u=l[t+tn.PREV_A];const e=l[t],s=this.getCurvePercent(t/tn.ENTRIES-1,1-(n-e)/(l[t+tn.PREV_TIME]-e));h+=(l[t+tn.R]-h)*s,c+=(l[t+tn.G]-c)*s,d+=(l[t+tn.B]-d)*s,u+=(l[t+tn.A]-u)*s}if(1==a)o.color.set(h,c,d,u);else{const t=o.color;r==A.setup&&t.setFromColor(o.data.color),t.add((h-t.r)*a,(c-t.g)*a,(d-t.b)*a,(u-t.a)*a)}}};let en=tn;en.ENTRIES=5,en.PREV_TIME=-5,en.PREV_R=-4,en.PREV_G=-3,en.PREV_B=-2,en.PREV_A=-1,en.R=1,en.G=2,en.B=3,en.A=4;const nn=class extends He{constructor(t){super(t),this.frames=j.newFloatArray(t*nn.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,e,n,s,a,r,i,o,l){t*=nn.ENTRIES,this.frames[t]=e,this.frames[t+nn.R]=n,this.frames[t+nn.G]=s,this.frames[t+nn.B]=a,this.frames[t+nn.A]=r,this.frames[t+nn.R2]=i,this.frames[t+nn.G2]=o,this.frames[t+nn.B2]=l}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex],l=this.frames;if(n<l[0]){switch(r){case A.setup:return o.color.setFromColor(o.data.color),void o.darkColor.setFromColor(o.data.darkColor);case A.first:const t=o.color,e=o.darkColor,n=o.data.color,s=o.data.darkColor;t.add((n.r-t.r)*a,(n.g-t.g)*a,(n.b-t.b)*a,(n.a-t.a)*a),e.add((s.r-e.r)*a,(s.g-e.g)*a,(s.b-e.b)*a,0)}return}let h=0,c=0,d=0,u=0,m=0,f=0,g=0;if(n>=l[l.length-nn.ENTRIES]){const t=l.length;h=l[t+nn.PREV_R],c=l[t+nn.PREV_G],d=l[t+nn.PREV_B],u=l[t+nn.PREV_A],m=l[t+nn.PREV_R2],f=l[t+nn.PREV_G2],g=l[t+nn.PREV_B2]}else{const t=$e.binarySearch(l,n,nn.ENTRIES);h=l[t+nn.PREV_R],c=l[t+nn.PREV_G],d=l[t+nn.PREV_B],u=l[t+nn.PREV_A],m=l[t+nn.PREV_R2],f=l[t+nn.PREV_G2],g=l[t+nn.PREV_B2];const e=l[t],s=this.getCurvePercent(t/nn.ENTRIES-1,1-(n-e)/(l[t+nn.PREV_TIME]-e));h+=(l[t+nn.R]-h)*s,c+=(l[t+nn.G]-c)*s,d+=(l[t+nn.B]-d)*s,u+=(l[t+nn.A]-u)*s,m+=(l[t+nn.R2]-m)*s,f+=(l[t+nn.G2]-f)*s,g+=(l[t+nn.B2]-g)*s}if(1==a)o.color.set(h,c,d,u),o.darkColor.set(m,f,g,1);else{const t=o.color,e=o.darkColor;r==A.setup&&(t.setFromColor(o.data.color),e.setFromColor(o.data.darkColor)),t.add((h-t.r)*a,(c-t.g)*a,(d-t.b)*a,(u-t.a)*a),e.add((m-e.r)*a,(f-e.g)*a,(g-e.b)*a,0)}}};let sn=nn;sn.ENTRIES=8,sn.PREV_TIME=-8,sn.PREV_R=-7,sn.PREV_G=-6,sn.PREV_B=-5,sn.PREV_A=-4,sn.PREV_R2=-3,sn.PREV_G2=-2,sn.PREV_B2=-1,sn.R=1,sn.G=2,sn.B=3,sn.A=4,sn.R2=5,sn.G2=6,sn.B2=7;let an=class{constructor(t){this.frames=j.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.attachmentNames[t]=n}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(i==I.mixOut&&r==A.setup){const e=o.data.attachmentName;return void o.setAttachment(null==e?null:t.getAttachment(this.slotIndex,e))}const l=this.frames;if(n<l[0]){if(r==A.setup||r==A.first){const e=o.data.attachmentName;o.setAttachment(null==e?null:t.getAttachment(this.slotIndex,e))}return}let h=0;h=n>=l[l.length-1]?l.length-1:$e.binarySearch(l,n,1)-1;const c=this.attachmentNames[h];t.slots[this.slotIndex].setAttachment(null==c?null:t.getAttachment(this.slotIndex,c))}},rn=null,on=class extends He{constructor(t){super(t),this.frames=j.newFloatArray(t),this.frameVertices=new Array(t),null==rn&&(rn=j.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,e,n){this.frames[t]=e,this.frameVertices[t]=n}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex],l=o.getAttachment();if(!(l instanceof Fe&&l.applyDeform(this.attachment)))return;const h=o.attachmentVertices;0==h.length&&(r=A.setup);const c=this.frameVertices,d=c[0].length,u=this.frames;if(n<u[0]){const t=l;switch(r){case A.setup:return void(h.length=0);case A.first:if(1==a){h.length=0;break}const e=j.setArraySize(h,d);if(null==t.bones){const n=t.vertices;for(let t=0;t<d;t++)e[t]+=(n[t]-e[t])*a}else{a=1-a;for(let t=0;t<d;t++)e[t]*=a}}return}const m=j.setArraySize(h,d);if(n>=u[u.length-1]){const t=c[u.length-1];if(1==a)if(r==A.add){const e=l;if(null==e.bones){const n=e.vertices;for(let e=0;e<d;e++)m[e]+=t[e]-n[e]}else for(let n=0;n<d;n++)m[n]+=t[n]}else j.arrayCopy(t,0,m,0,d);else switch(r){case A.setup:{const e=l;if(null==e.bones){const n=e.vertices;for(let e=0;e<d;e++){const s=n[e];m[e]=s+(t[e]-s)*a}}else for(let n=0;n<d;n++)m[n]=t[n]*a;break}case A.first:case A.replace:for(let n=0;n<d;n++)m[n]+=(t[n]-m[n])*a;case A.add:const e=l;if(null==e.bones){const n=e.vertices;for(let e=0;e<d;e++)m[e]+=(t[e]-n[e])*a}else for(let n=0;n<d;n++)m[n]+=t[n]*a}return}const f=$e.binarySearch(u,n),g=c[f-1],p=c[f],x=u[f],w=this.getCurvePercent(f-1,1-(n-x)/(u[f-1]-x));if(1==a)if(r==A.add){const t=l;if(null==t.bones){const e=t.vertices;for(let t=0;t<d;t++){const n=g[t];m[t]+=n+(p[t]-n)*w-e[t]}}else for(let e=0;e<d;e++){const t=g[e];m[e]+=t+(p[e]-t)*w}}else for(let b=0;b<d;b++){const t=g[b];m[b]=t+(p[b]-t)*w}else switch(r){case A.setup:{const t=l;if(null==t.bones){const e=t.vertices;for(let t=0;t<d;t++){const n=g[t],s=e[t];m[t]=s+(n+(p[t]-n)*w-s)*a}}else for(let e=0;e<d;e++){const t=g[e];m[e]=(t+(p[e]-t)*w)*a}break}case A.first:case A.replace:for(let e=0;e<d;e++){const t=g[e];m[e]+=(t+(p[e]-t)*w-m[e])*a}break;case A.add:const t=l;if(null==t.bones){const e=t.vertices;for(let t=0;t<d;t++){const n=g[t];m[t]+=(n+(p[t]-n)*w-e[t])*a}}else for(let e=0;e<d;e++){const t=g[e];m[e]+=(t+(p[e]-t)*w)*a}}}},ln=class{constructor(t){this.frames=j.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,n,s,a,r,i){if(null==s)return;const o=this.frames,l=this.frames.length;if(e>n)this.apply(t,e,Number.MAX_VALUE,s,a,r,i),e=-1;else if(e>=o[l-1])return;if(n<o[0])return;let h=0;if(e<o[0])h=0;else{h=$e.binarySearch(o,e);const t=o[h];for(;h>0&&o[h-1]==t;)h--}for(;h<l&&n>=o[h];h++)s.push(this.events[h])}},hn=class{constructor(t){this.frames=j.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.drawOrders[t]=n}apply(t,e,n,s,a,r,i){const o=t.drawOrder,l=t.slots;if(i==I.mixOut&&r==A.setup)return void j.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);const h=this.frames;if(n<h[0])return void(r!=A.setup&&r!=A.first||j.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length));let c=0;c=n>=h[h.length-1]?h.length-1:$e.binarySearch(h,n)-1;const d=this.drawOrders[c];if(null==d)j.arrayCopy(l,0,o,0,l.length);else for(let u=0,m=d.length;u<m;u++)o[u]=l[d[u]]}};const cn=class extends He{constructor(t){super(t),this.frames=j.newFloatArray(t*cn.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,e,n,s,a,r){t*=cn.ENTRIES,this.frames[t]=e,this.frames[t+cn.MIX]=n,this.frames[t+cn.BEND_DIRECTION]=s,this.frames[t+cn.COMPRESS]=a?1:0,this.frames[t+cn.STRETCH]=r?1:0}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.ikConstraints[this.ikConstraintIndex];if(n<o[0]){switch(r){case A.setup:return l.mix=l.data.mix,l.bendDirection=l.data.bendDirection,l.compress=l.data.compress,void(l.stretch=l.data.stretch);case A.first:l.mix+=(l.data.mix-l.mix)*a,l.bendDirection=l.data.bendDirection,l.compress=l.data.compress,l.stretch=l.data.stretch}return}if(n>=o[o.length-cn.ENTRIES])return void(r==A.setup?(l.mix=l.data.mix+(o[o.length+cn.PREV_MIX]-l.data.mix)*a,i==I.mixOut?(l.bendDirection=l.data.bendDirection,l.compress=l.data.compress,l.stretch=l.data.stretch):(l.bendDirection=o[o.length+cn.PREV_BEND_DIRECTION],l.compress=0!=o[o.length+cn.PREV_COMPRESS],l.stretch=0!=o[o.length+cn.PREV_STRETCH])):(l.mix+=(o[o.length+cn.PREV_MIX]-l.mix)*a,i==I.mixIn&&(l.bendDirection=o[o.length+cn.PREV_BEND_DIRECTION],l.compress=0!=o[o.length+cn.PREV_COMPRESS],l.stretch=0!=o[o.length+cn.PREV_STRETCH])));const h=$e.binarySearch(o,n,cn.ENTRIES),c=o[h+cn.PREV_MIX],d=o[h],u=this.getCurvePercent(h/cn.ENTRIES-1,1-(n-d)/(o[h+cn.PREV_TIME]-d));r==A.setup?(l.mix=l.data.mix+(c+(o[h+cn.MIX]-c)*u-l.data.mix)*a,i==I.mixOut?(l.bendDirection=l.data.bendDirection,l.compress=l.data.compress,l.stretch=l.data.stretch):(l.bendDirection=o[h+cn.PREV_BEND_DIRECTION],l.compress=0!=o[h+cn.PREV_COMPRESS],l.stretch=0!=o[h+cn.PREV_STRETCH])):(l.mix+=(c+(o[h+cn.MIX]-c)*u-l.mix)*a,i==I.mixIn&&(l.bendDirection=o[h+cn.PREV_BEND_DIRECTION],l.compress=0!=o[h+cn.PREV_COMPRESS],l.stretch=0!=o[h+cn.PREV_STRETCH]))}};let dn=cn;dn.ENTRIES=5,dn.PREV_TIME=-5,dn.PREV_MIX=-4,dn.PREV_BEND_DIRECTION=-3,dn.PREV_COMPRESS=-2,dn.PREV_STRETCH=-1,dn.MIX=1,dn.BEND_DIRECTION=2,dn.COMPRESS=3,dn.STRETCH=4;const un=class extends He{constructor(t){super(t),this.frames=j.newFloatArray(t*un.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,e,n,s,a,r){t*=un.ENTRIES,this.frames[t]=e,this.frames[t+un.ROTATE]=n,this.frames[t+un.TRANSLATE]=s,this.frames[t+un.SCALE]=a,this.frames[t+un.SHEAR]=r}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.transformConstraints[this.transformConstraintIndex];if(n<o[0]){const t=l.data;switch(r){case A.setup:return l.rotateMix=t.rotateMix,l.translateMix=t.translateMix,l.scaleMix=t.scaleMix,void(l.shearMix=t.shearMix);case A.first:l.rotateMix+=(t.rotateMix-l.rotateMix)*a,l.translateMix+=(t.translateMix-l.translateMix)*a,l.scaleMix+=(t.scaleMix-l.scaleMix)*a,l.shearMix+=(t.shearMix-l.shearMix)*a}return}let h=0,c=0,d=0,u=0;if(n>=o[o.length-un.ENTRIES]){const t=o.length;h=o[t+un.PREV_ROTATE],c=o[t+un.PREV_TRANSLATE],d=o[t+un.PREV_SCALE],u=o[t+un.PREV_SHEAR]}else{const t=$e.binarySearch(o,n,un.ENTRIES);h=o[t+un.PREV_ROTATE],c=o[t+un.PREV_TRANSLATE],d=o[t+un.PREV_SCALE],u=o[t+un.PREV_SHEAR];const e=o[t],s=this.getCurvePercent(t/un.ENTRIES-1,1-(n-e)/(o[t+un.PREV_TIME]-e));h+=(o[t+un.ROTATE]-h)*s,c+=(o[t+un.TRANSLATE]-c)*s,d+=(o[t+un.SCALE]-d)*s,u+=(o[t+un.SHEAR]-u)*s}if(r==A.setup){const t=l.data;l.rotateMix=t.rotateMix+(h-t.rotateMix)*a,l.translateMix=t.translateMix+(c-t.translateMix)*a,l.scaleMix=t.scaleMix+(d-t.scaleMix)*a,l.shearMix=t.shearMix+(u-t.shearMix)*a}else l.rotateMix+=(h-l.rotateMix)*a,l.translateMix+=(c-l.translateMix)*a,l.scaleMix+=(d-l.scaleMix)*a,l.shearMix+=(u-l.shearMix)*a}};let mn=un;mn.ENTRIES=5,mn.PREV_TIME=-5,mn.PREV_ROTATE=-4,mn.PREV_TRANSLATE=-3,mn.PREV_SCALE=-2,mn.PREV_SHEAR=-1,mn.ROTATE=1,mn.TRANSLATE=2,mn.SCALE=3,mn.SHEAR=4;const fn=class extends He{constructor(t){super(t),this.frames=j.newFloatArray(t*fn.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,e,n){t*=fn.ENTRIES,this.frames[t]=e,this.frames[t+fn.VALUE]=n}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.pathConstraints[this.pathConstraintIndex];if(n<o[0]){switch(r){case A.setup:return void(l.position=l.data.position);case A.first:l.position+=(l.data.position-l.position)*a}return}let h=0;if(n>=o[o.length-fn.ENTRIES])h=o[o.length+fn.PREV_VALUE];else{const t=$e.binarySearch(o,n,fn.ENTRIES);h=o[t+fn.PREV_VALUE];const e=o[t],s=this.getCurvePercent(t/fn.ENTRIES-1,1-(n-e)/(o[t+fn.PREV_TIME]-e));h+=(o[t+fn.VALUE]-h)*s}r==A.setup?l.position=l.data.position+(h-l.data.position)*a:l.position+=(h-l.position)*a}};let gn=fn;gn.ENTRIES=2,gn.PREV_TIME=-2,gn.PREV_VALUE=-1,gn.VALUE=1;let pn=class t extends gn{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(e,n,s,a,r,i,o){const l=this.frames,h=e.pathConstraints[this.pathConstraintIndex];if(s<l[0]){switch(i){case A.setup:return void(h.spacing=h.data.spacing);case A.first:h.spacing+=(h.data.spacing-h.spacing)*r}return}let c=0;if(s>=l[l.length-t.ENTRIES])c=l[l.length+t.PREV_VALUE];else{const e=$e.binarySearch(l,s,t.ENTRIES);c=l[e+t.PREV_VALUE];const n=l[e],a=this.getCurvePercent(e/t.ENTRIES-1,1-(s-n)/(l[e+t.PREV_TIME]-n));c+=(l[e+t.VALUE]-c)*a}i==A.setup?h.spacing=h.data.spacing+(c-h.data.spacing)*r:h.spacing+=(c-h.spacing)*r}};const xn=class extends He{constructor(t){super(t),this.frames=j.newFloatArray(t*xn.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,e,n,s){t*=xn.ENTRIES,this.frames[t]=e,this.frames[t+xn.ROTATE]=n,this.frames[t+xn.TRANSLATE]=s}apply(t,e,n,s,a,r,i){const o=this.frames,l=t.pathConstraints[this.pathConstraintIndex];if(n<o[0]){switch(r){case A.setup:return l.rotateMix=l.data.rotateMix,void(l.translateMix=l.data.translateMix);case A.first:l.rotateMix+=(l.data.rotateMix-l.rotateMix)*a,l.translateMix+=(l.data.translateMix-l.translateMix)*a}return}let h=0,c=0;if(n>=o[o.length-xn.ENTRIES])h=o[o.length+xn.PREV_ROTATE],c=o[o.length+xn.PREV_TRANSLATE];else{const t=$e.binarySearch(o,n,xn.ENTRIES);h=o[t+xn.PREV_ROTATE],c=o[t+xn.PREV_TRANSLATE];const e=o[t],s=this.getCurvePercent(t/xn.ENTRIES-1,1-(n-e)/(o[t+xn.PREV_TIME]-e));h+=(o[t+xn.ROTATE]-h)*s,c+=(o[t+xn.TRANSLATE]-c)*s}r==A.setup?(l.rotateMix=l.data.rotateMix+(h-l.data.rotateMix)*a,l.translateMix=l.data.translateMix+(c-l.data.translateMix)*a):(l.rotateMix+=(h-l.rotateMix)*a,l.translateMix+=(c-l.translateMix)*a)}};let wn=xn;wn.ENTRIES=3,wn.PREV_TIME=-3,wn.PREV_ROTATE=-2,wn.PREV_TRANSLATE=-1,wn.ROTATE=1,wn.TRANSLATE=2;const bn=class{constructor(t){this.tracks=new Array,this.events=new Array,this.listeners=new Array,this.queue=new An(this),this.propertyIDs=new B,this.animationsChanged=!1,this.timeScale=1,this.trackEntryPool=new G((()=>new Sn)),this.data=t}update(t){t*=this.timeScale;const e=this.tracks;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(null==s)continue;s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast;let a=t*s.timeScale;if(s.delay>0){if(s.delay-=a,s.delay>0)continue;a=-s.delay,s.delay=0}let r=s.next;if(null!=r){const e=s.trackLast-r.delay;if(e>=0){for(r.delay=0,r.trackTime=0==s.timeScale?0:(e/s.timeScale+t)*r.timeScale,s.trackTime+=a,this.setCurrent(n,r,!0);null!=r.mixingFrom;)r.mixTime+=t,r=r.mixingFrom;continue}}else if(s.trackLast>=s.trackEnd&&null==s.mixingFrom){e[n]=null,this.queue.end(s),this.disposeNext(s);continue}if(null!=s.mixingFrom&&this.updateMixingFrom(s,t)){let t=s.mixingFrom;for(s.mixingFrom=null,null!=t&&(t.mixingTo=null);null!=t;)this.queue.end(t),t=t.mixingFrom}s.trackTime+=a}this.queue.drain()}updateMixingFrom(t,e){const n=t.mixingFrom;if(null==n)return!0;const s=this.updateMixingFrom(n,e);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?(0!=n.totalAlpha&&0!=t.mixDuration||(t.mixingFrom=n.mixingFrom,null!=n.mixingFrom&&(n.mixingFrom.mixingTo=t),t.interruptAlpha=n.interruptAlpha,this.queue.end(n)),s):(n.trackTime+=e*n.timeScale,t.mixTime+=e,!1)}apply(t){if(null==t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,n=this.tracks;let s=!1;for(let a=0,r=n.length;a<r;a++){const r=n[a];if(null==r||r.delay>0)continue;s=!0;const i=0==a?A.first:r.mixBlend;let o=r.alpha;null!=r.mixingFrom?o*=this.applyMixingFrom(r,t,i):r.trackTime>=r.trackEnd&&null==r.next&&(o=0);const l=r.animationLast,h=r.getAnimationTime(),c=r.animation.timelines.length,d=r.animation.timelines;if(0==a&&1==o||i==A.add)for(let n=0;n<c;n++)d[n].apply(t,l,h,e,o,i,I.mixIn);else{const n=r.timelineMode,s=0==r.timelinesRotation.length;s&&j.setArraySize(r.timelinesRotation,c<<1,null);const a=r.timelinesRotation;for(let r=0;r<c;r++){const c=d[r],u=n[r]==bn.SUBSEQUENT?i:A.setup;c instanceof Ge?this.applyRotateTimeline(c,t,h,o,u,a,r<<1,s):c.apply(t,l,h,e,o,u,I.mixIn)}}this.queueEvents(r,h),e.length=0,r.nextAnimationLast=h,r.nextTrackLast=r.trackTime}return this.queue.drain(),s}applyMixingFrom(t,e,n){const s=t.mixingFrom;null!=s.mixingFrom&&this.applyMixingFrom(s,e,n);let a=0;0==t.mixDuration?(a=1,n==A.first&&(n=A.setup)):(a=t.mixTime/t.mixDuration,a>1&&(a=1),n!=A.first&&(n=s.mixBlend));const r=a<s.eventThreshold?this.events:null,i=a<s.attachmentThreshold,o=a<s.drawOrderThreshold,l=s.animationLast,h=s.getAnimationTime(),c=s.animation.timelines.length,d=s.animation.timelines,u=s.alpha*t.interruptAlpha,m=u*(1-a);if(n==A.add)for(let f=0;f<c;f++)d[f].apply(e,l,h,r,m,n,I.mixOut);else{const t=s.timelineMode,a=s.timelineHoldMix,f=0==s.timelinesRotation.length;f&&j.setArraySize(s.timelinesRotation,c<<1,null);const g=s.timelinesRotation;s.totalAlpha=0;for(let p=0;p<c;p++){const c=d[p];let x,w=I.mixOut,b=0;switch(t[p]){case bn.SUBSEQUENT:if(!i&&c instanceof an)continue;if(!o&&c instanceof hn)continue;x=n,b=m;break;case bn.FIRST:x=A.setup,b=m;break;case bn.HOLD:x=A.setup,b=u;break;default:x=A.setup;const t=a[p];b=u*Math.max(0,1-t.mixTime/t.mixDuration)}s.totalAlpha+=b,c instanceof Ge?this.applyRotateTimeline(c,e,h,b,x,g,p<<1,f):(x==A.setup&&(c instanceof an?i&&(w=I.mixOut):c instanceof hn&&o&&(w=I.mixOut)),c.apply(e,l,h,r,b,x,w))}}return t.mixDuration>0&&this.queueEvents(s,h),this.events.length=0,s.nextAnimationLast=h,s.nextTrackLast=s.trackTime,a}applyRotateTimeline(t,e,n,s,a,r,i,o){if(o&&(r[i]=0),1==s)return void t.apply(e,0,n,null,1,a,I.mixIn);const l=t,h=l.frames,c=e.bones[l.boneIndex];let d=0,u=0;if(n<h[0])switch(a){case A.setup:c.rotation=c.data.rotation;default:return;case A.first:d=c.rotation,u=c.data.rotation}else if(d=a==A.setup?c.data.rotation:c.rotation,n>=h[h.length-Ge.ENTRIES])u=c.data.rotation+h[h.length+Ge.PREV_ROTATION];else{const t=$e.binarySearch(h,n,Ge.ENTRIES),e=h[t+Ge.PREV_ROTATION],s=h[t],a=l.getCurvePercent((t>>1)-1,1-(n-s)/(h[t+Ge.PREV_TIME]-s));u=h[t+Ge.ROTATION]-e,u-=360*(16384-(16384.499999999996-u/360|0)),u=e+u*a+c.data.rotation,u-=360*(16384-(16384.499999999996-u/360|0))}let m=0,f=u-d;if(f-=360*(16384-(16384.499999999996-f/360|0)),0==f)m=r[i];else{let t=0,e=0;o?(t=0,e=f):(t=r[i],e=r[i+1]);const n=f>0;let s=t>=0;q.signum(e)!=q.signum(f)&&Math.abs(e)<=90&&(Math.abs(t)>180&&(t+=360*q.signum(t)),s=n),m=f+t-t%360,s!=n&&(m+=360*q.signum(t)),r[i]=m}r[i+1]=f,d+=m*s,c.rotation=d-360*(16384-(16384.499999999996-d/360|0))}queueEvents(t,e){const n=t.animationStart,s=t.animationEnd,a=s-n,r=t.trackLast%a,i=this.events;let o=0;const l=i.length;for(;o<l;o++){const e=i[o];if(e.time<r)break;e.time>s||this.queue.event(t,e)}let h=!1;for(h=t.loop?0==a||r>t.trackTime%a:e>=s&&t.animationLast<s,h&&this.queue.complete(t);o<l;o++){i[o].time<n||this.queue.event(t,i[o])}}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,n=this.tracks.length;e<n;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(null==e)return;this.queue.end(e),this.disposeNext(e);let n=e;for(;;){const t=n.mixingFrom;if(null==t)break;this.queue.end(t),n.mixingFrom=null,n.mixingTo=null,n=t}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,n){const s=this.expandToIndex(t);this.tracks[t]=e,null!=s&&(n&&this.queue.interrupt(s),e.mixingFrom=s,s.mixingTo=e,e.mixTime=0,null!=s.mixingFrom&&s.mixDuration>0&&(e.interruptAlpha*=Math.min(1,s.mixTime/s.mixDuration)),s.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,n){const s=this.data.skeletonData.findAnimation(e);if(null==s)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,s,n)}setAnimationWith(t,e,n){if(null==e)throw new Error("animation cannot be null.");let s=!0,a=this.expandToIndex(t);null!=a&&(-1==a.nextTrackLast?(this.tracks[t]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.disposeNext(a),a=a.mixingFrom,s=!1):this.disposeNext(a));const r=this.trackEntry(t,e,n,a);return this.setCurrent(t,r,s),this.queue.drain(),r}addAnimation(t,e,n,s){const a=this.data.skeletonData.findAnimation(e);if(null==a)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,a,n,s)}addAnimationWith(t,e,n,s){if(null==e)throw new Error("animation cannot be null.");let a=this.expandToIndex(t);if(null!=a)for(;null!=a.next;)a=a.next;const r=this.trackEntry(t,e,n,a);if(null==a)this.setCurrent(t,r,!0),this.queue.drain();else if(a.next=r,s<=0){const t=a.animationEnd-a.animationStart;0!=t?(a.loop?s+=t*(1+(a.trackTime/t|0)):s+=Math.max(t,a.trackTime),s-=this.data.getMix(a.animation,e)):s=a.trackTime}return r.delay=s,r}setEmptyAnimation(t,e){const n=this.setAnimationWith(t,bn.emptyAnimation,!1);return n.mixDuration=e,n.trackEnd=e,n}addEmptyAnimation(t,e,n){n<=0&&(n-=e);const s=this.addAnimationWith(t,bn.emptyAnimation,!1,n);return s.mixDuration=e,s.trackEnd=e,s}setEmptyAnimations(t){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,s=this.tracks.length;n<s;n++){const e=this.tracks[n];null!=e&&this.setEmptyAnimation(e.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(j.ensureArrayCapacity(this.tracks,t-this.tracks.length+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,n,s){const a=this.trackEntryPool.obtain();return a.trackIndex=t,a.animation=e,a.loop=n,a.holdPrevious=!1,a.eventThreshold=0,a.attachmentThreshold=0,a.drawOrderThreshold=0,a.animationStart=0,a.animationEnd=e.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.interruptAlpha=1,a.mixTime=0,a.mixDuration=null==s?0:this.data.getMix(s.animation,e),a}disposeNext(t){let e=t.next;for(;null!=e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,e=this.tracks.length;t<e;t++){let e=this.tracks[t];if(null!=e){for(;null!=e.mixingFrom;)e=e.mixingFrom;do{null!=e.mixingFrom&&e.mixBlend==A.add||this.setTimelineModes(e),e=e.mixingTo}while(null!=e)}}}setTimelineModes(t){const e=t.mixingTo,n=t.animation.timelines,s=t.animation.timelines.length,a=j.setArraySize(t.timelineMode,s);t.timelineHoldMix.length=0;const r=j.setArraySize(t.timelineHoldMix,s),i=this.propertyIDs;if(null!=e&&e.holdPrevious)for(let o=0;o<s;o++)i.add(n[o].getPropertyId()),a[o]=bn.HOLD;else t:for(let o=0;o<s;o++){const s=n[o].getPropertyId();if(i.add(s))if(null!=e&&this.hasTimeline(e,s)){for(let n=e.mixingTo;null!=n;n=n.mixingTo)if(!this.hasTimeline(n,s)){if(t.mixDuration>0){a[o]=bn.HOLD_MIX,r[o]=n;continue t}break}a[o]=bn.HOLD}else a[o]=bn.FIRST;else a[o]=bn.SUBSEQUENT}}hasTimeline(t,e){const n=t.animation.timelines;for(let s=0,a=n.length;s<a;s++)if(n[s].getPropertyId()==e)return!0;return!1}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(null==t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,n){bn.deprecatedWarning1||(bn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,n)}addAnimationByName(t,e,n,s){bn.deprecatedWarning2||(bn.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,n,s)}hasAnimation(t){return null!==this.data.skeletonData.findAnimation(t)}hasAnimationByName(t){return bn.deprecatedWarning3||(bn.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};let En=bn;En.emptyAnimation=new $e("<empty>",[],0),En.SUBSEQUENT=0,En.FIRST=1,En.HOLD=2,En.HOLD_MIX=3,En.deprecatedWarning1=!1,En.deprecatedWarning2=!1,En.deprecatedWarning3=!1;const yn=class{constructor(){this.mixBlend=A.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return 0==t?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return yn.deprecatedWarning1||(yn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){yn.deprecatedWarning1||(yn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return yn.deprecatedWarning2||(yn.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){yn.deprecatedWarning2||(yn.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Sn=yn;Sn.deprecatedWarning1=!1,Sn.deprecatedWarning2=!1;const Mn=class{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(In.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(In.interrupt),this.objects.push(t)}end(t){this.objects.push(In.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(In.dispose),this.objects.push(t)}complete(t){this.objects.push(In.complete),this.objects.push(t)}event(t,e){this.objects.push(In.event),this.objects.push(t),this.objects.push(e)}deprecateStuff(){return Mn.deprecatedWarning1||(Mn.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let n=0;n<t.length;n+=2){const s=t[n],a=t[n+1];switch(s){case In.start:null!=a.listener&&a.listener.start&&a.listener.start(a);for(let t=0;t<e.length;t++)e[t].start&&e[t].start(a);a.onStart&&this.deprecateStuff()&&a.onStart(a.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(a.trackIndex);break;case In.interrupt:null!=a.listener&&a.listener.interrupt&&a.listener.interrupt(a);for(let t=0;t<e.length;t++)e[t].interrupt&&e[t].interrupt(a);break;case In.end:null!=a.listener&&a.listener.end&&a.listener.end(a);for(let t=0;t<e.length;t++)e[t].end&&e[t].end(a);a.onEnd&&this.deprecateStuff()&&a.onEnd(a.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(a.trackIndex);case In.dispose:null!=a.listener&&a.listener.dispose&&a.listener.dispose(a);for(let t=0;t<e.length;t++)e[t].dispose&&e[t].dispose(a);this.animState.trackEntryPool.free(a);break;case In.complete:null!=a.listener&&a.listener.complete&&a.listener.complete(a);for(let t=0;t<e.length;t++)e[t].complete&&e[t].complete(a);const s=q.toInt(a.loopsCount());a.onComplete&&this.deprecateStuff()&&a.onComplete(a.trackIndex,s),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(a.trackIndex,s);break;case In.event:const r=t[2+n++];null!=a.listener&&a.listener.event&&a.listener.event(a,r);for(let t=0;t<e.length;t++)e[t].event&&e[t].event(a,r);a.onEvent&&this.deprecateStuff()&&a.onEvent(a.trackIndex,r),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(a.trackIndex,r)}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let An=Mn;An.deprecatedWarning1=!1;var In=(t=>(t[t.start=0]="start",t[t.interrupt=1]="interrupt",t[t.end=2]="end",t[t.dispose=3]="dispose",t[t.complete=4]="complete",t[t.event=5]="event",t))(In||{});const Tn=class{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,null==t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,n){const s=this.skeletonData.findAnimation(t);if(null==s)throw new Error(`Animation not found: ${t}`);const a=this.skeletonData.findAnimation(e);if(null==a)throw new Error(`Animation not found: ${e}`);this.setMixWith(s,a,n)}setMixByName(t,e,n){Tn.deprecatedWarning1||(Tn.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(t,e,n)}setMixWith(t,e,n){if(null==t)throw new Error("from cannot be null.");if(null==e)throw new Error("to cannot be null.");const s=`${t.name}.${e.name}`;this.animationToMixTime[s]=n}getMix(t,e){const n=`${t.name}.${e.name}`,s=this.animationToMixTime[n];return void 0===s?this.defaultMix:s}};let kn=Tn;kn.deprecatedWarning1=!1;let Rn=class{constructor(t){this.atlas=t}newRegionAttachment(t,e,n){const s=this.atlas.findRegion(n);if(null==s)throw new Error(`Region not found in atlas: ${n} (region attachment: ${e})`);const a=new Oe(e);return a.region=s,a}newMeshAttachment(t,e,n){const s=this.atlas.findRegion(n);if(null==s)throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${e})`);const a=new Xe(e);return a.region=s,a}newBoundingBoxAttachment(t,e){return new Ye(e)}newPathAttachment(t,e){return new De(e)}newPointAttachment(t,e){return new Be(e)}newClippingAttachment(t,e){return new Ne(e)}},Cn=class{constructor(t,e,n){if(this.matrix=new E,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!0,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=n,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,n,s,a,r,i){this.ax=t,this.ay=e,this.arotation=n,this.ascaleX=s,this.ascaleY=a,this.ashearX=r,this.ashearY=i,this.appliedValid=!0;const o=this.parent,l=this.matrix,h=this.skeleton.scaleX,c=-this.skeleton.scaleY;if(null==o){const o=this.skeleton,d=n+90+i;return l.a=q.cosDeg(n+r)*s*h,l.c=q.cosDeg(d)*a*h,l.b=q.sinDeg(n+r)*s*c,l.d=q.sinDeg(d)*a*c,l.tx=t*h+o.x,void(l.ty=e*c+o.y)}let d=o.matrix.a,u=o.matrix.c,m=o.matrix.b,f=o.matrix.d;switch(l.tx=d*t+u*e+o.matrix.tx,l.ty=m*t+f*e+o.matrix.ty,this.data.transformMode){case R.Normal:{const t=n+90+i,e=q.cosDeg(n+r)*s,o=q.cosDeg(t)*a,h=q.sinDeg(n+r)*s,c=q.sinDeg(t)*a;return l.a=d*e+u*h,l.c=d*o+u*c,l.b=m*e+f*h,void(l.d=m*o+f*c)}case R.OnlyTranslation:{const t=n+90+i;l.a=q.cosDeg(n+r)*s,l.c=q.cosDeg(t)*a,l.b=q.sinDeg(n+r)*s,l.d=q.sinDeg(t)*a;break}case R.NoRotationOrReflection:{let t=d*d+m*m,e=0;t>1e-4?(t=Math.abs(d*f-u*m)/t,u=m*t,f=d*t,e=Math.atan2(m,d)*q.radDeg):(d=0,m=0,e=90-Math.atan2(f,u)*q.radDeg);const o=n+r-e,h=n+i-e+90,c=q.cosDeg(o)*s,g=q.cosDeg(h)*a,p=q.sinDeg(o)*s,x=q.sinDeg(h)*a;l.a=d*c-u*p,l.c=d*g-u*x,l.b=m*c+f*p,l.d=m*g+f*x;break}case R.NoScale:case R.NoScaleOrReflection:{const t=q.cosDeg(n),e=q.sinDeg(n);let o=(d*t+u*e)/h,g=(m*t+f*e)/c,p=Math.sqrt(o*o+g*g);p>1e-5&&(p=1/p),o*=p,g*=p,p=Math.sqrt(o*o+g*g),this.data.transformMode==R.NoScale&&d*f-u*m<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY>0)&&(p=-p);const x=Math.PI/2+Math.atan2(g,o),w=Math.cos(x)*p,b=Math.sin(x)*p,E=q.cosDeg(r)*s,y=q.cosDeg(90+i)*a,S=q.sinDeg(r)*s,M=q.sinDeg(90+i)*a;l.a=o*E+w*S,l.c=o*y+w*M,l.b=g*E+b*S,l.d=g*y+b*M;break}}l.a*=h,l.c*=h,l.b*=c,l.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*q.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*q.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,e=this.matrix;if(null==t)return this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*q.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,void(this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*q.radDeg);const n=t.matrix,s=1/(n.a*n.d-n.b*n.c),a=e.tx-n.tx,r=e.ty-n.ty;this.ax=a*n.d*s-r*n.c*s,this.ay=r*n.a*s-a*n.b*s;const i=s*n.d,o=s*n.a,l=s*n.c,h=s*n.b,c=i*e.a-l*e.b,d=i*e.c-l*e.d,u=o*e.b-h*e.a,m=o*e.d-h*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+u*u),this.ascaleX>1e-4){const t=c*m-d*u;this.ascaleY=t/this.ascaleX,this.ashearY=Math.atan2(c*d+u*m,t)*q.radDeg,this.arotation=Math.atan2(u,c)*q.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(d*d+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,d)*q.radDeg}worldToLocal(t){const e=this.matrix,n=e.a,s=e.c,a=e.b,r=e.d,i=1/(n*r-s*a),o=t.x-e.tx,l=t.y-e.ty;return t.x=o*r*i-l*s*i,t.y=l*n*i-o*a*i,t}localToWorld(t){const e=this.matrix,n=t.x,s=t.y;return t.x=n*e.a+s*e.c+e.tx,t.y=n*e.b+s*e.d+e.ty,t}worldToLocalRotation(t){const e=q.sinDeg(t),n=q.cosDeg(t),s=this.matrix;return Math.atan2(s.a*e-s.b*n,s.d*n-s.c*e)*q.radDeg}localToWorldRotation(t){const e=q.sinDeg(t),n=q.cosDeg(t),s=this.matrix;return Math.atan2(n*s.b+e*s.d,n*s.a+e*s.c)*q.radDeg}rotateWorld(t){const e=this.matrix,n=e.a,s=e.c,a=e.b,r=e.d,i=q.cosDeg(t),o=q.sinDeg(t);e.a=i*n-o*a,e.c=i*s-o*r,e.b=o*n+i*a,e.d=o*s+i*r,this.appliedValid=!1}},Vn=class{constructor(t,e,n){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=R.Normal,t<0)throw new Error("index must be >= 0.");if(null==e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=n}},vn=class{constructor(t,e){if(null==e)throw new Error("data cannot be null.");this.time=t,this.data=e}},Pn=class{constructor(t){this.name=t}},Fn=class{constructor(t,e){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}getOrder(){return this.data.order}apply(){this.update()}update(){const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.mix)}}apply1(t,e,n,s,a,r,i){t.appliedValid||t.updateAppliedTransform();const o=t.parent.matrix,l=1/(o.a*o.d-o.b*o.c),h=e-o.tx,c=n-o.ty,d=(h*o.d-c*o.c)*l-t.ax,u=(c*o.a-h*o.b)*l-t.ay;let m=Math.atan2(u,d)*q.radDeg-t.ashearX-t.arotation;t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let f=t.ascaleX,g=t.ascaleY;if(s||a){const e=t.data.length*f,n=Math.sqrt(d*d+u*u);if(s&&n<e||a&&n>e&&e>1e-4){const t=(n/e-1)*i+1;f*=t,r&&(g*=t)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*i,f,g,t.ashearX,t.ashearY)}apply2(t,e,n,s,a,r,i){if(0==i)return void e.updateWorldTransform();t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();const o=t.ax,l=t.ay;let h=t.ascaleX,c=h,d=t.ascaleY,u=e.ascaleX;const m=t.matrix;let f=0,g=0,p=0;h<0?(h=-h,f=180,p=-1):(f=0,p=1),d<0&&(d=-d,p=-p),u<0?(u=-u,g=180):g=0;const x=e.ax;let w=0,b=0,E=0,y=m.a,S=m.c,M=m.b,A=m.d;const I=Math.abs(h-d)<=1e-4;I?(w=e.ay,b=y*x+S*w+m.tx,E=M*x+A*w+m.ty):(w=0,b=y*x+m.tx,E=M*x+m.ty);const T=t.parent.matrix;y=T.a,S=T.c,M=T.b,A=T.d;const k=1/(y*A-S*M);let R=n-T.tx,C=s-T.ty;const V=(R*A-C*S)*k-o,v=(C*y-R*M)*k-l,P=V*V+v*v;R=b-T.tx,C=E-T.ty;const F=(R*A-C*S)*k-o,Y=(C*y-R*M)*k-l,N=Math.sqrt(F*F+Y*Y);let X=e.data.length*u,D=0,B=0;t:if(I){X*=h;let t=(P-N*N-X*X)/(2*N*X);t<-1?t=-1:t>1&&(t=1,r&&N+X>1e-4&&(c*=(Math.sqrt(P)/(N+X)-1)*i+1)),B=Math.acos(t)*a,y=N+X*t,S=X*Math.sin(B),D=Math.atan2(v*y-V*S,V*y+v*S)}else{y=h*X,S=d*X;const t=y*y,e=S*S,n=Math.atan2(v,V);M=e*N*N+t*P-t*e;const s=-2*e*N,r=e-t;if(A=s*s-4*r*M,A>=0){let t=Math.sqrt(A);s<0&&(t=-t),t=-(s+t)/2;const e=t/r,i=M/t,o=Math.abs(e)<Math.abs(i)?e:i;if(o*o<=P){C=Math.sqrt(P-o*o)*a,D=n-Math.atan2(C,o),B=Math.atan2(C/d,(o-N)/h);break t}}let i=q.PI,o=N-y,l=o*o,c=0,u=0,m=N+y,f=m*m,g=0;M=-y*N/(t-e),M>=-1&&M<=1&&(M=Math.acos(M),R=y*Math.cos(M)+N,C=S*Math.sin(M),A=R*R+C*C,A<l&&(i=M,l=A,o=R,c=C),A>f&&(u=M,f=A,m=R,g=C)),P<=(l+f)/2?(D=n-Math.atan2(c*a,o),B=i*a):(D=n-Math.atan2(g*a,m),B=u*a)}const L=Math.atan2(w,x)*p;let _=t.arotation;D=(D-L)*q.radDeg+f-_,D>180?D-=360:D<-180&&(D+=360),t.updateWorldTransformWith(o,l,_+D*i,c,t.ascaleY,0,0),_=e.arotation,B=((B+L)*q.radDeg-e.ashearX)*p+g-_,B>180?B-=360:B<-180&&(B+=360),e.updateWorldTransformWith(x,w,_+B*i,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}},Yn=class{constructor(t){this.order=0,this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.name=t}},Nn=class{constructor(t){this.order=0,this.bones=new Array,this.name=t}};var Xn=(t=>(t[t.Length=0]="Length",t[t.Fixed=1]="Fixed",t[t.Percent=2]="Percent",t))(Xn||{});const Dn=class{constructor(t,e){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,s=t.bones.length;n<s;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}apply(){this.update()}update(){const t=this.target.getAttachment();if(!(t instanceof De))return;const e=this.rotateMix,n=this.translateMix,s=e>0;if(!(n>0)&&!s)return;const a=this.data,r=a.spacingMode,i=r==Xn.Length,o=a.rotateMode,l=o==k.Tangent,h=o==k.ChainScale,c=this.bones.length,d=l?c:c+1,u=this.bones,m=j.setArraySize(this.spaces,d);let f=null;const g=this.spacing;if(h||i){h&&(f=j.setArraySize(this.lengths,c));for(let t=0,e=d-1;t<e;){const e=u[t],n=e.data.length;if(n<Dn.epsilon)h&&(f[t]=0),m[++t]=0;else{const s=n*e.matrix.a,a=n*e.matrix.b,r=Math.sqrt(s*s+a*a);h&&(f[t]=r),m[++t]=(i?n+g:g)*r/n}}}else for(let y=1;y<d;y++)m[y]=g;const p=this.computeWorldPositions(t,d,l,a.positionMode==T.Percent,r==Xn.Percent);let x=p[0],w=p[1],b=a.offsetRotation,E=!1;if(0==b)E=o==k.Chain;else{E=!1;const t=this.target.bone.matrix;b*=t.a*t.d-t.b*t.c>0?q.degRad:-q.degRad}for(let y=0,S=3;y<c;y++,S+=3){const t=u[y],a=t.matrix;a.tx+=(x-a.tx)*n,a.ty+=(w-a.ty)*n;const r=p[S],i=p[S+1],o=r-x,c=i-w;if(h){const t=f[y];if(0!=t){const n=(Math.sqrt(o*o+c*c)/t-1)*e+1;a.a*=n,a.b*=n}}if(x=r,w=i,s){const n=a.a,s=a.c,r=a.b,i=a.d;let h=0,d=0,u=0;if(l&&(h=l?p[S-1]:0==m[y+1]?p[S+2]:Math.atan2(c,o)),h-=Math.atan2(r,n),E){d=Math.cos(h),u=Math.sin(h);const s=t.data.length;x+=(s*(d*n-u*r)-o)*e,w+=(s*(u*n+d*r)-c)*e}else h+=b;h>q.PI?h-=q.PI2:h<-q.PI&&(h+=q.PI2),h*=e,d=Math.cos(h),u=Math.sin(h),a.a=d*n-u*r,a.c=d*s-u*i,a.b=u*n+d*r,a.d=u*s+d*i}t.appliedValid=!1}}computeWorldPositions(t,e,n,s,a){const r=this.target;let i=this.position;const o=this.spaces,l=j.setArraySize(this.positions,3*e+2);let h=null;const c=t.closed;let d=t.worldVerticesLength,u=d/6,m=Dn.NONE;if(!t.constantSpeed){const f=t.lengths;u-=c?1:2;const g=f[u];if(s&&(i*=g),a)for(let t=0;t<e;t++)o[t]*=g;h=j.setArraySize(this.world,8);for(let s=0,a=0,p=0;s<e;s++,a+=3){const e=o[s];i+=e;let x=i;if(c)x%=g,x<0&&(x+=g),p=0;else{if(x<0){m!=Dn.BEFORE&&(m=Dn.BEFORE,t.computeWorldVertices(r,2,4,h,0,2)),this.addBeforePosition(x,h,0,l,a);continue}if(x>g){m!=Dn.AFTER&&(m=Dn.AFTER,t.computeWorldVertices(r,d-6,4,h,0,2)),this.addAfterPosition(x-g,h,0,l,a);continue}}for(;;p++){const t=f[p];if(!(x>t)){if(0==p)x/=t;else{const e=f[p-1];x=(x-e)/(t-e)}break}}p!=m&&(m=p,c&&p==u?(t.computeWorldVertices(r,d-4,4,h,0,2),t.computeWorldVertices(r,0,4,h,4,2)):t.computeWorldVertices(r,6*p+2,8,h,0,2)),this.addCurvePosition(x,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],l,a,n||s>0&&0==e)}return l}c?(d+=2,h=j.setArraySize(this.world,d),t.computeWorldVertices(r,2,d-4,h,0,2),t.computeWorldVertices(r,0,2,h,d-4,2),h[d-2]=h[0],h[d-1]=h[1]):(u--,d-=4,h=j.setArraySize(this.world,d),t.computeWorldVertices(r,2,d,h,0,2));const f=j.setArraySize(this.curves,u);let g=0,p=h[0],x=h[1],w=0,b=0,E=0,y=0,S=0,M=0,A=0,I=0,T=0,k=0,R=0,C=0,V=0,v=0;for(let Y=0,N=2;Y<u;Y++,N+=6)w=h[N],b=h[N+1],E=h[N+2],y=h[N+3],S=h[N+4],M=h[N+5],A=.1875*(p-2*w+E),I=.1875*(x-2*b+y),T=.09375*(3*(w-E)-p+S),k=.09375*(3*(b-y)-x+M),R=2*A+T,C=2*I+k,V=.75*(w-p)+A+.16666667*T,v=.75*(b-x)+I+.16666667*k,g+=Math.sqrt(V*V+v*v),V+=R,v+=C,R+=T,C+=k,g+=Math.sqrt(V*V+v*v),V+=R,v+=C,g+=Math.sqrt(V*V+v*v),V+=R+T,v+=C+k,g+=Math.sqrt(V*V+v*v),f[Y]=g,p=S,x=M;if(s&&(i*=g),a)for(let Y=0;Y<e;Y++)o[Y]*=g;const P=this.segments;let F=0;for(let Y=0,N=0,X=0,D=0;Y<e;Y++,N+=3){const t=o[Y];i+=t;let e=i;if(c)e%=g,e<0&&(e+=g),X=0;else{if(e<0){this.addBeforePosition(e,h,0,l,N);continue}if(e>g){this.addAfterPosition(e-g,h,d-4,l,N);continue}}for(;;X++){const t=f[X];if(!(e>t)){if(0==X)e/=t;else{const n=f[X-1];e=(e-n)/(t-n)}break}}if(X!=m){m=X;let t=6*X;for(p=h[t],x=h[t+1],w=h[t+2],b=h[t+3],E=h[t+4],y=h[t+5],S=h[t+6],M=h[t+7],A=.03*(p-2*w+E),I=.03*(x-2*b+y),T=.006*(3*(w-E)-p+S),k=.006*(3*(b-y)-x+M),R=2*A+T,C=2*I+k,V=.3*(w-p)+A+.16666667*T,v=.3*(b-x)+I+.16666667*k,F=Math.sqrt(V*V+v*v),P[0]=F,t=1;t<8;t++)V+=R,v+=C,R+=T,C+=k,F+=Math.sqrt(V*V+v*v),P[t]=F;V+=R,v+=C,F+=Math.sqrt(V*V+v*v),P[8]=F,V+=R+T,v+=C+k,F+=Math.sqrt(V*V+v*v),P[9]=F,D=0}for(e*=F;;D++){const t=P[D];if(!(e>t)){if(0==D)e/=t;else{const n=P[D-1];e=D+(e-n)/(t-n)}break}}this.addCurvePosition(.1*e,p,x,w,b,E,y,S,M,l,N,n||Y>0&&0==t)}return l}addBeforePosition(t,e,n,s,a){const r=e[n],i=e[n+1],o=e[n+2]-r,l=e[n+3]-i,h=Math.atan2(l,o);s[a]=r+t*Math.cos(h),s[a+1]=i+t*Math.sin(h),s[a+2]=h}addAfterPosition(t,e,n,s,a){const r=e[n+2],i=e[n+3],o=r-e[n],l=i-e[n+1],h=Math.atan2(l,o);s[a]=r+t*Math.cos(h),s[a+1]=i+t*Math.sin(h),s[a+2]=h}addCurvePosition(t,e,n,s,a,r,i,o,l,h,c,d){(0==t||isNaN(t))&&(t=1e-4);const u=t*t,m=u*t,f=1-t,g=f*f,p=g*f,x=f*t,w=3*x,b=f*w,E=w*t,y=e*p+s*b+r*E+o*m,S=n*p+a*b+i*E+l*m;h[c]=y,h[c+1]=S,d&&(h[c+2]=Math.atan2(S-(n*g+a*x*2+i*u),y-(e*g+s*x*2+r*u)))}getOrder(){return this.data.order}};let Bn=Dn;Bn.NONE=-1,Bn.BEFORE=-2,Bn.AFTER=-3,Bn.epsilon=1e-5;let Ln=class{constructor(t,e){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new Z,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target,r=a.matrix,i=r.a,o=r.c,l=r.b,h=r.d,c=i*h-o*l>0?q.degRad:-q.degRad,d=this.data.offsetRotation*c,u=this.data.offsetShearY*c,m=this.bones;for(let f=0,g=m.length;f<g;f++){const r=m[f];let c=!1;const g=r.matrix;if(0!=t){const e=g.a,n=g.c,s=g.b,a=g.d;let r=Math.atan2(l,i)-Math.atan2(s,e)+d;r>q.PI?r-=q.PI2:r<-q.PI&&(r+=q.PI2),r*=t;const o=Math.cos(r),h=Math.sin(r);g.a=o*e-h*s,g.c=o*n-h*a,g.b=h*e+o*s,g.d=h*n+o*a,c=!0}if(0!=e){const t=this.temp;a.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),g.tx+=(t.x-g.tx)*e,g.ty+=(t.y-g.ty)*e,c=!0}if(n>0){let t=Math.sqrt(g.a*g.a+g.b*g.b),e=Math.sqrt(i*i+l*l);t>1e-5&&(t=(t+(e-t+this.data.offsetScaleX)*n)/t),g.a*=t,g.b*=t,t=Math.sqrt(g.c*g.c+g.d*g.d),e=Math.sqrt(o*o+h*h),t>1e-5&&(t=(t+(e-t+this.data.offsetScaleY)*n)/t),g.c*=t,g.d*=t,c=!0}if(s>0){const t=g.c,e=g.d,n=Math.atan2(e,t);let a=Math.atan2(h,o)-Math.atan2(l,i)-(n-Math.atan2(g.b,g.a));a>q.PI?a-=q.PI2:a<-q.PI&&(a+=q.PI2),a=n+(a+u)*s;const r=Math.sqrt(t*t+e*e);g.c=Math.cos(a)*r,g.d=Math.sin(a)*r,c=!0}c&&(r.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target,r=a.matrix,i=r.a,o=r.c,l=r.b,h=r.d,c=i*h-o*l>0?q.degRad:-q.degRad,d=this.data.offsetRotation*c,u=this.data.offsetShearY*c,m=this.bones;for(let f=0,g=m.length;f<g;f++){const r=m[f];let c=!1;const g=r.matrix;if(0!=t){const e=g.a,n=g.c,s=g.b,a=g.d;let r=Math.atan2(l,i)+d;r>q.PI?r-=q.PI2:r<-q.PI&&(r+=q.PI2),r*=t;const o=Math.cos(r),h=Math.sin(r);g.a=o*e-h*s,g.c=o*n-h*a,g.b=h*e+o*s,g.d=h*n+o*a,c=!0}if(0!=e){const t=this.temp;a.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),g.tx+=t.x*e,g.ty+=t.y*e,c=!0}if(n>0){let t=(Math.sqrt(i*i+l*l)-1+this.data.offsetScaleX)*n+1;g.a*=t,g.b*=t,t=(Math.sqrt(o*o+h*h)-1+this.data.offsetScaleY)*n+1,g.c*=t,g.d*=t,c=!0}if(s>0){let t=Math.atan2(h,o)-Math.atan2(l,i);t>q.PI?t-=q.PI2:t<-q.PI&&(t+=q.PI2);const e=g.c,n=g.d;t=Math.atan2(n,e)+(t-q.PI/2+u)*s;const a=Math.sqrt(e*e+n*n);g.c=Math.cos(t)*a,g.d=Math.sin(t)*a,c=!0}c&&(r.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target;a.appliedValid||a.updateAppliedTransform();const r=this.bones;for(let i=0,o=r.length;i<o;i++){const o=r[i];o.appliedValid||o.updateAppliedTransform();let l=o.arotation;if(0!=t){let e=a.arotation-l+this.data.offsetRotation;e-=360*(16384-(16384.499999999996-e/360|0)),l+=e*t}let h=o.ax,c=o.ay;0!=e&&(h+=(a.ax-h+this.data.offsetX)*e,c+=(a.ay-c+this.data.offsetY)*e);let d=o.ascaleX,u=o.ascaleY;n>0&&(d>1e-5&&(d=(d+(a.ascaleX-d+this.data.offsetScaleX)*n)/d),u>1e-5&&(u=(u+(a.ascaleY-u+this.data.offsetScaleY)*n)/u));const m=o.ashearY;if(s>0){let t=a.ashearY-m+this.data.offsetShearY;t-=360*(16384-(16384.499999999996-t/360|0)),o.shearY+=t*s}o.updateWorldTransformWith(h,c,l,d,u,o.ashearX,m)}}applyRelativeLocal(){const t=this.rotateMix,e=this.translateMix,n=this.scaleMix,s=this.shearMix,a=this.target;a.appliedValid||a.updateAppliedTransform();const r=this.bones;for(let i=0,o=r.length;i<o;i++){const o=r[i];o.appliedValid||o.updateAppliedTransform();let l=o.arotation;0!=t&&(l+=(a.arotation+this.data.offsetRotation)*t);let h=o.ax,c=o.ay;0!=e&&(h+=(a.ax+this.data.offsetX)*e,c+=(a.ay+this.data.offsetY)*e);let d=o.ascaleX,u=o.ascaleY;n>0&&(d>1e-5&&(d*=(a.ascaleX-1+this.data.offsetScaleX)*n+1),u>1e-5&&(u*=(a.ascaleY-1+this.data.offsetScaleY)*n+1));let m=o.ashearY;s>0&&(m+=(a.ashearY+this.data.offsetShearY)*s),o.updateWorldTransformWith(h,c,l,d,u,o.ashearX,m)}}getOrder(){return this.data.order}};const _n=class{constructor(t){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,null==t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const n=t.bones[e];let s;if(null==n.parent)s=new Cn(n,this,null);else{const t=this.bones[n.parent.index];s=new Cn(n,this,t),t.children.push(s)}this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const n=t.slots[e],s=this.bones[n.boneData.index],a=new Le(n,s);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const n=t.ikConstraints[e];this.ikConstraints.push(new Fn(n,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const n=t.transformConstraints[e];this.transformConstraints.push(new Ln(n,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const n=t.pathConstraints[e];this.pathConstraints.push(new Bn(n,this))}this.color=new O(1,1,1,1),this.updateCache()}updateCache(){this._updateCache.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let l=0,h=t.length;l<h;l++)t[l].sorted=!1;const e=this.ikConstraints,n=this.transformConstraints,s=this.pathConstraints,a=e.length,r=n.length,i=s.length,o=a+r+i;t:for(let l=0;l<o;l++){for(let t=0;t<a;t++){const n=e[t];if(n.data.order==l){this.sortIkConstraint(n);continue t}}for(let t=0;t<r;t++){const e=n[t];if(e.data.order==l){this.sortTransformConstraint(e);continue t}}for(let t=0;t<i;t++){const e=s[t];if(e.data.order==l){this.sortPathConstraint(e);continue t}}}for(let l=0,h=t.length;l<h;l++)this.sortBone(t[l])}sortIkConstraint(t){const e=t.target;this.sortBone(e);const n=t.bones,s=n[0];if(this.sortBone(s),n.length>1){const t=n[n.length-1];this._updateCache.indexOf(t)>-1||this.updateCacheReset.push(t)}this._updateCache.push(t),this.sortReset(s.children),n[n.length-1].sorted=!0}sortPathConstraint(t){const e=t.target,n=e.data.index,s=e.bone;null!=this.skin&&this.sortPathConstraintAttachment(this.skin,n,s),null!=this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,s);for(let o=0,l=this.data.skins.length;o<l;o++)this.sortPathConstraintAttachment(this.data.skins[o],n,s);const a=e.getAttachment();a instanceof De&&this.sortPathConstraintAttachmentWith(a,s);const r=t.bones,i=r.length;for(let o=0;o<i;o++)this.sortBone(r[o]);this._updateCache.push(t);for(let o=0;o<i;o++)this.sortReset(r[o].children);for(let o=0;o<i;o++)r[o].sorted=!0}sortTransformConstraint(t){this.sortBone(t.target);const e=t.bones,n=e.length;if(t.data.local)for(let s=0;s<n;s++){const t=e[s];this.sortBone(t.parent),this._updateCache.indexOf(t)>-1||this.updateCacheReset.push(t)}else for(let s=0;s<n;s++)this.sortBone(e[s]);this._updateCache.push(t);for(let s=0;s<n;s++)this.sortReset(e[s].children);for(let s=0;s<n;s++)e[s].sorted=!0}sortPathConstraintAttachment(t,e,n){const s=t.attachments[e];if(s)for(const a in s)this.sortPathConstraintAttachmentWith(s[a],n)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof De))return;const n=t.bones;if(null==n)this.sortBone(e);else{const t=this.bones;let e=0;for(;e<n.length;){const s=n[e++];for(let a=e+s;e<a;e++){const s=n[e];this.sortBone(t[s])}}}}sortBone(t){if(t.sorted)return;const e=t.parent;null!=e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,n=t.length;e<n;e++){const n=t[e];n.sorted&&this.sortReset(n.children),n.sorted=!1}}updateWorldTransform(){const t=this.updateCacheReset;for(let n=0,s=t.length;n<s;n++){const e=t[n];e.ax=e.x,e.ay=e.y,e.arotation=e.rotation,e.ascaleX=e.scaleX,e.ascaleY=e.scaleY,e.ashearX=e.shearX,e.ashearY=e.shearY,e.appliedValid=!0}const e=this._updateCache;for(let n=0,s=e.length;n<s;n++)e[n].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let a=0,r=t.length;a<r;a++)t[a].setToSetupPose();const e=this.ikConstraints;for(let a=0,r=e.length;a<r;a++){const t=e[a];t.bendDirection=t.data.bendDirection,t.mix=t.data.mix}const n=this.transformConstraints;for(let a=0,r=n.length;a<r;a++){const t=n[a],e=t.data;t.rotateMix=e.rotateMix,t.translateMix=e.translateMix,t.scaleMix=e.scaleMix,t.shearMix=e.shearMix}const s=this.pathConstraints;for(let a=0,r=s.length;a<r;a++){const t=s[a],e=t.data;t.position=e.position,t.spacing=e.spacing,t.rotateMix=e.rotateMix,t.translateMix=e.translateMix}}setSlotsToSetupPose(){const t=this.slots;j.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,n=t.length;e<n;e++)t[e].setToSetupPose()}getRootBone(){return 0==this.bones.length?null:this.bones[0]}findBone(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findBoneIndex(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++)if(e[n].data.name==t)return n;return-1}findSlot(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findSlotIndex(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++)if(e[n].data.name==t)return n;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(null==e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(null!=t)if(null!=this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n],a=s.data.attachmentName;if(null!=a){const e=t.getAttachment(n,a);null!=e&&s.setAttachment(e)}}}this.skin=t}getAttachmentByName(t,e){return this.getAttachment(this.data.findSlotIndex(t),e)}getAttachment(t,e){if(null==e)throw new Error("attachmentName cannot be null.");if(null!=this.skin){const n=this.skin.getAttachment(t,e);if(null!=n)return n}return null!=this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(null==t)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++){const a=n[s];if(a.data.name==t){let n=null;if(null!=e&&(n=this.getAttachment(s,e),null==n))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);return void a.setAttachment(n)}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findTransformConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findPathConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}getBounds(t,e,n){if(null==t)throw new Error("offset cannot be null.");if(null==e)throw new Error("size cannot be null.");const s=this.drawOrder;let a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let l=0,h=s.length;l<h;l++){const t=s[l];let e=0,h=null;const c=t.getAttachment();if(c instanceof Oe)e=8,h=j.setArraySize(n,e,0),c.computeWorldVertices(t.bone,h,0,2);else if(c instanceof Xe){const s=c;e=s.worldVerticesLength,h=j.setArraySize(n,e,0),s.computeWorldVertices(t,0,e,h,0,2)}if(null!=h)for(let n=0,s=h.length;n<s;n+=2){const t=h[n],e=h[n+1];a=Math.min(a,t),r=Math.min(r,e),i=Math.max(i,t),o=Math.max(o,e)}}t.set(a,r),e.set(i-a,o-r)}update(t){this.time+=t}get flipX(){return-1==this.scaleX}set flipX(t){_n.deprecatedWarning1||(_n.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return-1==this.scaleY}set flipY(t){_n.deprecatedWarning1||(_n.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};let On=_n;On.deprecatedWarning1=!1;let Wn=class{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findBoneIndex(t){if(null==t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}findSlot(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findSlotIndex(t){if(null==t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}findSkin(t){if(null==t)throw new Error("skinName cannot be null.");const e=this.skins;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findEvent(t){if(null==t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findAnimation(t){if(null==t)throw new Error("animationName cannot be null.");const e=this.animations;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findIkConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findTransformConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findPathConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findPathConstraintIndex(t){if(null==t)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}},qn=class{constructor(t,e,n){if(this.color=new O(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(null==e)throw new Error("name cannot be null.");if(null==n)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=n}},$n=class{constructor(t){if(this.order=0,this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1,null==t)throw new Error("name cannot be null.");this.name=t}},Un=class{constructor(t){if(this.attachments=new Array,null==t)throw new Error("name cannot be null.");this.name=t}addAttachment(t,e,n){if(null==n)throw new Error("attachment cannot be null.");const s=this.attachments;t>=s.length&&(s.length=t+1),s[t]||(s[t]={}),s[t][e]=n}getAttachment(t,e){const n=this.attachments[t];return n?n[e]:null}attachAll(t,e){let n=0;for(let s=0;s<t.slots.length;s++){const a=t.slots[s],r=a.getAttachment();if(r&&n<e.attachments.length){const t=e.attachments[n];for(const e in t){if(r==t[e]){const t=this.getAttachment(n,e);null!=t&&a.setAttachment(t);break}}}n++}}},zn=class t{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(e){const n=this.scale,s=new Wn,a="string"==typeof e?JSON.parse(e):e,r=a.skeleton;if(null!=r&&(s.hash=r.hash,s.version=r.spine,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images),a.bones)for(let i=0;i<a.bones.length;i++){const e=a.bones[i];let r=null;const o=this.getValue(e,"parent",null);if(null!=o&&(r=s.findBone(o),null==r))throw new Error(`Parent bone not found: ${o}`);const l=new Vn(s.bones.length,e.name,r);l.length=this.getValue(e,"length",0)*n,l.x=this.getValue(e,"x",0)*n,l.y=this.getValue(e,"y",0)*n,l.rotation=this.getValue(e,"rotation",0),l.scaleX=this.getValue(e,"scaleX",1),l.scaleY=this.getValue(e,"scaleY",1),l.shearX=this.getValue(e,"shearX",0),l.shearY=this.getValue(e,"shearY",0),l.transformMode=t.transformModeFromString(this.getValue(e,"transform","normal")),s.bones.push(l)}if(a.slots)for(let i=0;i<a.slots.length;i++){const e=a.slots[i],n=e.name,r=e.bone,o=s.findBone(r);if(null==o)throw new Error(`Slot bone not found: ${r}`);const l=new qn(s.slots.length,n,o),h=this.getValue(e,"color",null);null!=h&&l.color.setFromString(h);const c=this.getValue(e,"dark",null);null!=c&&(l.darkColor=new O(1,1,1,1),l.darkColor.setFromString(c)),l.attachmentName=this.getValue(e,"attachment",null),l.blendMode=t.blendModeFromString(this.getValue(e,"blend","normal")),s.slots.push(l)}if(a.ik)for(let t=0;t<a.ik.length;t++){const e=a.ik[t],n=new Yn(e.name);n.order=this.getValue(e,"order",0);for(let t=0;t<e.bones.length;t++){const a=e.bones[t],r=s.findBone(a);if(null==r)throw new Error(`IK bone not found: ${a}`);n.bones.push(r)}const r=e.target;if(n.target=s.findBone(r),null==n.target)throw new Error(`IK target bone not found: ${r}`);n.bendDirection=this.getValue(e,"bendPositive",!0)?1:-1,n.mix=this.getValue(e,"mix",1),s.ikConstraints.push(n)}if(a.transform)for(let t=0;t<a.transform.length;t++){const e=a.transform[t],r=new $n(e.name);r.order=this.getValue(e,"order",0);for(let t=0;t<e.bones.length;t++){const n=e.bones[t],a=s.findBone(n);if(null==a)throw new Error(`Transform constraint bone not found: ${n}`);r.bones.push(a)}const i=e.target;if(r.target=s.findBone(i),null==r.target)throw new Error(`Transform constraint target bone not found: ${i}`);r.local=this.getValue(e,"local",!1),r.relative=this.getValue(e,"relative",!1),r.offsetRotation=this.getValue(e,"rotation",0),r.offsetX=this.getValue(e,"x",0)*n,r.offsetY=this.getValue(e,"y",0)*n,r.offsetScaleX=this.getValue(e,"scaleX",0),r.offsetScaleY=this.getValue(e,"scaleY",0),r.offsetShearY=this.getValue(e,"shearY",0),r.rotateMix=this.getValue(e,"rotateMix",1),r.translateMix=this.getValue(e,"translateMix",1),r.scaleMix=this.getValue(e,"scaleMix",1),r.shearMix=this.getValue(e,"shearMix",1),s.transformConstraints.push(r)}if(a.path)for(let i=0;i<a.path.length;i++){const e=a.path[i],r=new Nn(e.name);r.order=this.getValue(e,"order",0);for(let t=0;t<e.bones.length;t++){const n=e.bones[t],a=s.findBone(n);if(null==a)throw new Error(`Transform constraint bone not found: ${n}`);r.bones.push(a)}const o=e.target;if(r.target=s.findSlot(o),null==r.target)throw new Error(`Path target slot not found: ${o}`);r.positionMode=t.positionModeFromString(this.getValue(e,"positionMode","percent")),r.spacingMode=t.spacingModeFromString(this.getValue(e,"spacingMode","length")),r.rotateMode=t.rotateModeFromString(this.getValue(e,"rotateMode","tangent")),r.offsetRotation=this.getValue(e,"rotation",0),r.position=this.getValue(e,"position",0),r.positionMode==T.Fixed&&(r.position*=n),r.spacing=this.getValue(e,"spacing",0),r.spacingMode!=Xn.Length&&r.spacingMode!=Xn.Fixed||(r.spacing*=n),r.rotateMix=this.getValue(e,"rotateMix",1),r.translateMix=this.getValue(e,"translateMix",1),s.pathConstraints.push(r)}if(a.skins)for(const t in a.skins){const e=a.skins[t],n=new Un(t);for(const t in e){const a=s.findSlotIndex(t);if(-1==a)throw new Error(`Slot not found: ${t}`);const r=e[t];for(const t in r){const e=this.readAttachment(r[t],n,a,t,s);null!=e&&n.addAttachment(a,t,e)}}s.skins.push(n),"default"==n.name&&(s.defaultSkin=n)}for(let t=0,i=this.linkedMeshes.length;t<i;t++){const e=this.linkedMeshes[t],n=null==e.skin?s.defaultSkin:s.findSkin(e.skin);if(null==n)throw new Error(`Skin not found: ${e.skin}`);const a=n.getAttachment(e.slotIndex,e.parent);if(null==a)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.setParentMesh(a)}if(this.linkedMeshes.length=0,a.events)for(const t in a.events){const e=a.events[t],n=new Pn(t);n.intValue=this.getValue(e,"int",0),n.floatValue=this.getValue(e,"float",0),n.stringValue=this.getValue(e,"string",""),n.audioPath=this.getValue(e,"audio",null),null!=n.audioPath&&(n.volume=this.getValue(e,"volume",1),n.balance=this.getValue(e,"balance",0)),s.events.push(n)}if(a.animations)for(const t in a.animations){const e=a.animations[t];this.readAnimation(e,t,s)}return s}readAttachment(t,e,n,s,a){const r=this.scale;s=this.getValue(t,"name",s);switch(this.getValue(t,"type","region")){case"region":{const n=this.getValue(t,"path",s),a=this.attachmentLoader.newRegionAttachment(e,s,n);if(null==a)return null;a.path=n,a.x=this.getValue(t,"x",0)*r,a.y=this.getValue(t,"y",0)*r,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*r,a.height=t.height*r;const i=this.getValue(t,"color",null);return null!=i&&a.color.setFromString(i),a}case"boundingbox":{const n=this.attachmentLoader.newBoundingBoxAttachment(e,s);if(null==n)return null;this.readVertices(t,n,t.vertexCount<<1);const a=this.getValue(t,"color",null);return null!=a&&n.color.setFromString(a),n}case"mesh":case"linkedmesh":{const a=this.getValue(t,"path",s),r=this.attachmentLoader.newMeshAttachment(e,s,a);if(null==r)return null;r.path=a;const i=this.getValue(t,"color",null);null!=i&&r.color.setFromString(i);const o=this.getValue(t,"parent",null);if(null!=o)return r.inheritDeform=this.getValue(t,"deform",!0),this.linkedMeshes.push(new Hn(r,this.getValue(t,"skin",null),n,o)),r;const l=t.uvs;return this.readVertices(t,r,l.length),r.triangles=t.triangles,r.regionUVs=new Float32Array(l),r.hullLength=2*this.getValue(t,"hull",0),r}case"path":{const n=this.attachmentLoader.newPathAttachment(e,s);if(null==n)return null;n.closed=this.getValue(t,"closed",!1),n.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,n,a<<1);const i=j.newArray(a/3,0);for(let e=0;e<t.lengths.length;e++)i[e]=t.lengths[e]*r;n.lengths=i;const o=this.getValue(t,"color",null);return null!=o&&n.color.setFromString(o),n}case"point":{const n=this.attachmentLoader.newPointAttachment(e,s);if(null==n)return null;n.x=this.getValue(t,"x",0)*r,n.y=this.getValue(t,"y",0)*r,n.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return null!=a&&n.color.setFromString(a),n}case"clipping":{const n=this.attachmentLoader.newClippingAttachment(e,s);if(null==n)return null;const r=this.getValue(t,"end",null);if(null!=r){const t=a.findSlot(r);if(null==t)throw new Error(`Clipping end slot not found: ${r}`);n.endSlot=t}const i=t.vertexCount;this.readVertices(t,n,i<<1);const o=this.getValue(t,"color",null);return null!=o&&n.color.setFromString(o),n}}return null}readVertices(t,e,n){const s=this.scale;e.worldVerticesLength=n;const a=t.vertices;if(n==a.length){const t=j.toFloatArray(a);if(1!=s)for(let e=0,n=a.length;e<n;e++)t[e]*=s;return void(e.vertices=t)}const r=new Array,i=new Array;for(let o=0,l=a.length;o<l;){const t=a[o++];i.push(t);for(let e=o+4*t;o<e;o+=4)i.push(a[o]),r.push(a[o+1]*s),r.push(a[o+2]*s),r.push(a[o+3])}e.bones=i,e.vertices=j.toFloatArray(r)}readAnimation(t,e,n){const s=this.scale,a=new Array;let r=0;if(t.slots)for(const o in t.slots){const e=t.slots[o],s=n.findSlotIndex(o);if(-1==s)throw new Error(`Slot not found: ${o}`);for(const t in e){const n=e[t];if("attachment"==t){const t=new an(n.length);t.slotIndex=s;let e=0;for(let s=0;s<n.length;s++){const a=n[s];t.setFrame(e++,a.time,a.name)}a.push(t),r=Math.max(r,t.frames[t.getFrameCount()-1])}else if("color"==t){const t=new en(n.length);t.slotIndex=s;let e=0;for(let s=0;s<n.length;s++){const a=n[s],r=new O;r.setFromString(a.color||"ffffffff"),t.setFrame(e,a.time,r.r,r.g,r.b,r.a),this.readCurve(a,t,e),e++}a.push(t),r=Math.max(r,t.frames[(t.getFrameCount()-1)*en.ENTRIES])}else{if("twoColor"!=t)throw new Error(`Invalid timeline type for a slot: ${t} (${o})`);{const t=new sn(n.length);t.slotIndex=s;let e=0;for(let s=0;s<n.length;s++){const a=n[s],r=new O,i=new O;r.setFromString(a.light),i.setFromString(a.dark),t.setFrame(e,a.time,r.r,r.g,r.b,r.a,i.r,i.g,i.b),this.readCurve(a,t,e),e++}a.push(t),r=Math.max(r,t.frames[(t.getFrameCount()-1)*sn.ENTRIES])}}}}if(t.bones)for(const o in t.bones){const e=t.bones[o],i=n.findBoneIndex(o);if(-1==i)throw new Error(`Bone not found: ${o}`);for(const t in e){const n=e[t];if("rotate"===t){const t=new Ge(n.length);t.boneIndex=i;let e=0;for(let s=0;s<n.length;s++){const a=n[s];t.setFrame(e,a.time,a.angle),this.readCurve(a,t,e),e++}a.push(t),r=Math.max(r,t.frames[(t.getFrameCount()-1)*Ge.ENTRIES])}else{if("translate"!==t&&"scale"!==t&&"shear"!==t)throw new Error(`Invalid timeline type for a bone: ${t} (${o})`);{let e=null,o=1;"scale"===t?e=new Ke(n.length):"shear"===t?e=new Je(n.length):(e=new Qe(n.length),o=s),e.boneIndex=i;let l=0;for(let t=0;t<n.length;t++){const s=n[t],a=this.getValue(s,"x",0),r=this.getValue(s,"y",0);e.setFrame(l,s.time,a*o,r*o),this.readCurve(s,e,l),l++}a.push(e),r=Math.max(r,e.frames[(e.getFrameCount()-1)*Qe.ENTRIES])}}}}if(t.ik)for(const o in t.ik){const e=t.ik[o],s=n.findIkConstraint(o),i=new dn(e.length);i.ikConstraintIndex=n.ikConstraints.indexOf(s);let l=0;for(let t=0;t<e.length;t++){const n=e[t];i.setFrame(l,n.time,this.getValue(n,"mix",1),this.getValue(n,"bendPositive",!0)?1:-1,this.getValue(n,"compress",!1),this.getValue(n,"stretch",!1)),this.readCurve(n,i,l),l++}a.push(i),r=Math.max(r,i.frames[(i.getFrameCount()-1)*dn.ENTRIES])}if(t.transform)for(const o in t.transform){const e=t.transform[o],s=n.findTransformConstraint(o),i=new mn(e.length);i.transformConstraintIndex=n.transformConstraints.indexOf(s);let l=0;for(let t=0;t<e.length;t++){const n=e[t];i.setFrame(l,n.time,this.getValue(n,"rotateMix",1),this.getValue(n,"translateMix",1),this.getValue(n,"scaleMix",1),this.getValue(n,"shearMix",1)),this.readCurve(n,i,l),l++}a.push(i),r=Math.max(r,i.frames[(i.getFrameCount()-1)*mn.ENTRIES])}if(t.paths)for(const o in t.paths){const e=t.paths[o],i=n.findPathConstraintIndex(o);if(-1==i)throw new Error(`Path constraint not found: ${o}`);const l=n.pathConstraints[i];for(const t in e){const n=e[t];if("position"===t||"spacing"===t){let e=null,o=1;"spacing"===t?(e=new pn(n.length),l.spacingMode!=Xn.Length&&l.spacingMode!=Xn.Fixed||(o=s)):(e=new gn(n.length),l.positionMode==T.Fixed&&(o=s)),e.pathConstraintIndex=i;let h=0;for(let s=0;s<n.length;s++){const a=n[s];e.setFrame(h,a.time,this.getValue(a,t,0)*o),this.readCurve(a,e,h),h++}a.push(e),r=Math.max(r,e.frames[(e.getFrameCount()-1)*gn.ENTRIES])}else if("mix"===t){const t=new wn(n.length);t.pathConstraintIndex=i;let e=0;for(let s=0;s<n.length;s++){const a=n[s];t.setFrame(e,a.time,this.getValue(a,"rotateMix",1),this.getValue(a,"translateMix",1)),this.readCurve(a,t,e),e++}a.push(t),r=Math.max(r,t.frames[(t.getFrameCount()-1)*wn.ENTRIES])}}}if(t.deform)for(const o in t.deform){const e=t.deform[o],i=n.findSkin(o);if(null!=i)for(const t in e){const o=e[t],l=n.findSlotIndex(t);if(-1==l)throw new Error(`Slot not found: ${o.name}`);for(const t in o){const e=o[t],n=i.getAttachment(l,t);if(null==n)throw new Error(`Deform attachment not found: ${e.name}`);const h=null!=n.bones,c=n.vertices,d=h?c.length/3*2:c.length,u=new on(e.length);u.slotIndex=l,u.attachment=n;let m=0;for(let t=0;t<e.length;t++){const n=e[t];let a;const r=this.getValue(n,"vertices",null);if(null==r)a=h?j.newFloatArray(d):c;else{a=j.newFloatArray(d);const t=this.getValue(n,"offset",0);if(j.arrayCopy(r,0,a,t,r.length),1!=s)for(let e=t,n=e+r.length;e<n;e++)a[e]*=s;if(!h)for(let e=0;e<d;e++)a[e]+=c[e]}u.setFrame(m,n.time,a),this.readCurve(n,u,m),m++}a.push(u),r=Math.max(r,u.frames[u.getFrameCount()-1])}}}let i=t.drawOrder;if(null==i&&(i=t.draworder),null!=i){const t=new hn(i.length),e=n.slots.length;let s=0;for(let a=0;a<i.length;a++){const r=i[a];let o=null;const l=this.getValue(r,"offsets",null);if(null!=l){o=j.newArray(e,-1);const t=j.newArray(e-l.length,0);let s=0,a=0;for(let e=0;e<l.length;e++){const r=l[e],i=n.findSlotIndex(r.slot);if(-1==i)throw new Error(`Slot not found: ${r.slot}`);for(;s!=i;)t[a++]=s++;o[s+r.offset]=s++}for(;s<e;)t[a++]=s++;for(let n=e-1;n>=0;n--)-1==o[n]&&(o[n]=t[--a])}t.setFrame(s++,r.time,o)}a.push(t),r=Math.max(r,t.frames[t.getFrameCount()-1])}if(t.events){const e=new ln(t.events.length);let s=0;for(let a=0;a<t.events.length;a++){const r=t.events[a],i=n.findEvent(r.name);if(null==i)throw new Error(`Event not found: ${r.name}`);const o=new vn(j.toSinglePrecision(r.time),i);o.intValue=this.getValue(r,"int",i.intValue),o.floatValue=this.getValue(r,"float",i.floatValue),o.stringValue=this.getValue(r,"string",i.stringValue),null!=o.data.audioPath&&(o.volume=this.getValue(r,"volume",1),o.balance=this.getValue(r,"balance",0)),e.setFrame(s++,o)}a.push(e),r=Math.max(r,e.frames[e.getFrameCount()-1])}if(isNaN(r))throw new Error("Error while parsing animation, duration is NaN");n.animations.push(new $e(e,a,r))}readCurve(t,e,n){if(t.curve)if("stepped"===t.curve)e.setStepped(n);else if("[object Array]"===Object.prototype.toString.call(t.curve)){const s=t.curve;e.setCurve(n,s[0],s[1],s[2],s[3])}}getValue(t,e,n){return void 0!==t[e]?t[e]:n}static blendModeFromString(t){if("normal"==(t=t.toLowerCase()))return y.NORMAL;if("additive"==t)return y.ADD;if("multiply"==t)return y.MULTIPLY;if("screen"==t)return y.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if("fixed"==(t=t.toLowerCase()))return T.Fixed;if("percent"==t)return T.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if("length"==(t=t.toLowerCase()))return Xn.Length;if("fixed"==t)return Xn.Fixed;if("percent"==t)return Xn.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if("tangent"==(t=t.toLowerCase()))return k.Tangent;if("chain"==t)return k.Chain;if("chainscale"==t)return k.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if("normal"==(t=t.toLowerCase()))return R.Normal;if("onlytranslation"==t)return R.OnlyTranslation;if("norotationorreflection"==t)return R.NoRotationOrReflection;if("noscale"==t)return R.NoScale;if("noscaleorreflection"==t)return R.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}},Hn=class{constructor(t,e,n,s){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=s}};const jn=Object.freeze(Object.defineProperty({__proto__:null,Animation:$e,AnimationState:En,AnimationStateAdapter2:class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}},AnimationStateData:kn,AtlasAttachmentLoader:Rn,Attachment:ve,AttachmentTimeline:an,Bone:Cn,BoneData:Vn,BoundingBoxAttachment:Ye,ClippingAttachment:Ne,ColorTimeline:en,CurveTimeline:He,DeformTimeline:on,DrawOrderTimeline:hn,Event:vn,EventData:Pn,EventQueue:An,EventTimeline:ln,EventType:In,IkConstraint:Fn,IkConstraintData:Yn,IkConstraintTimeline:dn,JitterEffect:class{constructor(t,e){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,n,s){t.x+=q.randomTriangular(-this.jitterX,this.jitterY),t.y+=q.randomTriangular(-this.jitterX,this.jitterY)}end(){}},MeshAttachment:Xe,PathAttachment:De,PathConstraint:Bn,PathConstraintData:Nn,PathConstraintMixTimeline:wn,PathConstraintPositionTimeline:gn,PathConstraintSpacingTimeline:pn,PointAttachment:Be,RegionAttachment:Oe,RotateTimeline:Ge,ScaleTimeline:Ke,ShearTimeline:Je,Skeleton:On,SkeletonBounds:class extends Q{},SkeletonData:Wn,SkeletonJson:zn,Skin:Un,Slot:Le,SlotData:qn,SpacingMode:Xn,Spine:class extends st{createSkeleton(t){this.skeleton=new On(t),this.skeleton.updateWorldTransform(),this.stateData=new kn(t),this.state=new En(this.stateData)}},SwirlEffect:qe,TimelineType:Ue,TrackEntry:Sn,TransformConstraint:Ln,TransformConstraintData:$n,TransformConstraintTimeline:mn,TranslateTimeline:Qe,TwoColorTimeline:sn,VertexAttachment:Fe},Symbol.toStringTag,{value:"Module"}));class Gn{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const Zn=class extends Gn{constructor(t){super(t),this.id=Zn.nextID++,this.bones=null,this.vertices=[],this.worldVerticesLength=0,this.timelineAttachment=this}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,n,s,a,r){n=a+(n>>1)*r;const i=t.bone.skeleton,o=t.deform;let l=this.vertices;const h=this.bones;if(!h){o.length>0&&(l=o);const i=t.bone.matrix,h=i.tx,c=i.ty,d=i.a,u=i.c,m=i.b,f=i.d;for(let t=e,o=a;o<n;t+=2,o+=r){const e=l[t],n=l[t+1];s[o]=e*d+n*u+h,s[o+1]=e*m+n*f+c}return}let c=0,d=0;for(let m=0;m<e;m+=2){const t=h[c];c+=t+1,d+=t}const u=i.bones;if(0==o.length)for(let m=a,f=3*d;m<n;m+=r){let t=0,e=0,n=h[c++];for(n+=c;c<n;c++,f+=3){const n=u[h[c]].matrix,s=l[f],a=l[f+1],r=l[f+2];t+=(s*n.a+a*n.c+n.tx)*r,e+=(s*n.b+a*n.d+n.ty)*r}s[m]=t,s[m+1]=e}else{const t=o;for(let e=a,i=3*d,o=d<<1;e<n;e+=r){let n=0,a=0,r=h[c++];for(r+=c;c<r;c++,i+=3,o+=2){const e=u[h[c]].matrix,s=l[i]+t[o],r=l[i+1]+t[o+1],d=l[i+2];n+=(s*e.a+r*e.c+e.tx)*d,a+=(s*e.b+r*e.d+e.ty)*d}s[e]=n,s[e+1]=a}}}copyTo(t){this.bones?(t.bones=new Array(this.bones.length),j.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices&&(t.vertices=j.newFloatArray(this.vertices.length),j.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)),t.worldVerticesLength=this.worldVerticesLength,t.timelineAttachment=this.timelineAttachment}};let Qn=Zn;Qn.nextID=0;class Kn extends Qn{constructor(t){super(t),this.type=S.BoundingBox,this.color=new O(1,1,1,1)}copy(){const t=new Kn(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Jn extends Qn{constructor(t){super(t),this.type=S.Clipping,this.endSlot=null,this.color=new O(.2275,.2275,.8078,1)}copy(){const t=new Jn(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class ts extends Qn{constructor(t,e){super(t),this.type=S.Mesh,this.region=null,this.triangles=[],this.color=new O(1,1,1,1),this.width=0,this.height=0,this.hullLength=0,this.edges=[],this.parentMesh=null,this.sequence=null,this.tempColor=new O(0,0,0,0),this.path=e}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new ts(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),j.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),j.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=null!=this.sequence?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),j.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,e,n,s,a,r){null!=this.sequence&&this.sequence.apply(t,this),super.computeWorldVertices(t,e,n,s,a,r)}newLinkedMesh(){const t=new ts(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class es extends Qn{constructor(t){super(t),this.type=S.Path,this.lengths=[],this.closed=!1,this.constantSpeed=!1,this.color=new O(1,1,1,1)}copy(){const t=new es(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),j.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class ns extends Qn{constructor(t){super(t),this.type=S.Point,this.x=0,this.y=0,this.rotation=0,this.color=new O(.38,.94,0,1)}computeWorldPosition(t,e){const n=t.matrix;return e.x=this.x*n.a+this.y*n.c+t.worldX,e.y=this.x*n.b+this.y*n.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,n=q.cosDeg(this.rotation),s=q.sinDeg(this.rotation),a=n*e.a+s*e.c,r=n*e.b+s*e.d;return Math.atan2(r,a)*q.radDeg}copy(){const t=new ns(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}const ss=class extends Gn{constructor(t,e){super(t),this.type=S.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new O(1,1,1,1),this.rendererObject=null,this.region=null,this.sequence=null,this.offset=j.newFloatArray(8),this.uvs=j.newFloatArray(8),this.tempColor=new O(1,1,1,1),this.path=e}updateRegion(){if(!this.region)throw new Error("Region not set.");const t=this.region,e=this.width/this.region.originalWidth*this.scaleX,n=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*e,a=-this.height/2*this.scaleY+this.region.offsetY*n,r=s+this.region.width*e,i=a+this.region.height*n,o=this.rotation*Math.PI/180,l=Math.cos(o),h=Math.sin(o),c=this.x,d=this.y,u=s*l+c,m=s*h,f=a*l+d,g=a*h,p=r*l+c,x=r*h,w=i*l+d,b=i*h,E=this.offset;E[0]=u-g,E[1]=f+m,E[2]=u-b,E[3]=w+m,E[4]=p-b,E[5]=w+x,E[6]=p-g,E[7]=f+x;const y=this.uvs;90==t.degrees?(y[2]=t.u,y[3]=t.v2,y[4]=t.u,y[5]=t.v,y[6]=t.u2,y[7]=t.v,y[0]=t.u2,y[1]=t.v2):(y[0]=t.u,y[1]=t.v2,y[2]=t.u,y[3]=t.v,y[4]=t.u2,y[5]=t.v,y[6]=t.u2,y[7]=t.v2)}computeWorldVertices(t,e,n,s){null!=this.sequence&&this.sequence.apply(t,this);const a=t.bone,r=this.offset,i=a.matrix,o=i.tx,l=i.ty,h=i.a,c=i.c,d=i.b,u=i.d;let m=0,f=0;m=r[0],f=r[1],e[n]=m*h+f*c+o,e[n+1]=m*d+f*u+l,n+=s,m=r[2],f=r[3],e[n]=m*h+f*c+o,e[n+1]=m*d+f*u+l,n+=s,m=r[4],f=r[5],e[n]=m*h+f*c+o,e[n+1]=m*d+f*u+l,n+=s,m=r[6],f=r[7],e[n]=m*h+f*c+o,e[n+1]=m*d+f*u+l}copy(){const t=new ss(this.name,this.path);return t.region=this.region,t.rendererObject=this.rendererObject,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,j.arrayCopy(this.uvs,0,t.uvs,0,8),j.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t.sequence=null!=this.sequence?this.sequence.copy():null,t}};let as=ss;as.X1=0,as.Y1=1,as.C1R=2,as.C1G=3,as.C1B=4,as.C1A=5,as.U1=6,as.V1=7,as.X2=8,as.Y2=9,as.C2R=10,as.C2G=11,as.C2B=12,as.C2A=13,as.U2=14,as.V2=15,as.X3=16,as.Y3=17,as.C3R=18,as.C3G=19,as.C3B=20,as.C3A=21,as.U3=22,as.V3=23,as.X4=24,as.Y4=25,as.C4R=26,as.C4G=27,as.C4B=28,as.C4A=29,as.U4=30,as.V4=31;const rs=class{constructor(t){this.id=rs.nextID(),this.start=0,this.digits=0,this.setupIndex=0,this.regions=new Array(t)}copy(){const t=new rs(this.regions.length);return j.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,e){let n=t.sequenceIndex;-1==n&&(n=this.setupIndex),n>=this.regions.length&&(n=this.regions.length-1);const s=this.regions[n];e.region!=s&&(e.region=s)}getPath(t,e){let n=t;const s=(this.start+e).toString();for(let a=this.digits-s.length;a>0;a--)n+="0";return n+=s,n}static nextID(){return rs._nextID++}};let is=rs;is._nextID=0;var os=(t=>(t[t.hold=0]="hold",t[t.once=1]="once",t[t.loop=2]="loop",t[t.pingpong=3]="pingpong",t[t.onceReverse=4]="onceReverse",t[t.loopReverse=5]="loopReverse",t[t.pingpongReverse=6]="pingpongReverse",t))(os||{});const ls=[0,1,2,3,4,5,6];class hs{constructor(t,e,n){if(this.timelines=[],this.timelineIds=new L,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(e),this.duration=n}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let e=0;e<t.length;e++)this.timelineIds.addAll(t[e].getPropertyIds())}hasTimeline(t){for(let e=0;e<t.length;e++)if(this.timelineIds.contains(t[e]))return!0;return!1}apply(t,e,n,s,a,r,i,o){if(!t)throw new Error("skeleton cannot be null.");s&&0!=this.duration&&(n%=this.duration,e>0&&(e%=this.duration));const l=this.timelines;for(let h=0,c=l.length;h<c;h++)l[h].apply(t,e,n,a,r,i,o)}}const cs=0,ds=1,us=2,ms=3,fs=4,gs=5,ps=6,xs=7,ws=8,bs=9,Es=10,ys=11,Ss=12,Ms=13,As=14,Is=15,Ts=16,ks=17,Rs=18,Cs=19;class Vs{constructor(t,e){this.propertyIds=e,this.frames=j.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,e){const n=t.length;for(let s=1;s<n;s++)if(t[s]>e)return s-1;return n-1}static search(t,e,n){const s=t.length;for(let a=n;a<s;a+=n)if(t[a]>e)return a-n;return s-n}}class vs extends Vs{constructor(t,e,n){super(t,n),this.curves=j.newFloatArray(t+18*e),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const e=this.getFrameCount()+18*t;if(this.curves.length>e){const t=j.newFloatArray(e);j.arrayCopy(this.curves,0,t,0,e),this.curves=t}}setBezier(t,e,n,s,a,r,i,o,l,h,c){const d=this.curves;let u=this.getFrameCount()+18*t;0==n&&(d[e]=2+u);const m=.03*(s-2*r+o),f=.03*(a-2*i+l),g=.006*(3*(r-o)-s+h),p=.006*(3*(i-l)-a+c);let x=2*m+g,w=2*f+p,b=.3*(r-s)+m+.16666667*g,E=.3*(i-a)+f+.16666667*p,y=s+b,S=a+E;for(let M=u+18;u<M;u+=2)d[u]=y,d[u+1]=S,b+=x,E+=w,x+=g,w+=p,y+=b,S+=E}getBezierValue(t,e,n,s){const a=this.curves;if(a[s]>t){const r=this.frames[e],i=this.frames[e+n];return i+(t-r)/(a[s]-r)*(a[s+1]-i)}const r=s+18;for(s+=2;s<r;s+=2)if(a[s]>=t){const e=a[s-2],n=a[s-1];return n+(t-e)/(a[s]-e)*(a[s+1]-n)}e+=this.getFrameEntries();const i=a[r-2],o=a[r-1];return o+(t-i)/(this.frames[e]-i)*(this.frames[e+n]-o)}}class Ps extends vs{constructor(t,e,n){super(t,e,[n])}getFrameEntries(){return 2}setFrame(t,e,n){t<<=1,this.frames[t]=e,this.frames[t+1]=n}getCurveValue(t){const e=this.frames;let n=e.length-2;for(let a=2;a<=n;a+=2)if(e[a]>t){n=a-2;break}const s=this.curves[n>>1];switch(s){case 0:const s=e[n],a=e[n+1];return a+(t-s)/(e[n+2]-s)*(e[n+2+1]-a);case 1:return e[n+1]}return this.getBezierValue(t,n,1,s-2)}}class Fs extends vs{constructor(t,e,n,s){super(t,e,[n,s])}getFrameEntries(){return 3}setFrame(t,e,n,s){t*=3,this.frames[t]=e,this.frames[t+1]=n,this.frames[t+2]=s}}class Ys extends Ps{constructor(t,e,n){super(t,e,`${cs}|${n}`),this.boneIndex=0,this.boneIndex=n}apply(t,e,n,s,a,r,i){const o=t.bones[this.boneIndex];if(!o.active)return;if(n<this.frames[0]){switch(r){case A.setup:return void(o.rotation=o.data.rotation);case A.first:o.rotation+=(o.data.rotation-o.rotation)*a}return}let l=this.getCurveValue(n);switch(r){case A.setup:o.rotation=o.data.rotation+l*a;break;case A.first:case A.replace:l+=o.data.rotation-o.rotation;case A.add:o.rotation+=l*a}}}class Ns extends Fs{constructor(t,e,n){super(t,e,`${ds}|${n}`,`${us}|${n}`),this.boneIndex=0,this.boneIndex=n}apply(t,e,n,s,a,r,i){const o=t.bones[this.boneIndex];if(!o.active)return;const l=this.frames;if(n<l[0]){switch(r){case A.setup:return o.x=o.data.x,void(o.y=o.data.y);case A.first:o.x+=(o.data.x-o.x)*a,o.y+=(o.data.y-o.y)*a}return}let h=0,c=0;const d=Vs.search(l,n,3),u=this.curves[d/3];switch(u){case 0:const t=l[d];h=l[d+1],c=l[d+2];const e=(n-t)/(l[d+3]-t);h+=(l[d+3+1]-h)*e,c+=(l[d+3+2]-c)*e;break;case 1:h=l[d+1],c=l[d+2];break;default:h=this.getBezierValue(n,d,1,u-2),c=this.getBezierValue(n,d,2,u+18-2)}switch(r){case A.setup:o.x=o.data.x+h*a,o.y=o.data.y+c*a;break;case A.first:case A.replace:o.x+=(o.data.x+h-o.x)*a,o.y+=(o.data.y+c-o.y)*a;break;case A.add:o.x+=h*a,o.y+=c*a}}}class Xs extends Ps{constructor(t,e,n){super(t,e,`${ds}|${n}`),this.boneIndex=0,this.boneIndex=n}apply(t,e,n,s,a,r,i){const o=t.bones[this.boneIndex];if(!o.active)return;if(n<this.frames[0]){switch(r){case A.setup:return void(o.x=o.data.x);case A.first:o.x+=(o.data.x-o.x)*a}return}const l=this.getCurveValue(n);switch(r){case A.setup:o.x=o.data.x+l*a;break;case A.first:case A.replace:o.x+=(o.data.x+l-o.x)*a;break;case A.add:o.x+=l*a}}}class Ds extends Ps{constructor(t,e,n){super(t,e,`${us}|${n}`),this.boneIndex=0,this.boneIndex=n}apply(t,e,n,s,a,r,i){const o=t.bones[this.boneIndex];if(!o.active)return;if(n<this.frames[0]){switch(r){case A.setup:return void(o.y=o.data.y);case A.first:o.y+=(o.data.y-o.y)*a}return}const l=this.getCurveValue(n);switch(r){case A.setup:o.y=o.data.y+l*a;break;case A.first:case A.replace:o.y+=(o.data.y+l-o.y)*a;break;case A.add:o.y+=l*a}}}class Bs extends Fs{constructor(t,e,n){super(t,e,`${ms}|${n}`,`${fs}|${n}`),this.boneIndex=0,this.boneIndex=n}apply(t,e,n,s,a,r,i){const o=t.bones[this.boneIndex];if(!o.active)return;const l=this.frames;if(n<l[0]){switch(r){case A.setup:return o.scaleX=o.data.scaleX,void(o.scaleY=o.data.scaleY);case A.first:o.scaleX+=(o.data.scaleX-o.scaleX)*a,o.scaleY+=(o.data.scaleY-o.scaleY)*a}return}let h,c;const d=Vs.search(l,n,3),u=this.curves[d/3];switch(u){case 0:const t=l[d];h=l[d+1],c=l[d+2];const e=(n-t)/(l[d+3]-t);h+=(l[d+3+1]-h)*e,c+=(l[d+3+2]-c)*e;break;case 1:h=l[d+1],c=l[d+2];break;default:h=this.getBezierValue(n,d,1,u-2),c=this.getBezierValue(n,d,2,u+18-2)}if(h*=o.data.scaleX,c*=o.data.scaleY,1==a)r==A.add?(o.scaleX+=h-o.data.scaleX,o.scaleY+=c-o.data.scaleY):(o.scaleX=h,o.scaleY=c);else{let t=0,e=0;if(i==I.mixOut)switch(r){case A.setup:t=o.data.scaleX,e=o.data.scaleY,o.scaleX=t+(Math.abs(h)*q.signum(t)-t)*a,o.scaleY=e+(Math.abs(c)*q.signum(e)-e)*a;break;case A.first:case A.replace:t=o.scaleX,e=o.scaleY,o.scaleX=t+(Math.abs(h)*q.signum(t)-t)*a,o.scaleY=e+(Math.abs(c)*q.signum(e)-e)*a;break;case A.add:o.scaleX+=(h-o.data.scaleX)*a,o.scaleY+=(c-o.data.scaleY)*a}else switch(r){case A.setup:t=Math.abs(o.data.scaleX)*q.signum(h),e=Math.abs(o.data.scaleY)*q.signum(c),o.scaleX=t+(h-t)*a,o.scaleY=e+(c-e)*a;break;case A.first:case A.replace:t=Math.abs(o.scaleX)*q.signum(h),e=Math.abs(o.scaleY)*q.signum(c),o.scaleX=t+(h-t)*a,o.scaleY=e+(c-e)*a;break;case A.add:o.scaleX+=(h-o.data.scaleX)*a,o.scaleY+=(c-o.data.scaleY)*a}}}}class Ls extends Ps{constructor(t,e,n){super(t,e,`${ms}|${n}`),this.boneIndex=0,this.boneIndex=n}apply(t,e,n,s,a,r,i){const o=t.bones[this.boneIndex];if(!o.active)return;if(n<this.frames[0]){switch(r){case A.setup:return void(o.scaleX=o.data.scaleX);case A.first:o.scaleX+=(o.data.scaleX-o.scaleX)*a}return}const l=this.getCurveValue(n)*o.data.scaleX;if(1==a)r==A.add?o.scaleX+=l-o.data.scaleX:o.scaleX=l;else{let t=0;if(i==I.mixOut)switch(r){case A.setup:t=o.data.scaleX,o.scaleX=t+(Math.abs(l)*q.signum(t)-t)*a;break;case A.first:case A.replace:t=o.scaleX,o.scaleX=t+(Math.abs(l)*q.signum(t)-t)*a;break;case A.add:o.scaleX+=(l-o.data.scaleX)*a}else switch(r){case A.setup:t=Math.abs(o.data.scaleX)*q.signum(l),o.scaleX=t+(l-t)*a;break;case A.first:case A.replace:t=Math.abs(o.scaleX)*q.signum(l),o.scaleX=t+(l-t)*a;break;case A.add:o.scaleX+=(l-o.data.scaleX)*a}}}}class _s extends Ps{constructor(t,e,n){super(t,e,`${fs}|${n}`),this.boneIndex=0,this.boneIndex=n}apply(t,e,n,s,a,r,i){const o=t.bones[this.boneIndex];if(!o.active)return;if(n<this.frames[0]){switch(r){case A.setup:return void(o.scaleY=o.data.scaleY);case A.first:o.scaleY+=(o.data.scaleY-o.scaleY)*a}return}const l=this.getCurveValue(n)*o.data.scaleY;if(1==a)r==A.add?o.scaleY+=l-o.data.scaleY:o.scaleY=l;else{let t=0;if(i==I.mixOut)switch(r){case A.setup:t=o.data.scaleY,o.scaleY=t+(Math.abs(l)*q.signum(t)-t)*a;break;case A.first:case A.replace:t=o.scaleY,o.scaleY=t+(Math.abs(l)*q.signum(t)-t)*a;break;case A.add:o.scaleY+=(l-o.data.scaleY)*a}else switch(r){case A.setup:t=Math.abs(o.data.scaleY)*q.signum(l),o.scaleY=t+(l-t)*a;break;case A.first:case A.replace:t=Math.abs(o.scaleY)*q.signum(l),o.scaleY=t+(l-t)*a;break;case A.add:o.scaleY+=(l-o.data.scaleY)*a}}}}class Os extends Fs{constructor(t,e,n){super(t,e,`${gs}|${n}`,`${ps}|${n}`),this.boneIndex=0,this.boneIndex=n}apply(t,e,n,s,a,r,i){const o=t.bones[this.boneIndex];if(!o.active)return;const l=this.frames;if(n<l[0]){switch(r){case A.setup:return o.shearX=o.data.shearX,void(o.shearY=o.data.shearY);case A.first:o.shearX+=(o.data.shearX-o.shearX)*a,o.shearY+=(o.data.shearY-o.shearY)*a}return}let h=0,c=0;const d=Vs.search(l,n,3),u=this.curves[d/3];switch(u){case 0:const t=l[d];h=l[d+1],c=l[d+2];const e=(n-t)/(l[d+3]-t);h+=(l[d+3+1]-h)*e,c+=(l[d+3+2]-c)*e;break;case 1:h=l[d+1],c=l[d+2];break;default:h=this.getBezierValue(n,d,1,u-2),c=this.getBezierValue(n,d,2,u+18-2)}switch(r){case A.setup:o.shearX=o.data.shearX+h*a,o.shearY=o.data.shearY+c*a;break;case A.first:case A.replace:o.shearX+=(o.data.shearX+h-o.shearX)*a,o.shearY+=(o.data.shearY+c-o.shearY)*a;break;case A.add:o.shearX+=h*a,o.shearY+=c*a}}}class Ws extends Ps{constructor(t,e,n){super(t,e,`${gs}|${n}`),this.boneIndex=0,this.boneIndex=n}apply(t,e,n,s,a,r,i){const o=t.bones[this.boneIndex];if(!o.active)return;if(n<this.frames[0]){switch(r){case A.setup:return void(o.shearX=o.data.shearX);case A.first:o.shearX+=(o.data.shearX-o.shearX)*a}return}const l=this.getCurveValue(n);switch(r){case A.setup:o.shearX=o.data.shearX+l*a;break;case A.first:case A.replace:o.shearX+=(o.data.shearX+l-o.shearX)*a;break;case A.add:o.shearX+=l*a}}}class qs extends Ps{constructor(t,e,n){super(t,e,`${ps}|${n}`),this.boneIndex=0,this.boneIndex=n}apply(t,e,n,s,a,r,i){const o=t.bones[this.boneIndex];if(!o.active)return;if(n<this.frames[0]){switch(r){case A.setup:return void(o.shearY=o.data.shearY);case A.first:o.shearY+=(o.data.shearY-o.shearY)*a}return}const l=this.getCurveValue(n);switch(r){case A.setup:o.shearY=o.data.shearY+l*a;break;case A.first:case A.replace:o.shearY+=(o.data.shearY+l-o.shearY)*a;break;case A.add:o.shearY+=l*a}}}class $s extends vs{constructor(t,e,n){super(t,e,[`${xs}|${n}`,`${ws}|${n}`]),this.slotIndex=0,this.slotIndex=n}getFrameEntries(){return 5}setFrame(t,e,n,s,a,r){t*=5,this.frames[t]=e,this.frames[t+1]=n,this.frames[t+2]=s,this.frames[t+3]=a,this.frames[t+4]=r}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;const l=this.frames,h=o.color;if(n<l[0]){const t=o.data.color;switch(r){case A.setup:return void h.setFromColor(t);case A.first:h.add((t.r-h.r)*a,(t.g-h.g)*a,(t.b-h.b)*a,(t.a-h.a)*a)}return}let c=0,d=0,u=0,m=0;const f=Vs.search(l,n,5),g=this.curves[f/5];switch(g){case 0:const t=l[f];c=l[f+1],d=l[f+2],u=l[f+3],m=l[f+4];const e=(n-t)/(l[f+5]-t);c+=(l[f+5+1]-c)*e,d+=(l[f+5+2]-d)*e,u+=(l[f+5+3]-u)*e,m+=(l[f+5+4]-m)*e;break;case 1:c=l[f+1],d=l[f+2],u=l[f+3],m=l[f+4];break;default:c=this.getBezierValue(n,f,1,g-2),d=this.getBezierValue(n,f,2,g+18-2),u=this.getBezierValue(n,f,3,g+36-2),m=this.getBezierValue(n,f,4,g+54-2)}1==a?h.set(c,d,u,m):(r==A.setup&&h.setFromColor(o.data.color),h.add((c-h.r)*a,(d-h.g)*a,(u-h.b)*a,(m-h.a)*a))}}class Us extends vs{constructor(t,e,n){super(t,e,[`${xs}|${n}`]),this.slotIndex=0,this.slotIndex=n}getFrameEntries(){return 4}setFrame(t,e,n,s,a){t<<=2,this.frames[t]=e,this.frames[t+1]=n,this.frames[t+2]=s,this.frames[t+3]=a}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;const l=this.frames,h=o.color;if(n<l[0]){const t=o.data.color;switch(r){case A.setup:return h.r=t.r,h.g=t.g,void(h.b=t.b);case A.first:h.r+=(t.r-h.r)*a,h.g+=(t.g-h.g)*a,h.b+=(t.b-h.b)*a}return}let c=0,d=0,u=0;const m=Vs.search(l,n,4),f=this.curves[m>>2];switch(f){case 0:const t=l[m];c=l[m+1],d=l[m+2],u=l[m+3];const e=(n-t)/(l[m+4]-t);c+=(l[m+4+1]-c)*e,d+=(l[m+4+2]-d)*e,u+=(l[m+4+3]-u)*e;break;case 1:c=l[m+1],d=l[m+2],u=l[m+3];break;default:c=this.getBezierValue(n,m,1,f-2),d=this.getBezierValue(n,m,2,f+18-2),u=this.getBezierValue(n,m,3,f+36-2)}if(1==a)h.r=c,h.g=d,h.b=u;else{if(r==A.setup){const t=o.data.color;h.r=t.r,h.g=t.g,h.b=t.b}h.r+=(c-h.r)*a,h.g+=(d-h.g)*a,h.b+=(u-h.b)*a}}}class zs extends Ps{constructor(t,e,n){super(t,e,`${ws}|${n}`),this.slotIndex=0,this.slotIndex=n}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;const l=o.color;if(n<this.frames[0]){const t=o.data.color;switch(r){case A.setup:return void(l.a=t.a);case A.first:l.a+=(t.a-l.a)*a}return}const h=this.getCurveValue(n);1==a?l.a=h:(r==A.setup&&(l.a=o.data.color.a),l.a+=(h-l.a)*a)}}class Hs extends vs{constructor(t,e,n){super(t,e,[`${xs}|${n}`,`${ws}|${n}`,`${bs}|${n}`]),this.slotIndex=0,this.slotIndex=n}getFrameEntries(){return 8}setFrame(t,e,n,s,a,r,i,o,l){t<<=3,this.frames[t]=e,this.frames[t+1]=n,this.frames[t+2]=s,this.frames[t+3]=a,this.frames[t+4]=r,this.frames[t+5]=i,this.frames[t+6]=o,this.frames[t+7]=l}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;const l=this.frames,h=o.color,c=o.darkColor;if(n<l[0]){const t=o.data.color,e=o.data.darkColor;switch(r){case A.setup:return h.setFromColor(t),c.r=e.r,c.g=e.g,void(c.b=e.b);case A.first:h.add((t.r-h.r)*a,(t.g-h.g)*a,(t.b-h.b)*a,(t.a-h.a)*a),c.r+=(e.r-c.r)*a,c.g+=(e.g-c.g)*a,c.b+=(e.b-c.b)*a}return}let d=0,u=0,m=0,f=0,g=0,p=0,x=0;const w=Vs.search(l,n,8),b=this.curves[w>>3];switch(b){case 0:const t=l[w];d=l[w+1],u=l[w+2],m=l[w+3],f=l[w+4],g=l[w+5],p=l[w+6],x=l[w+7];const e=(n-t)/(l[w+8]-t);d+=(l[w+8+1]-d)*e,u+=(l[w+8+2]-u)*e,m+=(l[w+8+3]-m)*e,f+=(l[w+8+4]-f)*e,g+=(l[w+8+5]-g)*e,p+=(l[w+8+6]-p)*e,x+=(l[w+8+7]-x)*e;break;case 1:d=l[w+1],u=l[w+2],m=l[w+3],f=l[w+4],g=l[w+5],p=l[w+6],x=l[w+7];break;default:d=this.getBezierValue(n,w,1,b-2),u=this.getBezierValue(n,w,2,b+18-2),m=this.getBezierValue(n,w,3,b+36-2),f=this.getBezierValue(n,w,4,b+54-2),g=this.getBezierValue(n,w,5,b+72-2),p=this.getBezierValue(n,w,6,b+90-2),x=this.getBezierValue(n,w,7,b+108-2)}if(1==a)h.set(d,u,m,f),c.r=g,c.g=p,c.b=x;else{if(r==A.setup){h.setFromColor(o.data.color);const t=o.data.darkColor;c.r=t.r,c.g=t.g,c.b=t.b}h.add((d-h.r)*a,(u-h.g)*a,(m-h.b)*a,(f-h.a)*a),c.r+=(g-c.r)*a,c.g+=(p-c.g)*a,c.b+=(x-c.b)*a}}}class js extends vs{constructor(t,e,n){super(t,e,[`${xs}|${n}`,`${bs}|${n}`]),this.slotIndex=0,this.slotIndex=n}getFrameEntries(){return 7}setFrame(t,e,n,s,a,r,i,o){t*=7,this.frames[t]=e,this.frames[t+1]=n,this.frames[t+2]=s,this.frames[t+3]=a,this.frames[t+4]=r,this.frames[t+5]=i,this.frames[t+6]=o}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;const l=this.frames,h=o.color,c=o.darkColor;if(n<l[0]){const t=o.data.color,e=o.data.darkColor;switch(r){case A.setup:return h.r=t.r,h.g=t.g,h.b=t.b,c.r=e.r,c.g=e.g,void(c.b=e.b);case A.first:h.r+=(t.r-h.r)*a,h.g+=(t.g-h.g)*a,h.b+=(t.b-h.b)*a,c.r+=(e.r-c.r)*a,c.g+=(e.g-c.g)*a,c.b+=(e.b-c.b)*a}return}let d=0,u=0,m=0,f=0,g=0,p=0;const x=Vs.search(l,n,7),w=this.curves[x/7];switch(w){case 0:const t=l[x];d=l[x+1],u=l[x+2],m=l[x+3],f=l[x+4],g=l[x+5],p=l[x+6];const e=(n-t)/(l[x+7]-t);d+=(l[x+7+1]-d)*e,u+=(l[x+7+2]-u)*e,m+=(l[x+7+3]-m)*e,f+=(l[x+7+4]-f)*e,g+=(l[x+7+5]-g)*e,p+=(l[x+7+6]-p)*e;break;case 1:d=l[x+1],u=l[x+2],m=l[x+3],f=l[x+4],g=l[x+5],p=l[x+6];break;default:d=this.getBezierValue(n,x,1,w-2),u=this.getBezierValue(n,x,2,w+18-2),m=this.getBezierValue(n,x,3,w+36-2),f=this.getBezierValue(n,x,4,w+54-2),g=this.getBezierValue(n,x,5,w+72-2),p=this.getBezierValue(n,x,6,w+90-2)}if(1==a)h.r=d,h.g=u,h.b=m,c.r=f,c.g=g,c.b=p;else{if(r==A.setup){const t=o.data.color,e=o.data.darkColor;h.r=t.r,h.g=t.g,h.b=t.b,c.r=e.r,c.g=e.g,c.b=e.b}h.r+=(d-h.r)*a,h.g+=(u-h.g)*a,h.b+=(m-h.b)*a,c.r+=(f-c.r)*a,c.g+=(g-c.g)*a,c.b+=(p-c.b)*a}}}class Gs extends Vs{constructor(t,e){super(t,[`${Es}|${e}`]),this.slotIndex=0,this.slotIndex=e,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.attachmentNames[t]=n}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];o.bone.active&&(i!=I.mixOut?n<this.frames[0]?r!=A.setup&&r!=A.first||this.setAttachment(t,o,o.data.attachmentName):this.setAttachment(t,o,this.attachmentNames[Vs.search1(this.frames,n)]):r==A.setup&&this.setAttachment(t,o,o.data.attachmentName))}setAttachment(t,e,n){e.setAttachment(n?t.getAttachment(this.slotIndex,n):null)}}class Zs extends vs{constructor(t,e,n,s){super(t,e,[`${ys}|${n}|${s.id}`]),this.slotIndex=0,this.slotIndex=n,this.attachment=s,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.vertices[t]=n}setBezier(t,e,n,s,a,r,i,o,l,h,c){const d=this.curves;let u=this.getFrameCount()+18*t;0==n&&(d[e]=2+u);const m=.03*(s-2*r+o),f=.03*l-.06*i,g=.006*(3*(r-o)-s+h),p=.018*(i-l+.33333333);let x=2*m+g,w=2*f+p,b=.3*(r-s)+m+.16666667*g,E=.3*i+f+.16666667*p,y=s+b,S=E;for(let M=u+18;u<M;u+=2)d[u]=y,d[u+1]=S,b+=x,E+=w,x+=g,w+=p,y+=b,S+=E}getCurvePercent(t,e){const n=this.curves;let s=n[e];switch(s){case 0:const n=this.frames[e];return(t-n)/(this.frames[e+this.getFrameEntries()]-n);case 1:return 0}if(s-=2,n[s]>t){const a=this.frames[e];return n[s+1]*(t-a)/(n[s]-a)}const a=s+18;for(s+=2;s<a;s+=2)if(n[s]>=t){const e=n[s-2],a=n[s-1];return a+(t-e)/(n[s]-e)*(n[s+1]-a)}const r=n[a-2],i=n[a-1];return i+(1-i)*(t-r)/(this.frames[e+this.getFrameEntries()]-r)}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;const l=o.getAttachment();if(!l)return;if(!(l instanceof Qn)||l.timelineAttachment!=this.attachment)return;const h=o.deform;0==h.length&&(r=A.setup);const c=this.vertices,d=c[0].length,u=this.frames;if(n<u[0]){switch(r){case A.setup:return void(h.length=0);case A.first:if(1==a)return void(h.length=0);h.length=d;const t=l;if(t.bones){a=1-a;for(let t=0;t<d;t++)h[t]*=a}else{const e=t.vertices;for(let t=0;t<d;t++)h[t]+=(e[t]-h[t])*a}}return}if(h.length=d,n>=u[u.length-1]){const t=c[u.length-1];if(1==a)if(r==A.add){const e=l;if(e.bones)for(let n=0;n<d;n++)h[n]+=t[n];else{const n=e.vertices;for(let e=0;e<d;e++)h[e]+=t[e]-n[e]}}else j.arrayCopy(t,0,h,0,d);else switch(r){case A.setup:{const e=l;if(e.bones)for(let n=0;n<d;n++)h[n]=t[n]*a;else{const n=e.vertices;for(let e=0;e<d;e++){const s=n[e];h[e]=s+(t[e]-s)*a}}break}case A.first:case A.replace:for(let n=0;n<d;n++)h[n]+=(t[n]-h[n])*a;break;case A.add:const e=l;if(e.bones)for(let n=0;n<d;n++)h[n]+=t[n]*a;else{const n=e.vertices;for(let e=0;e<d;e++)h[e]+=(t[e]-n[e])*a}}return}const m=Vs.search1(u,n),f=this.getCurvePercent(n,m),g=c[m],p=c[m+1];if(1==a)if(r==A.add){const t=l;if(t.bones)for(let e=0;e<d;e++){const t=g[e];h[e]+=t+(p[e]-t)*f}else{const e=t.vertices;for(let t=0;t<d;t++){const n=g[t];h[t]+=n+(p[t]-n)*f-e[t]}}}else for(let x=0;x<d;x++){const t=g[x];h[x]=t+(p[x]-t)*f}else switch(r){case A.setup:{const t=l;if(t.bones)for(let e=0;e<d;e++){const t=g[e];h[e]=(t+(p[e]-t)*f)*a}else{const e=t.vertices;for(let t=0;t<d;t++){const n=g[t],s=e[t];h[t]=s+(n+(p[t]-n)*f-s)*a}}break}case A.first:case A.replace:for(let e=0;e<d;e++){const t=g[e];h[e]+=(t+(p[e]-t)*f-h[e])*a}break;case A.add:const t=l;if(t.bones)for(let e=0;e<d;e++){const t=g[e];h[e]+=(t+(p[e]-t)*f)*a}else{const e=t.vertices;for(let t=0;t<d;t++){const n=g[t];h[t]+=(n+(p[t]-n)*f-e[t])*a}}}}}const Qs=class extends Vs{constructor(t){super(t,Qs.propertyIds),this.events=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,n,s,a,r,i){if(!s)return;const o=this.frames,l=this.frames.length;if(e>n)this.apply(t,e,Number.MAX_VALUE,s,a,r,i),e=-1;else if(e>=o[l-1])return;if(n<o[0])return;let h=0;if(e<o[0])h=0;else{h=Vs.search1(o,e)+1;const t=o[h];for(;h>0&&o[h-1]==t;)h--}for(;h<l&&n>=o[h];h++)s.push(this.events[h])}};let Ks=Qs;Ks.propertyIds=[`${Ss}`];const Js=class extends Vs{constructor(t){super(t,Js.propertyIds),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.drawOrders[t]=n}apply(t,e,n,s,a,r,i){if(i==I.mixOut)return void(r==A.setup&&j.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length));if(n<this.frames[0])return void(r!=A.setup&&r!=A.first||j.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length));const o=Vs.search1(this.frames,n),l=this.drawOrders[o];if(l){const e=t.drawOrder,n=t.slots;for(let t=0,s=l.length;t<s;t++)e[t]=n[l[t]]}else j.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length)}};let ta=Js;ta.propertyIds=[`${Ms}`];class ea extends vs{constructor(t,e,n){super(t,e,[`${As}|${n}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=n}getFrameEntries(){return 6}setFrame(t,e,n,s,a,r,i){t*=6,this.frames[t]=e,this.frames[t+1]=n,this.frames[t+2]=s,this.frames[t+3]=a,this.frames[t+4]=r?1:0,this.frames[t+5]=i?1:0}apply(t,e,n,s,a,r,i){const o=t.ikConstraints[this.ikConstraintIndex];if(!o.active)return;const l=this.frames;if(n<l[0]){switch(r){case A.setup:return o.mix=o.data.mix,o.softness=o.data.softness,o.bendDirection=o.data.bendDirection,o.compress=o.data.compress,void(o.stretch=o.data.stretch);case A.first:o.mix+=(o.data.mix-o.mix)*a,o.softness+=(o.data.softness-o.softness)*a,o.bendDirection=o.data.bendDirection,o.compress=o.data.compress,o.stretch=o.data.stretch}return}let h=0,c=0;const d=Vs.search(l,n,6),u=this.curves[d/6];switch(u){case 0:const t=l[d];h=l[d+1],c=l[d+2];const e=(n-t)/(l[d+6]-t);h+=(l[d+6+1]-h)*e,c+=(l[d+6+2]-c)*e;break;case 1:h=l[d+1],c=l[d+2];break;default:h=this.getBezierValue(n,d,1,u-2),c=this.getBezierValue(n,d,2,u+18-2)}r==A.setup?(o.mix=o.data.mix+(h-o.data.mix)*a,o.softness=o.data.softness+(c-o.data.softness)*a,i==I.mixOut?(o.bendDirection=o.data.bendDirection,o.compress=o.data.compress,o.stretch=o.data.stretch):(o.bendDirection=l[d+3],o.compress=0!=l[d+4],o.stretch=0!=l[d+5])):(o.mix+=(h-o.mix)*a,o.softness+=(c-o.softness)*a,i==I.mixIn&&(o.bendDirection=l[d+3],o.compress=0!=l[d+4],o.stretch=0!=l[d+5]))}}class na extends vs{constructor(t,e,n){super(t,e,[`${Is}|${n}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=n}getFrameEntries(){return 7}setFrame(t,e,n,s,a,r,i,o){const l=this.frames;l[t*=7]=e,l[t+1]=n,l[t+2]=s,l[t+3]=a,l[t+4]=r,l[t+5]=i,l[t+6]=o}apply(t,e,n,s,a,r,i){const o=t.transformConstraints[this.transformConstraintIndex];if(!o.active)return;const l=this.frames;if(n<l[0]){const t=o.data;switch(r){case A.setup:return o.mixRotate=t.mixRotate,o.mixX=t.mixX,o.mixY=t.mixY,o.mixScaleX=t.mixScaleX,o.mixScaleY=t.mixScaleY,void(o.mixShearY=t.mixShearY);case A.first:o.mixRotate+=(t.mixRotate-o.mixRotate)*a,o.mixX+=(t.mixX-o.mixX)*a,o.mixY+=(t.mixY-o.mixY)*a,o.mixScaleX+=(t.mixScaleX-o.mixScaleX)*a,o.mixScaleY+=(t.mixScaleY-o.mixScaleY)*a,o.mixShearY+=(t.mixShearY-o.mixShearY)*a}return}let h,c,d,u,m,f;const g=Vs.search(l,n,7),p=this.curves[g/7];switch(p){case 0:const t=l[g];h=l[g+1],c=l[g+2],d=l[g+3],u=l[g+4],m=l[g+5],f=l[g+6];const e=(n-t)/(l[g+7]-t);h+=(l[g+7+1]-h)*e,c+=(l[g+7+2]-c)*e,d+=(l[g+7+3]-d)*e,u+=(l[g+7+4]-u)*e,m+=(l[g+7+5]-m)*e,f+=(l[g+7+6]-f)*e;break;case 1:h=l[g+1],c=l[g+2],d=l[g+3],u=l[g+4],m=l[g+5],f=l[g+6];break;default:h=this.getBezierValue(n,g,1,p-2),c=this.getBezierValue(n,g,2,p+18-2),d=this.getBezierValue(n,g,3,p+36-2),u=this.getBezierValue(n,g,4,p+54-2),m=this.getBezierValue(n,g,5,p+72-2),f=this.getBezierValue(n,g,6,p+90-2)}if(r==A.setup){const t=o.data;o.mixRotate=t.mixRotate+(h-t.mixRotate)*a,o.mixX=t.mixX+(c-t.mixX)*a,o.mixY=t.mixY+(d-t.mixY)*a,o.mixScaleX=t.mixScaleX+(u-t.mixScaleX)*a,o.mixScaleY=t.mixScaleY+(m-t.mixScaleY)*a,o.mixShearY=t.mixShearY+(f-t.mixShearY)*a}else o.mixRotate+=(h-o.mixRotate)*a,o.mixX+=(c-o.mixX)*a,o.mixY+=(d-o.mixY)*a,o.mixScaleX+=(u-o.mixScaleX)*a,o.mixScaleY+=(m-o.mixScaleY)*a,o.mixShearY+=(f-o.mixShearY)*a}}class sa extends Ps{constructor(t,e,n){super(t,e,`${Ts}|${n}`),this.pathConstraintIndex=0,this.pathConstraintIndex=n}apply(t,e,n,s,a,r,i){const o=t.pathConstraints[this.pathConstraintIndex];if(!o.active)return;if(n<this.frames[0]){switch(r){case A.setup:return void(o.position=o.data.position);case A.first:o.position+=(o.data.position-o.position)*a}return}const l=this.getCurveValue(n);r==A.setup?o.position=o.data.position+(l-o.data.position)*a:o.position+=(l-o.position)*a}}class aa extends Ps{constructor(t,e,n){super(t,e,`${ks}|${n}`),this.pathConstraintIndex=0,this.pathConstraintIndex=n}apply(t,e,n,s,a,r,i){const o=t.pathConstraints[this.pathConstraintIndex];if(!o.active)return;if(n<this.frames[0]){switch(r){case A.setup:return void(o.spacing=o.data.spacing);case A.first:o.spacing+=(o.data.spacing-o.spacing)*a}return}const l=this.getCurveValue(n);r==A.setup?o.spacing=o.data.spacing+(l-o.data.spacing)*a:o.spacing+=(l-o.spacing)*a}}class ra extends vs{constructor(t,e,n){super(t,e,[`${Rs}|${n}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=n}getFrameEntries(){return 4}setFrame(t,e,n,s,a){const r=this.frames;r[t<<=2]=e,r[t+1]=n,r[t+2]=s,r[t+3]=a}apply(t,e,n,s,a,r,i){const o=t.pathConstraints[this.pathConstraintIndex];if(!o.active)return;const l=this.frames;if(n<l[0]){switch(r){case A.setup:return o.mixRotate=o.data.mixRotate,o.mixX=o.data.mixX,void(o.mixY=o.data.mixY);case A.first:o.mixRotate+=(o.data.mixRotate-o.mixRotate)*a,o.mixX+=(o.data.mixX-o.mixX)*a,o.mixY+=(o.data.mixY-o.mixY)*a}return}let h,c,d;const u=Vs.search(l,n,4),m=this.curves[u>>2];switch(m){case 0:const t=l[u];h=l[u+1],c=l[u+2],d=l[u+3];const e=(n-t)/(l[u+4]-t);h+=(l[u+4+1]-h)*e,c+=(l[u+4+2]-c)*e,d+=(l[u+4+3]-d)*e;break;case 1:h=l[u+1],c=l[u+2],d=l[u+3];break;default:h=this.getBezierValue(n,u,1,m-2),c=this.getBezierValue(n,u,2,m+18-2),d=this.getBezierValue(n,u,3,m+36-2)}if(r==A.setup){const t=o.data;o.mixRotate=t.mixRotate+(h-t.mixRotate)*a,o.mixX=t.mixX+(c-t.mixX)*a,o.mixY=t.mixY+(d-t.mixY)*a}else o.mixRotate+=(h-o.mixRotate)*a,o.mixX+=(c-o.mixX)*a,o.mixY+=(d-o.mixY)*a}}const ia=class extends Vs{constructor(t,e,n){super(t,[`${Cs}|${e}|${n.sequence.id}`]),this.slotIndex=e,this.attachment=n}getFrameEntries(){return ia.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(t,e,n,s,a){const r=this.frames;r[t*=ia.ENTRIES]=e,r[t+ia.MODE]=n|s<<4,r[t+ia.DELAY]=a}apply(t,e,n,s,a,r,i){const o=t.slots[this.slotIndex];if(!o.bone.active)return;const l=o.attachment,h=this.attachment;if(!(l==h||l instanceof Qn&&l.timelineAttachment==h))return;const c=this.frames;if(n<c[0])return void(r!=A.setup&&r!=A.first||(o.sequenceIndex=-1));const d=Vs.search(c,n,ia.ENTRIES),u=c[d],m=c[d+ia.MODE],f=c[d+ia.DELAY];if(!this.attachment.sequence)return;let g=m>>4;const p=this.attachment.sequence.regions.length,x=ls[15&m];if(x!=os.hold)switch(g+=(n-u)/f+1e-5|0,x){case os.once:g=Math.min(p-1,g);break;case os.loop:g%=p;break;case os.pingpong:{const t=(p<<1)-2;g=0==t?0:g%t,g>=p&&(g=t-g);break}case os.onceReverse:g=Math.max(p-1-g,0);break;case os.loopReverse:g=p-1-g%p;break;case os.pingpongReverse:{const t=(p<<1)-2;g=0==t?0:(g+p-1)%t,g>=p&&(g=t-g)}}o.sequenceIndex=g}};let oa=ia;oa.ENTRIES=3,oa.MODE=1,oa.DELAY=2;const la=class{constructor(t){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new ua(this),this.propertyIDs=new L,this.animationsChanged=!1,this.trackEntryPool=new G((()=>new da)),this.data=t}static emptyAnimation(){return la._emptyAnimation}update(t){t*=this.timeScale;const e=this.tracks;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(!s)continue;s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast;let a=t*s.timeScale;if(s.delay>0){if(s.delay-=a,s.delay>0)continue;a=-s.delay,s.delay=0}let r=s.next;if(r){const e=s.trackLast-r.delay;if(e>=0){for(r.delay=0,r.trackTime+=0==s.timeScale?0:(e/s.timeScale+t)*r.timeScale,s.trackTime+=a,this.setCurrent(n,r,!0);r.mixingFrom;)r.mixTime+=t,r=r.mixingFrom;continue}}else if(s.trackLast>=s.trackEnd&&!s.mixingFrom){e[n]=null,this.queue.end(s),this.clearNext(s);continue}if(s.mixingFrom&&this.updateMixingFrom(s,t)){let t=s.mixingFrom;for(s.mixingFrom=null,t&&(t.mixingTo=null);t;)this.queue.end(t),t=t.mixingFrom}s.trackTime+=a}this.queue.drain()}updateMixingFrom(t,e){const n=t.mixingFrom;if(!n)return!0;const s=this.updateMixingFrom(n,e);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?(0!=n.totalAlpha&&0!=t.mixDuration||(t.mixingFrom=n.mixingFrom,n.mixingFrom&&(n.mixingFrom.mixingTo=t),t.interruptAlpha=n.interruptAlpha,this.queue.end(n)),s):(n.trackTime+=e*n.timeScale,t.mixTime+=e,!1)}apply(t){if(!t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,n=this.tracks;let s=!1;for(let i=0,o=n.length;i<o;i++){const a=n[i];if(!a||a.delay>0)continue;s=!0;const r=0==i?A.first:a.mixBlend;let o=a.alpha;a.mixingFrom?o*=this.applyMixingFrom(a,t,r):a.trackTime>=a.trackEnd&&!a.next&&(o=0);const l=a.animationLast,h=a.getAnimationTime();let c=h,d=e;a.reverse&&(c=a.animation.duration-c,d=null);const u=a.animation.timelines,m=u.length;if(0==i&&1==o||r==A.add)for(let e=0;e<m;e++){const n=u[e];n instanceof Gs?this.applyAttachmentTimeline(n,t,c,r,!0):n.apply(t,l,c,d,o,r,I.mixIn)}else{const e=a.timelineMode,n=a.shortestRotation,s=!n&&a.timelinesRotation.length!=m<<1;s&&(a.timelinesRotation.length=m<<1);for(let i=0;i<m;i++){const h=u[i],m=e[i]==fa?r:A.setup;!n&&h instanceof Ys?this.applyRotateTimeline(h,t,c,o,m,a.timelinesRotation,i<<1,s):h instanceof Gs?this.applyAttachmentTimeline(h,t,c,r,!0):h.apply(t,l,c,d,o,m,I.mixIn)}}this.queueEvents(a,h),e.length=0,a.nextAnimationLast=h,a.nextTrackLast=a.trackTime}const a=this.unkeyedState+ba,r=t.slots;for(let i=0,o=t.slots.length;i<o;i++){const e=r[i];if(e.attachmentState==a){const n=e.data.attachmentName;e.setAttachment(n?t.getAttachment(e.data.index,n):null)}}return this.unkeyedState+=2,this.queue.drain(),s}applyMixingFrom(t,e,n){const s=t.mixingFrom;s.mixingFrom&&this.applyMixingFrom(s,e,n);let a=0;0==t.mixDuration?(a=1,n==A.first&&(n=A.setup)):(a=t.mixTime/t.mixDuration,a>1&&(a=1),n!=A.first&&(n=s.mixBlend));const r=a<s.attachmentThreshold,i=a<s.drawOrderThreshold,o=s.animation.timelines,l=o.length,h=s.alpha*t.interruptAlpha,c=h*(1-a),d=s.animationLast,u=s.getAnimationTime();let m=u,f=null;if(s.reverse?m=s.animation.duration-m:a<s.eventThreshold&&(f=this.events),n==A.add)for(let g=0;g<l;g++)o[g].apply(e,d,m,f,c,n,I.mixOut);else{const t=s.timelineMode,a=s.timelineHoldMix,u=s.shortestRotation,g=!u&&s.timelinesRotation.length!=l<<1;g&&(s.timelinesRotation.length=l<<1),s.totalAlpha=0;for(let p=0;p<l;p++){const l=o[p];let x,w=I.mixOut,b=0;switch(t[p]){case fa:if(!i&&l instanceof ta)continue;x=n,b=c;break;case ga:x=A.setup,b=c;break;case pa:x=n,b=h;break;case xa:x=A.setup,b=h;break;default:x=A.setup;const t=a[p];b=h*Math.max(0,1-t.mixTime/t.mixDuration)}s.totalAlpha+=b,!u&&l instanceof Ys?this.applyRotateTimeline(l,e,m,b,x,s.timelinesRotation,p<<1,g):l instanceof Gs?this.applyAttachmentTimeline(l,e,m,x,r):(i&&l instanceof ta&&x==A.setup&&(w=I.mixIn),l.apply(e,d,m,f,b,x,w))}}return t.mixDuration>0&&this.queueEvents(s,u),this.events.length=0,s.nextAnimationLast=u,s.nextTrackLast=s.trackTime,a}applyAttachmentTimeline(t,e,n,s,a){const r=e.slots[t.slotIndex];r.bone.active&&(n<t.frames[0]?s!=A.setup&&s!=A.first||this.setAttachment(e,r,r.data.attachmentName,a):this.setAttachment(e,r,t.attachmentNames[Vs.search1(t.frames,n)],a),r.attachmentState<=this.unkeyedState&&(r.attachmentState=this.unkeyedState+ba))}setAttachment(t,e,n,s){e.setAttachment(n?t.getAttachment(e.data.index,n):null),s&&(e.attachmentState=this.unkeyedState+Ea)}applyRotateTimeline(t,e,n,s,a,r,i,o){if(o&&(r[i]=0),1==s)return void t.apply(e,0,n,null,1,a,I.mixIn);const l=e.bones[t.boneIndex];if(!l.active)return;let h=0,c=0;if(n<t.frames[0])switch(a){case A.setup:l.rotation=l.data.rotation;default:return;case A.first:h=l.rotation,c=l.data.rotation}else h=a==A.setup?l.data.rotation:l.rotation,c=l.data.rotation+t.getCurveValue(n);let d=0,u=c-h;if(u-=360*(16384-(16384.499999999996-u/360|0)),0==u)d=r[i];else{let t=0,e=0;o?(t=0,e=u):(t=r[i],e=r[i+1]);const n=u>0;let s=t>=0;q.signum(e)!=q.signum(u)&&Math.abs(e)<=90&&(Math.abs(t)>180&&(t+=360*q.signum(t)),s=n),d=u+t-t%360,s!=n&&(d+=360*q.signum(t)),r[i]=d}r[i+1]=u,l.rotation=h+d*s}queueEvents(t,e){const n=t.animationStart,s=t.animationEnd,a=s-n,r=t.trackLast%a,i=this.events;let o=0;const l=i.length;for(;o<l;o++){const e=i[o];if(e.time<r)break;e.time>s||this.queue.event(t,e)}let h=!1;for(h=t.loop?0==a||r>t.trackTime%a:e>=s&&t.animationLast<s,h&&this.queue.complete(t);o<l;o++){const e=i[o];e.time<n||this.queue.event(t,e)}}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,n=this.tracks.length;e<n;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(!e)return;this.queue.end(e),this.clearNext(e);let n=e;for(;;){const t=n.mixingFrom;if(!t)break;this.queue.end(t),n.mixingFrom=null,n.mixingTo=null,n=t}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,n){const s=this.expandToIndex(t);this.tracks[t]=e,e.previous=null,s&&(n&&this.queue.interrupt(s),e.mixingFrom=s,s.mixingTo=e,e.mixTime=0,s.mixingFrom&&s.mixDuration>0&&(e.interruptAlpha*=Math.min(1,s.mixTime/s.mixDuration)),s.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,n=!1){const s=this.data.skeletonData.findAnimation(e);if(!s)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,s,n)}setAnimationWith(t,e,n=!1){if(!e)throw new Error("animation cannot be null.");let s=!0,a=this.expandToIndex(t);a&&(-1==a.nextTrackLast?(this.tracks[t]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.clearNext(a),a=a.mixingFrom,s=!1):this.clearNext(a));const r=this.trackEntry(t,e,n,a);return this.setCurrent(t,r,s),this.queue.drain(),r}addAnimation(t,e,n=!1,s=0){const a=this.data.skeletonData.findAnimation(e);if(!a)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,a,n,s)}addAnimationWith(t,e,n=!1,s=0){if(!e)throw new Error("animation cannot be null.");let a=this.expandToIndex(t);if(a)for(;a.next;)a=a.next;const r=this.trackEntry(t,e,n,a);return a?(a.next=r,r.previous=a,s<=0&&(s+=a.getTrackComplete()-r.mixDuration)):(this.setCurrent(t,r,!0),this.queue.drain()),r.delay=s,r}setEmptyAnimation(t,e=0){const n=this.setAnimationWith(t,la.emptyAnimation(),!1);return n.mixDuration=e,n.trackEnd=e,n}addEmptyAnimation(t,e=0,n=0){const s=this.addAnimationWith(t,la.emptyAnimation(),!1,n);return n<=0&&(s.delay+=s.mixDuration-e),s.mixDuration=e,s.trackEnd=e,s}setEmptyAnimations(t=0){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,s=this.tracks.length;n<s;n++){const e=this.tracks[n];e&&this.setEmptyAnimation(e.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(j.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,n,s){const a=this.trackEntryPool.obtain();return a.reset(),a.trackIndex=t,a.animation=e,a.loop=n,a.holdPrevious=!1,a.reverse=!1,a.shortestRotation=!1,a.eventThreshold=0,a.attachmentThreshold=0,a.drawOrderThreshold=0,a.animationStart=0,a.animationEnd=e.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.mixTime=0,a.mixDuration=s?this.data.getMix(s.animation,e):0,a.interruptAlpha=1,a.totalAlpha=0,a.mixBlend=A.replace,a}clearNext(t){let e=t.next;for(;e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const t=this.tracks;for(let e=0,n=t.length;e<n;e++){let n=t[e];if(n){for(;n.mixingFrom;)n=n.mixingFrom;do{n.mixingTo&&n.mixBlend==A.add||this.computeHold(n),n=n.mixingTo}while(n)}}}computeHold(t){const e=t.mixingTo,n=t.animation.timelines,s=t.animation.timelines.length,a=t.timelineMode;a.length=s;const r=t.timelineHoldMix;r.length=0;const i=this.propertyIDs;if(e&&e.holdPrevious)for(let o=0;o<s;o++)a[o]=i.addAll(n[o].getPropertyIds())?xa:pa;else t:for(let o=0;o<s;o++){const s=n[o],l=s.getPropertyIds();if(i.addAll(l))if(!e||s instanceof Gs||s instanceof ta||s instanceof Ks||!e.animation.hasTimeline(l))a[o]=ga;else{for(let n=e.mixingTo;n;n=n.mixingTo)if(!n.animation.hasTimeline(l)){if(t.mixDuration>0){a[o]=wa,r[o]=n;continue t}break}a[o]=xa}else a[o]=fa}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(!t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,n){la.deprecatedWarning1||(la.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,n)}addAnimationByName(t,e,n,s){la.deprecatedWarning2||(la.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,n,s)}hasAnimation(t){return null!==this.data.skeletonData.findAnimation(t)}hasAnimationByName(t){return la.deprecatedWarning3||(la.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};let ha=la;ha._emptyAnimation=new hs("<empty>",[],0),ha.deprecatedWarning1=!1,ha.deprecatedWarning2=!1,ha.deprecatedWarning3=!1;const ca=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.shortestRotation=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=A.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return 0==t?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(0!=t){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return ca.deprecatedWarning1||(ca.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){ca.deprecatedWarning1||(ca.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return ca.deprecatedWarning2||(ca.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){ca.deprecatedWarning2||(ca.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let da=ca;da.deprecatedWarning1=!1,da.deprecatedWarning2=!1;class ua{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(ma.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(ma.interrupt),this.objects.push(t)}end(t){this.objects.push(ma.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(ma.dispose),this.objects.push(t)}complete(t){this.objects.push(ma.complete),this.objects.push(t)}event(t,e){this.objects.push(ma.event),this.objects.push(t),this.objects.push(e)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let n=0;n<t.length;n+=2){const s=t[n],a=t[n+1];switch(s){case ma.start:a.listener&&a.listener.start&&a.listener.start(a);for(let t=0;t<e.length;t++){const n=e[t];n.start&&n.start(a)}break;case ma.interrupt:a.listener&&a.listener.interrupt&&a.listener.interrupt(a);for(let t=0;t<e.length;t++){const n=e[t];n.interrupt&&n.interrupt(a)}break;case ma.end:a.listener&&a.listener.end&&a.listener.end(a);for(let t=0;t<e.length;t++){const n=e[t];n.end&&n.end(a)}case ma.dispose:a.listener&&a.listener.dispose&&a.listener.dispose(a);for(let t=0;t<e.length;t++){const n=e[t];n.dispose&&n.dispose(a)}this.animState.trackEntryPool.free(a);break;case ma.complete:a.listener&&a.listener.complete&&a.listener.complete(a);for(let t=0;t<e.length;t++){const n=e[t];n.complete&&n.complete(a)}break;case ma.event:const s=t[2+n++];a.listener&&a.listener.event&&a.listener.event(a,s);for(let t=0;t<e.length;t++){const n=e[t];n.event&&n.event(a,s)}}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var ma=(t=>(t[t.start=0]="start",t[t.interrupt=1]="interrupt",t[t.end=2]="end",t[t.dispose=3]="dispose",t[t.complete=4]="complete",t[t.event=5]="event",t))(ma||{});const fa=0,ga=1,pa=2,xa=3,wa=4,ba=1,Ea=2;class ya{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,n){const s=this.skeletonData.findAnimation(t);if(!s)throw new Error(`Animation not found: ${t}`);const a=this.skeletonData.findAnimation(e);if(!a)throw new Error(`Animation not found: ${e}`);this.setMixWith(s,a,n)}setMixWith(t,e,n){if(!t)throw new Error("from cannot be null.");if(!e)throw new Error("to cannot be null.");const s=`${t.name}.${e.name}`;this.animationToMixTime[s]=n}getMix(t,e){const n=`${t.name}.${e.name}`,s=this.animationToMixTime[n];return void 0===s?this.defaultMix:s}}class Sa{constructor(t){this.atlas=t}loadSequence(t,e,n){const s=n.regions;for(let a=0,r=s.length;a<r;a++){const r=n.getPath(e,a),i=this.atlas.findRegion(r);if(null==i)throw new Error(`Region not found in atlas: ${r} (sequence: ${t})`);s[a]=i,s[a].renderObject=s[a]}}newRegionAttachment(t,e,n,s){const a=new as(e,n);if(null!=s)this.loadSequence(e,n,s);else{const t=this.atlas.findRegion(n);if(!t)throw new Error(`Region not found in atlas: ${n} (region attachment: ${e})`);t.renderObject=t,a.region=t}return a}newMeshAttachment(t,e,n,s){const a=new ts(e,n);if(null!=s)this.loadSequence(e,n,s);else{const t=this.atlas.findRegion(n);if(!t)throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${e})`);t.renderObject=t,a.region=t}return a}newBoundingBoxAttachment(t,e){return new Kn(e)}newPathAttachment(t,e){return new es(e)}newPointAttachment(t,e){return new ns(e)}newClippingAttachment(t,e){return new Jn(e)}}class Ma{constructor(t,e,n){if(this.matrix=new E,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=n,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,n,s,a,r,i){this.ax=t,this.ay=e,this.arotation=n,this.ascaleX=s,this.ascaleY=a,this.ashearX=r,this.ashearY=i;const o=this.parent,l=this.matrix,h=this.skeleton.scaleX,c=-this.skeleton.scaleY;if(!o){const o=this.skeleton,d=n+90+i;return l.a=q.cosDeg(n+r)*s*h,l.c=q.cosDeg(d)*a*h,l.b=q.sinDeg(n+r)*s*c,l.d=q.sinDeg(d)*a*c,l.tx=t*h+o.x,void(l.ty=e*c+o.y)}let d=o.matrix.a,u=o.matrix.c,m=o.matrix.b,f=o.matrix.d;switch(l.tx=d*t+u*e+o.matrix.tx,l.ty=m*t+f*e+o.matrix.ty,this.data.transformMode){case R.Normal:{const t=n+90+i,e=q.cosDeg(n+r)*s,o=q.cosDeg(t)*a,h=q.sinDeg(n+r)*s,c=q.sinDeg(t)*a;return l.a=d*e+u*h,l.c=d*o+u*c,l.b=m*e+f*h,void(l.d=m*o+f*c)}case R.OnlyTranslation:{const t=n+90+i;l.a=q.cosDeg(n+r)*s,l.c=q.cosDeg(t)*a,l.b=q.sinDeg(n+r)*s,l.d=q.sinDeg(t)*a;break}case R.NoRotationOrReflection:{let t=d*d+m*m,e=0;t>1e-4?(t=Math.abs(d*f-u*m)/t,d/=h,m/=c,u=m*t,f=d*t,e=Math.atan2(m,d)*q.radDeg):(d=0,m=0,e=90-Math.atan2(f,u)*q.radDeg);const o=n+r-e,g=n+i-e+90,p=q.cosDeg(o)*s,x=q.cosDeg(g)*a,w=q.sinDeg(o)*s,b=q.sinDeg(g)*a;l.a=d*p-u*w,l.c=d*x-u*b,l.b=m*p+f*w,l.d=m*x+f*b;break}case R.NoScale:case R.NoScaleOrReflection:{const t=q.cosDeg(n),e=q.sinDeg(n);let o=(d*t+u*e)/h,g=(m*t+f*e)/c,p=Math.sqrt(o*o+g*g);p>1e-5&&(p=1/p),o*=p,g*=p,p=Math.sqrt(o*o+g*g),this.data.transformMode==R.NoScale&&d*f-u*m<0!=(h<0!=c<0)&&(p=-p);const x=Math.PI/2+Math.atan2(g,o),w=Math.cos(x)*p,b=Math.sin(x)*p,E=q.cosDeg(r)*s,y=q.cosDeg(90+i)*a,S=q.sinDeg(r)*s,M=q.sinDeg(90+i)*a;l.a=o*E+w*S,l.c=o*y+w*M,l.b=g*E+b*S,l.d=g*y+b*M;break}}l.a*=h,l.c*=h,l.b*=c,l.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*q.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*q.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,e=this.matrix;if(!t)return this.ax=e.tx-this.skeleton.x,this.ay=e.ty-this.skeleton.y,this.arotation=Math.atan2(e.b,e.a)*q.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,void(this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*q.radDeg);const n=t.matrix,s=1/(n.a*n.d-n.b*n.c),a=e.tx-n.tx,r=e.ty-n.ty;this.ax=a*n.d*s-r*n.c*s,this.ay=r*n.a*s-a*n.b*s;const i=s*n.d,o=s*n.a,l=s*n.c,h=s*n.b,c=i*e.a-l*e.b,d=i*e.c-l*e.d,u=o*e.b-h*e.a,m=o*e.d-h*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+u*u),this.ascaleX>1e-4){const t=c*m-d*u;this.ascaleY=t/this.ascaleX,this.ashearY=Math.atan2(c*d+u*m,t)*q.radDeg,this.arotation=Math.atan2(u,c)*q.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(d*d+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,d)*q.radDeg}worldToLocal(t){const e=this.matrix,n=e.a,s=e.c,a=e.b,r=e.d,i=1/(n*r-s*a),o=t.x-e.tx,l=t.y-e.ty;return t.x=o*r*i-l*s*i,t.y=l*n*i-o*a*i,t}localToWorld(t){const e=this.matrix,n=t.x,s=t.y;return t.x=n*e.a+s*e.c+e.tx,t.y=n*e.b+s*e.d+e.ty,t}worldToLocalRotation(t){const e=q.sinDeg(t),n=q.cosDeg(t),s=this.matrix;return Math.atan2(s.a*e-s.b*n,s.d*n-s.c*e)*q.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const e=q.sinDeg(t),n=q.cosDeg(t),s=this.matrix;return Math.atan2(n*s.b+e*s.d,n*s.a+e*s.c)*q.radDeg}rotateWorld(t){const e=this.matrix,n=e.a,s=e.c,a=e.b,r=e.d,i=q.cosDeg(t),o=q.sinDeg(t);e.a=i*n-o*a,e.c=i*s-o*r,e.b=o*n+i*a,e.d=o*s+i*r}}class Aa{constructor(t,e,n){if(this.index=0,this.parent=null,this.length=0,this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=R.Normal,this.skinRequired=!1,this.color=new O,t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=n}}class Ia{constructor(t,e,n){this.name=t,this.order=e,this.skinRequired=n}}class Ta{constructor(t,e){if(this.intValue=0,this.floatValue=0,this.stringValue=null,this.time=0,this.volume=0,this.balance=0,!e)throw new Error("data cannot be null.");this.time=t,this.data=e}}class ka{constructor(t){this.intValue=0,this.floatValue=0,this.stringValue=null,this.audioPath=null,this.volume=0,this.balance=0,this.name=t}}class Ra{constructor(t,e){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++){const n=e.findBone(t.bones[s].name);if(!n)throw new Error(`Couldn't find bone ${t.bones[s].name}`);this.bones.push(n)}const n=e.findBone(t.target.name);if(!n)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=n}isActive(){return this.active}update(){if(0==this.mix)return;const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix)}}apply1(t,e,n,s,a,r,i){const o=t.parent.matrix;if(!o)throw new Error("IK bone must have parent.");const l=o.a;let h=o.c;const c=o.b;let d=o.d,u=-t.ashearX-t.arotation,m=0,f=0;const g=t.skeleton.scaleX,p=-t.skeleton.scaleY;switch(t.data.transformMode){case R.OnlyTranslation:m=e-t.worldX,f=n-t.worldY,f=-f;break;case R.NoRotationOrReflection:const s=Math.abs(l*d-h*c)/(l*l+c*c),a=l/g,r=c/p;h=-r*s*g,d=a*s*p,u+=Math.atan2(r,a)*q.radDeg;default:const i=e-o.tx,x=n-o.ty,w=l*d-h*c;m=(i*d-x*h)/w-t.ax,f=(x*l-i*c)/w-t.ay}u+=Math.atan2(f,m)*q.radDeg,t.ascaleX<0&&(u+=180),u>180?u-=360:u<-180&&(u+=360);let x=t.ascaleX,w=t.ascaleY;if(s||a){switch(t.data.transformMode){case R.NoScale:case R.NoScaleOrReflection:m=e-t.worldX,f=n-t.worldY}const o=t.data.length*x,l=Math.sqrt(m*m+f*f);if(s&&l<o||a&&l>o&&o>1e-4){const t=(l/o-1)*i+1;x*=t,r&&(w*=t)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*i,x,w,t.ashearX,t.ashearY)}apply2(t,e,n,s,a,r,i,o,l){const h=t.ax,c=t.ay;let d=t.ascaleX,u=t.ascaleY,m=d,f=u,g=e.ascaleX;const p=t.matrix;let x=0,w=0,b=0;d<0?(d=-d,x=180,b=-1):(x=0,b=1),u<0&&(u=-u,b=-b),g<0?(g=-g,w=180):w=0;const E=e.ax;let y=0,S=0,M=0,A=p.a,I=p.c,T=p.b,k=p.d;const R=Math.abs(d-u)<=1e-4;!R||r?(y=0,S=A*E+p.tx,M=T*E+p.ty):(y=e.ay,S=A*E+I*y+p.tx,M=T*E+k*y+p.ty);const C=t.parent.matrix;if(!C)throw new Error("IK parent must itself have a parent.");A=C.a,I=C.c,T=C.b,k=C.d;const V=1/(A*k-I*T);let v=S-C.tx,P=M-C.ty;const F=(v*k-P*I)*V-h,Y=(P*A-v*T)*V-c,N=Math.sqrt(F*F+Y*Y);let X,D,B=e.data.length*g;if(N<1e-4)return this.apply1(t,n,s,!1,r,!1,l),void e.updateWorldTransformWith(E,y,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);v=n-C.tx,P=s-C.ty;let L=(v*k-P*I)*V-h,_=(P*A-v*T)*V-c,O=L*L+_*_;if(0!=o){o*=d*(g+1)*.5;const t=Math.sqrt(O),e=t-N-B*d+o;if(e>0){let n=Math.min(1,e/(2*o))-1;n=(e-o*(1-n*n))/t,L-=n*L,_-=n*_,O=L*L+_*_}}t:if(R){B*=d;let t=(O-N*N-B*B)/(2*N*B);t<-1?(t=-1,D=Math.PI*a):t>1?(t=1,D=0,r&&(A=(Math.sqrt(O)/(N+B)-1)*l+1,m*=A,i&&(f*=A))):D=Math.acos(t)*a,A=N+B*t,I=B*Math.sin(D),X=Math.atan2(_*A-L*I,L*A+_*I)}else{A=d*B,I=u*B;const t=A*A,e=I*I,n=Math.atan2(_,L);T=e*N*N+t*O-t*e;const s=-2*e*N,r=e-t;if(k=s*s-4*r*T,k>=0){let t=Math.sqrt(k);s<0&&(t=-t),t=.5*-(s+t);const e=t/r,i=T/t,o=Math.abs(e)<Math.abs(i)?e:i;if(o*o<=O){P=Math.sqrt(O-o*o)*a,X=n-Math.atan2(P,o),D=Math.atan2(P/u,(o-N)/d);break t}}let i=q.PI,o=N-A,l=o*o,h=0,c=0,m=N+A,f=m*m,g=0;T=-A*N/(t-e),T>=-1&&T<=1&&(T=Math.acos(T),v=A*Math.cos(T)+N,P=I*Math.sin(T),k=v*v+P*P,k<l&&(i=T,l=k,o=v,h=P),k>f&&(c=T,f=k,m=v,g=P)),O<=.5*(l+f)?(X=n-Math.atan2(h*a,o),D=i*a):(X=n-Math.atan2(g*a,m),D=c*a)}const W=Math.atan2(y,E)*b;let $=t.arotation;X=(X-W)*q.radDeg+x-$,X>180?X-=360:X<-180&&(X+=360),t.updateWorldTransformWith(h,c,$+X*l,m,f,0,0),$=e.arotation,D=((D+W)*q.radDeg-e.ashearX)*b+w-$,D>180?D-=360:D<-180&&(D+=360),e.updateWorldTransformWith(E,y,$+D*l,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}}class Ca extends Ia{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class Va extends Ia{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.positionMode=T.Fixed,this.spacingMode=va.Fixed,this.rotateMode=k.Chain,this.offsetRotation=0,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var va=(t=>(t[t.Length=0]="Length",t[t.Fixed=1]="Fixed",t[t.Percent=2]="Percent",t[t.Proportional=3]="Proportional",t))(va||{});const Pa=class{constructor(t,e){if(this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let s=0,a=t.bones.length;s<a;s++){const n=e.findBone(t.bones[s].name);if(!n)throw new Error(`Couldn't find bone ${t.bones[s].name}.`);this.bones.push(n)}const n=e.findSlot(t.target.name);if(!n)throw new Error(`Couldn't find target bone ${t.target.name}`);this.target=n,this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}isActive(){return this.active}update(){const t=this.target.getAttachment();if(!(t instanceof es))return;const e=this.mixRotate,n=this.mixX,s=this.mixY;if(0==e&&0==n&&0==s)return;const a=this.data,r=a.rotateMode==k.Tangent,i=a.rotateMode==k.ChainScale,o=this.bones,l=o.length,h=r?l:l+1,c=j.setArraySize(this.spaces,h),d=i?this.lengths=j.setArraySize(this.lengths,l):[],u=this.spacing;switch(a.spacingMode){case va.Percent:if(i)for(let n=0,s=h-1;n<s;n++){const t=o[n],e=t.data.length;if(e<Pa.epsilon)d[n]=0;else{const s=e*t.matrix.a,a=e*t.matrix.b;d[n]=Math.sqrt(s*s+a*a)}}j.arrayFill(c,1,h,u);break;case va.Proportional:let t=0;for(let n=0,s=h-1;n<s;){const e=o[n],s=e.data.length;if(s<Pa.epsilon)i&&(d[n]=0),c[++n]=u;else{const a=s*e.matrix.a,r=s*e.matrix.b,o=Math.sqrt(a*a+r*r);i&&(d[n]=o),c[++n]=o,t+=o}}if(t>0){t=h/t*u;for(let e=1;e<h;e++)c[e]*=t}break;default:const e=a.spacingMode==va.Length;for(let n=0,s=h-1;n<s;){const t=o[n],s=t.data.length;if(s<Pa.epsilon)i&&(d[n]=0),c[++n]=u;else{const a=s*t.matrix.a,r=s*t.matrix.b,o=Math.sqrt(a*a+r*r);i&&(d[n]=o),c[++n]=(e?s+u:u)*o/s}}}const m=this.computeWorldPositions(t,h,r);let f=m[0],g=m[1],p=a.offsetRotation,x=!1;if(0==p)x=a.rotateMode==k.Chain;else{x=!1;const t=this.target.bone.matrix;p*=t.a*t.d-t.b*t.c>0?q.degRad:-q.degRad}for(let w=0,b=3;w<l;w++,b+=3){const t=o[w],a=t.matrix;a.tx+=(f-a.tx)*n,a.ty+=(g-a.ty)*s;const l=m[b],h=m[b+1],u=l-f,E=h-g;if(i){const t=d[w];if(0!=t){const n=(Math.sqrt(u*u+E*E)/t-1)*e+1;a.a*=n,a.b*=n}}if(f=l,g=h,e>0){const n=a.a,s=a.c,i=a.b,o=a.d;let l=0,h=0,d=0;if(l=r?m[b-1]:0==c[w+1]?m[b+2]:Math.atan2(E,u),l-=Math.atan2(i,n),x){h=Math.cos(l),d=Math.sin(l);const s=t.data.length;f+=(s*(h*n-d*i)-u)*e,g+=(s*(d*n+h*i)-E)*e}else l+=p;l>q.PI?l-=q.PI2:l<-q.PI&&(l+=q.PI2),l*=e,h=Math.cos(l),d=Math.sin(l),a.a=h*n-d*i,a.c=h*s-d*o,a.b=d*n+h*i,a.d=d*s+h*o}t.updateAppliedTransform()}}computeWorldPositions(t,e,n){const s=this.target;let a=this.position;const r=this.spaces,i=j.setArraySize(this.positions,3*e+2);let o=this.world;const l=t.closed;let h=t.worldVerticesLength,c=h/6,d=Pa.NONE;if(!t.constantSpeed){const u=t.lengths;c-=l?1:2;const m=u[c];let f;switch(this.data.positionMode==T.Percent&&(a*=m),this.data.spacingMode){case va.Percent:f=m;break;case va.Proportional:f=m/e;break;default:f=1}o=j.setArraySize(this.world,8);for(let g=0,p=0,x=0;g<e;g++,p+=3){const e=r[g]*f;a+=e;let w=a;if(l)w%=m,w<0&&(w+=m),x=0;else{if(w<0){d!=Pa.BEFORE&&(d=Pa.BEFORE,t.computeWorldVertices(s,2,4,o,0,2)),this.addBeforePosition(w,o,0,i,p);continue}if(w>m){d!=Pa.AFTER&&(d=Pa.AFTER,t.computeWorldVertices(s,h-6,4,o,0,2)),this.addAfterPosition(w-m,o,0,i,p);continue}}for(;;x++){const t=u[x];if(!(w>t)){if(0==x)w/=t;else{const e=u[x-1];w=(w-e)/(t-e)}break}}x!=d&&(d=x,l&&x==c?(t.computeWorldVertices(s,h-4,4,o,0,2),t.computeWorldVertices(s,0,4,o,4,2)):t.computeWorldVertices(s,6*x+2,8,o,0,2)),this.addCurvePosition(w,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],i,p,n||g>0&&0==e)}return i}l?(h+=2,o=j.setArraySize(this.world,h),t.computeWorldVertices(s,2,h-4,o,0,2),t.computeWorldVertices(s,0,2,o,h-4,2),o[h-2]=o[0],o[h-1]=o[1]):(c--,h-=4,o=j.setArraySize(this.world,h),t.computeWorldVertices(s,2,h,o,0,2));const u=j.setArraySize(this.curves,c);let m,f=0,g=o[0],p=o[1],x=0,w=0,b=0,E=0,y=0,S=0,M=0,A=0,I=0,k=0,R=0,C=0,V=0,v=0;for(let T=0,Y=2;T<c;T++,Y+=6)x=o[Y],w=o[Y+1],b=o[Y+2],E=o[Y+3],y=o[Y+4],S=o[Y+5],M=.1875*(g-2*x+b),A=.1875*(p-2*w+E),I=.09375*(3*(x-b)-g+y),k=.09375*(3*(w-E)-p+S),R=2*M+I,C=2*A+k,V=.75*(x-g)+M+.16666667*I,v=.75*(w-p)+A+.16666667*k,f+=Math.sqrt(V*V+v*v),V+=R,v+=C,R+=I,C+=k,f+=Math.sqrt(V*V+v*v),V+=R,v+=C,f+=Math.sqrt(V*V+v*v),V+=R+I,v+=C+k,f+=Math.sqrt(V*V+v*v),u[T]=f,g=y,p=S;switch(this.data.positionMode==T.Percent&&(a*=f),this.data.spacingMode){case va.Percent:m=f;break;case va.Proportional:m=f/e;break;default:m=1}const P=this.segments;let F=0;for(let T=0,Y=0,N=0,X=0;T<e;T++,Y+=3){const t=r[T]*m;a+=t;let e=a;if(l)e%=f,e<0&&(e+=f),N=0;else{if(e<0){this.addBeforePosition(e,o,0,i,Y);continue}if(e>f){this.addAfterPosition(e-f,o,h-4,i,Y);continue}}for(;;N++){const t=u[N];if(!(e>t)){if(0==N)e/=t;else{const n=u[N-1];e=(e-n)/(t-n)}break}}if(N!=d){d=N;let t=6*N;for(g=o[t],p=o[t+1],x=o[t+2],w=o[t+3],b=o[t+4],E=o[t+5],y=o[t+6],S=o[t+7],M=.03*(g-2*x+b),A=.03*(p-2*w+E),I=.006*(3*(x-b)-g+y),k=.006*(3*(w-E)-p+S),R=2*M+I,C=2*A+k,V=.3*(x-g)+M+.16666667*I,v=.3*(w-p)+A+.16666667*k,F=Math.sqrt(V*V+v*v),P[0]=F,t=1;t<8;t++)V+=R,v+=C,R+=I,C+=k,F+=Math.sqrt(V*V+v*v),P[t]=F;V+=R,v+=C,F+=Math.sqrt(V*V+v*v),P[8]=F,V+=R+I,v+=C+k,F+=Math.sqrt(V*V+v*v),P[9]=F,X=0}for(e*=F;;X++){const t=P[X];if(!(e>t)){if(0==X)e/=t;else{const n=P[X-1];e=X+(e-n)/(t-n)}break}}this.addCurvePosition(.1*e,g,p,x,w,b,E,y,S,i,Y,n||T>0&&0==t)}return i}addBeforePosition(t,e,n,s,a){const r=e[n],i=e[n+1],o=e[n+2]-r,l=e[n+3]-i,h=Math.atan2(l,o);s[a]=r+t*Math.cos(h),s[a+1]=i+t*Math.sin(h),s[a+2]=h}addAfterPosition(t,e,n,s,a){const r=e[n+2],i=e[n+3],o=r-e[n],l=i-e[n+1],h=Math.atan2(l,o);s[a]=r+t*Math.cos(h),s[a+1]=i+t*Math.sin(h),s[a+2]=h}addCurvePosition(t,e,n,s,a,r,i,o,l,h,c,d){if(0==t||isNaN(t))return h[c]=e,h[c+1]=n,void(h[c+2]=Math.atan2(a-n,s-e));const u=t*t,m=u*t,f=1-t,g=f*f,p=g*f,x=f*t,w=3*x,b=f*w,E=w*t,y=e*p+s*b+r*E+o*m,S=n*p+a*b+i*E+l*m;h[c]=y,h[c+1]=S,d&&(h[c+2]=t<.001?Math.atan2(a-n,s-e):Math.atan2(S-(n*g+a*x*2+i*u),y-(e*g+s*x*2+r*u)))}};let Fa=Pa;Fa.NONE=-1,Fa.BEFORE=-2,Fa.AFTER=-3,Fa.epsilon=1e-5;class Ya{constructor(t,e){if(this.darkColor=null,this.attachment=null,this.attachmentState=0,this.sequenceIndex=-1,this.deform=new Array,!t)throw new Error("data cannot be null.");if(!e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new O,this.darkColor=t.darkColor?new O:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(t instanceof Qn&&this.attachment instanceof Qn&&t.timelineAttachment==this.attachment.timelineAttachment||(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}class Na{constructor(t,e){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new Z,this.active=!1,!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let s=0;s<t.bones.length;s++){const n=e.findBone(t.bones[s].name);if(!n)throw new Error(`Couldn't find bone ${t.bones[s].name}.`);this.bones.push(n)}const n=e.findBone(t.target.name);if(!n)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=n}isActive(){return this.active}update(){0==this.mixRotate&&0==this.mixX&&0==this.mixY&&0==this.mixScaleX&&0==this.mixScaleX&&0==this.mixShearY||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,e=this.mixX,n=this.mixY,s=this.mixScaleX,a=this.mixScaleY,r=this.mixShearY,i=0!=e||0!=n,o=this.target,l=o.matrix,h=l.a,c=l.c,d=l.b,u=l.d,m=h*u-c*d>0?q.degRad:-q.degRad,f=this.data.offsetRotation*m,g=this.data.offsetShearY*m,p=this.bones;for(let x=0,w=p.length;x<w;x++){const l=p[x],m=l.matrix;if(0!=t){const e=m.a,n=m.c,s=m.b,a=m.d;let r=Math.atan2(d,h)-Math.atan2(s,e)+f;r>q.PI?r-=q.PI2:r<-q.PI&&(r+=q.PI2),r*=t;const i=Math.cos(r),o=Math.sin(r);m.a=i*e-o*s,m.c=i*n-o*a,m.b=o*e+i*s,m.d=o*n+i*a}if(i){const t=this.temp;o.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),m.tx+=(t.x-m.tx)*e,m.ty+=(t.y-m.ty)*n}if(0!=s){let t=Math.sqrt(m.a*m.a+m.b*m.b);0!=t&&(t=(t+(Math.sqrt(h*h+d*d)-t+this.data.offsetScaleX)*s)/t),m.a*=t,m.b*=t}if(0!=a){let t=Math.sqrt(m.c*m.c+m.d*m.d);0!=t&&(t=(t+(Math.sqrt(c*c+u*u)-t+this.data.offsetScaleY)*a)/t),m.c*=t,m.d*=t}if(r>0){const t=m.c,e=m.d,n=Math.atan2(e,t);let s=Math.atan2(u,c)-Math.atan2(d,h)-(n-Math.atan2(m.b,m.a));s>q.PI?s-=q.PI2:s<-q.PI&&(s+=q.PI2),s=n+(s+g)*r;const a=Math.sqrt(t*t+e*e);m.c=Math.cos(s)*a,m.d=Math.sin(s)*a}l.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,e=this.mixX,n=this.mixY,s=this.mixScaleX,a=this.mixScaleY,r=this.mixShearY,i=0!=e||0!=n,o=this.target,l=o.matrix,h=l.a,c=l.c,d=l.b,u=l.d,m=h*u-c*d>0?q.degRad:-q.degRad,f=this.data.offsetRotation*m,g=this.data.offsetShearY*m,p=this.bones;for(let x=0,w=p.length;x<w;x++){const l=p[x],m=l.matrix;if(0!=t){const e=m.a,n=m.c,s=m.b,a=m.d;let r=Math.atan2(d,h)+f;r>q.PI?r-=q.PI2:r<-q.PI&&(r+=q.PI2),r*=t;const i=Math.cos(r),o=Math.sin(r);m.a=i*e-o*s,m.c=i*n-o*a,m.b=o*e+i*s,m.d=o*n+i*a}if(i){const t=this.temp;o.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),m.tx+=t.x*e,m.ty+=t.y*n}if(0!=s){const t=(Math.sqrt(h*h+d*d)-1+this.data.offsetScaleX)*s+1;m.a*=t,m.b*=t}if(0!=a){const t=(Math.sqrt(c*c+u*u)-1+this.data.offsetScaleY)*a+1;m.c*=t,m.d*=t}if(r>0){let t=Math.atan2(u,c)-Math.atan2(d,h);t>q.PI?t-=q.PI2:t<-q.PI&&(t+=q.PI2);const e=m.c,n=m.d;t=Math.atan2(n,e)+(t-q.PI/2+g)*r;const s=Math.sqrt(e*e+n*n);m.c=Math.cos(t)*s,m.d=Math.sin(t)*s}l.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,e=this.mixX,n=this.mixY,s=this.mixScaleX,a=this.mixScaleY,r=this.mixShearY,i=this.target,o=this.bones;for(let l=0,h=o.length;l<h;l++){const h=o[l];let c=h.arotation;if(0!=t){let e=i.arotation-c+this.data.offsetRotation;e-=360*(16384-(16384.499999999996-e/360|0)),c+=e*t}let d=h.ax,u=h.ay;d+=(i.ax-d+this.data.offsetX)*e,u+=(i.ay-u+this.data.offsetY)*n;let m=h.ascaleX,f=h.ascaleY;0!=s&&0!=m&&(m=(m+(i.ascaleX-m+this.data.offsetScaleX)*s)/m),0!=a&&0!=f&&(f=(f+(i.ascaleY-f+this.data.offsetScaleY)*a)/f);let g=h.ashearY;if(0!=r){let t=i.ashearY-g+this.data.offsetShearY;t-=360*(16384-(16384.499999999996-t/360|0)),g+=t*r}h.updateWorldTransformWith(d,u,c,m,f,h.ashearX,g)}}applyRelativeLocal(){const t=this.mixRotate,e=this.mixX,n=this.mixY,s=this.mixScaleX,a=this.mixScaleY,r=this.mixShearY,i=this.target,o=this.bones;for(let l=0,h=o.length;l<h;l++){const h=o[l],c=h.arotation+(i.arotation+this.data.offsetRotation)*t,d=h.ax+(i.ax+this.data.offsetX)*e,u=h.ay+(i.ay+this.data.offsetY)*n,m=h.ascaleX*((i.ascaleX-1+this.data.offsetScaleX)*s+1),f=h.ascaleY*((i.ascaleY-1+this.data.offsetScaleY)*a+1),g=h.ashearY+(i.ashearY+this.data.offsetShearY)*r;h.updateWorldTransformWith(d,u,c,m,f,h.ashearX,g)}}}const Xa=class{constructor(t){if(this._updateCache=new Array,this.skin=null,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const n=t.bones[e];let s;if(n.parent){const t=this.bones[n.parent.index];s=new Ma(n,this,t),t.children.push(s)}else s=new Ma(n,this,null);this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const n=t.slots[e],s=this.bones[n.boneData.index],a=new Ya(n,s);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const n=t.ikConstraints[e];this.ikConstraints.push(new Ra(n,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const n=t.transformConstraints[e];this.transformConstraints.push(new Na(n,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const n=t.pathConstraints[e];this.pathConstraints.push(new Fa(n,this))}this.color=new O(1,1,1,1),this.updateCache()}updateCache(){this._updateCache.length=0;const t=this.bones;for(let l=0,h=t.length;l<h;l++){const e=t[l];e.sorted=e.data.skinRequired,e.active=!e.sorted}if(this.skin){const t=this.skin.bones;for(let e=0,n=this.skin.bones.length;e<n;e++){let n=this.bones[t[e].index];do{n.sorted=!1,n.active=!0,n=n.parent}while(n)}}const e=this.ikConstraints,n=this.transformConstraints,s=this.pathConstraints,a=e.length,r=n.length,i=s.length,o=a+r+i;t:for(let l=0;l<o;l++){for(let t=0;t<a;t++){const n=e[t];if(n.data.order==l){this.sortIkConstraint(n);continue t}}for(let t=0;t<r;t++){const e=n[t];if(e.data.order==l){this.sortTransformConstraint(e);continue t}}for(let t=0;t<i;t++){const e=s[t];if(e.data.order==l){this.sortPathConstraint(e);continue t}}}for(let l=0,h=t.length;l<h;l++)this.sortBone(t[l])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&j.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const n=t.bones,s=n[0];if(this.sortBone(s),1==n.length)this._updateCache.push(t),this.sortReset(s.children);else{const e=n[n.length-1];this.sortBone(e),this._updateCache.push(t),this.sortReset(s.children),e.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&j.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,n=e.data.index,s=e.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,n,s),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,s);for(let o=0,l=this.data.skins.length;o<l;o++)this.sortPathConstraintAttachment(this.data.skins[o],n,s);const a=e.getAttachment();a instanceof es&&this.sortPathConstraintAttachmentWith(a,s);const r=t.bones,i=r.length;for(let o=0;o<i;o++)this.sortBone(r[o]);this._updateCache.push(t);for(let o=0;o<i;o++)this.sortReset(r[o].children);for(let o=0;o<i;o++)r[o].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&j.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,n=e.length;if(t.data.local)for(let s=0;s<n;s++){const t=e[s];this.sortBone(t.parent),this.sortBone(t)}else for(let s=0;s<n;s++)this.sortBone(e[s]);this._updateCache.push(t);for(let s=0;s<n;s++)this.sortReset(e[s].children);for(let s=0;s<n;s++)e[s].sorted=!0}sortPathConstraintAttachment(t,e,n){const s=t.attachments[e];if(s)for(const a in s)this.sortPathConstraintAttachmentWith(s[a],n)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof es))return;const n=t.bones;if(n){const t=this.bones;for(let e=0,s=n.length;e<s;){let s=n[e++];for(s+=e;e<s;)this.sortBone(t[n[e++]])}}else this.sortBone(e)}sortBone(t){if(!t)return;if(t.sorted)return;const e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,n=t.length;e<n;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const t=this.bones;for(let n=0,s=t.length;n<s;n++){const e=t[n];e.ax=e.x,e.ay=e.y,e.arotation=e.rotation,e.ascaleX=e.scaleX,e.ascaleY=e.scaleY,e.ashearX=e.shearX,e.ashearY=e.shearY}const e=this._updateCache;for(let n=0,s=e.length;n<s;n++)e[n].update()}updateWorldTransformWith(t){const e=this.getRootBone(),n=t.matrix.a,s=t.matrix.c,a=t.matrix.b,r=t.matrix.d;e.matrix.tx=n*this.x+s*this.y+t.worldX,e.matrix.ty=a*this.x+r*this.y+t.worldY;const i=e.rotation+90+e.shearY,o=q.cosDeg(e.rotation+e.shearX)*e.scaleX,l=q.cosDeg(i)*e.scaleY,h=q.sinDeg(e.rotation+e.shearX)*e.scaleX,c=q.sinDeg(i)*e.scaleY,d=this.scaleX,u=-this.scaleY;e.matrix.a=(n*o+s*h)*d,e.matrix.c=(n*l+s*c)*d,e.matrix.b=(a*o+r*h)*u,e.matrix.d=(a*l+r*c)*u;const m=this._updateCache;for(let f=0,g=m.length;f<g;f++){const t=m[f];t!=e&&t.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let a=0,r=t.length;a<r;a++)t[a].setToSetupPose();const e=this.ikConstraints;for(let a=0,r=e.length;a<r;a++){const t=e[a];t.mix=t.data.mix,t.softness=t.data.softness,t.bendDirection=t.data.bendDirection,t.compress=t.data.compress,t.stretch=t.data.stretch}const n=this.transformConstraints;for(let a=0,r=n.length;a<r;a++){const t=n[a],e=t.data;t.mixRotate=e.mixRotate,t.mixX=e.mixX,t.mixY=e.mixY,t.mixScaleX=e.mixScaleX,t.mixScaleY=e.mixScaleY,t.mixShearY=e.mixShearY}const s=this.pathConstraints;for(let a=0,r=s.length;a<r;a++){const t=s[a],e=t.data;t.position=e.position,t.spacing=e.spacing,t.mixRotate=e.mixRotate,t.mixX=e.mixX,t.mixY=e.mixY}}setSlotsToSetupPose(){const t=this.slots;j.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,n=t.length;e<n;e++)t[e].setToSetupPose()}getRootBone(){return 0==this.bones.length?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++)if(e[n].data.name==t)return n;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++)if(e[n].data.name==t)return n;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(!e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n],a=s.data.attachmentName;if(a){const e=t.getAttachment(n,a);e&&s.setAttachment(e)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){const n=this.data.findSlot(t);if(!n)throw new Error(`Can't find slot with name ${t}`);return this.getAttachment(n.index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){const n=this.skin.getAttachment(t,e);if(n)return n}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,a=n.length;s<a;s++){const a=n[s];if(a.data.name==t){let n=null;if(e&&(n=this.getAttachment(s,e),!n))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);return void a.setAttachment(n)}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.data.name==t)return s}return null}getBoundsRect(){const t=new Z,e=new Z;return this.getBounds(t,e),{x:t.x,y:t.y,width:e.x,height:e.y}}getBounds(t,e,n=new Array(2)){if(!t)throw new Error("offset cannot be null.");if(!e)throw new Error("size cannot be null.");const s=this.drawOrder;let a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let l=0,h=s.length;l<h;l++){const t=s[l];if(!t.bone.active)continue;let e=0,h=null;const c=t.getAttachment();if(c instanceof as)e=8,h=j.setArraySize(n,e,0),c.computeWorldVertices(t,h,0,2);else if(c instanceof ts){const s=c;e=s.worldVerticesLength,h=j.setArraySize(n,e,0),s.computeWorldVertices(t,0,e,h,0,2)}if(h)for(let n=0,s=h.length;n<s;n+=2){const t=h[n],e=h[n+1];a=Math.min(a,t),r=Math.min(r,e),i=Math.max(i,t),o=Math.max(o,e)}}t.set(a,r),e.set(i-a,o-r)}get flipX(){return-1==this.scaleX}set flipX(t){Xa.deprecatedWarning1||(Xa.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return-1==this.scaleY}set flipY(t){Xa.deprecatedWarning1||(Xa.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};let Da=Xa;Da.deprecatedWarning1=!1;class Ba{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const e=this.skins;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const e=this.animations;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++){const s=e[n];if(s.name==t)return s}return null}findPathConstraintIndex(t){if(null==t)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let n=0,s=e.length;n<s;n++)if(e[n].name==t)return n;return-1}}class La{constructor(t,e,n){if(this.index=0,this.color=new O(1,1,1,1),this.darkColor=null,this.attachmentName=null,this.blendMode=y.NORMAL,t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");if(!n)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=n}}class _a extends Ia{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class Oa{constructor(t,e,n){this.slotIndex=t,this.name=e,this.attachment=n}}class Wa{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,n){if(!n)throw new Error("attachment cannot be null.");const s=this.attachments;t>=s.length&&(s.length=t+1),s[t]||(s[t]={}),s[t][e]=n}addSkin(t){for(let n=0;n<t.bones.length;n++){const e=t.bones[n];let s=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==e){s=!0;break}s||this.bones.push(e)}for(let n=0;n<t.constraints.length;n++){const e=t.constraints[n];let s=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==e){s=!0;break}s||this.constraints.push(e)}const e=t.getAttachments();for(let n=0;n<e.length;n++){const t=e[n];this.setAttachment(t.slotIndex,t.name,t.attachment)}}copySkin(t){for(let n=0;n<t.bones.length;n++){const e=t.bones[n];let s=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==e){s=!0;break}s||this.bones.push(e)}for(let n=0;n<t.constraints.length;n++){const e=t.constraints[n];let s=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==e){s=!0;break}s||this.constraints.push(e)}const e=t.getAttachments();for(let n=0;n<e.length;n++){const t=e[n];t.attachment&&(t.attachment instanceof ts?(t.attachment=t.attachment.newLinkedMesh(),this.setAttachment(t.slotIndex,t.name,t.attachment)):(t.attachment=t.attachment.copy(),this.setAttachment(t.slotIndex,t.name,t.attachment)))}}getAttachment(t,e){const n=this.attachments[t];return n?n[e]:null}removeAttachment(t,e){const n=this.attachments[t];n&&delete n[e]}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const n=this.attachments[e];if(n)for(const s in n){const a=n[s];a&&t.push(new Oa(e,s,a))}}return t}getAttachmentsForSlot(t,e){const n=this.attachments[t];if(n)for(const s in n){const a=n[s];a&&e.push(new Oa(t,s,a))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let n=0;for(let s=0;s<t.slots.length;s++){const a=t.slots[s],r=a.getAttachment();if(r&&n<e.attachments.length){const t=e.attachments[n];for(const e in t){if(r==t[e]){const t=this.getAttachment(n,e);t&&a.setAttachment(t);break}}}n++}}}class qa{constructor(t){this.ver40=!1,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,n=new Ba;n.name="";const s=new M(t),a=s.readInt32(),r=s.readInt32();n.hash=0==r&&0==a?null:r.toString(16)+a.toString(16),n.version=s.readString();const i=n.version.substr(0,3);if("4.0"!==i&&"4.1"!==i){const t=`Spine 4.1 loader cant load version ${n.version}. Please configure your pixi-spine bundle`;console.error(t)}this.ver40="4.0"===i,n.x=s.readFloat(),n.y=s.readFloat(),n.width=s.readFloat(),n.height=s.readFloat();const o=s.readBoolean();o&&(n.fps=s.readFloat(),n.imagesPath=s.readString(),n.audioPath=s.readString());let l=0;l=s.readInt(!0);for(let c=0;c<l;c++){const t=s.readString();if(!t)throw new Error("String in string table must not be null.");s.strings.push(t)}l=s.readInt(!0);for(let c=0;c<l;c++){const t=s.readString();if(!t)throw new Error("Bone name must not be null.");const a=0==c?null:n.bones[s.readInt(!0)],r=new Aa(c,t,a);r.rotation=s.readFloat(),r.x=s.readFloat()*e,r.y=s.readFloat()*e,r.scaleX=s.readFloat(),r.scaleY=s.readFloat(),r.shearX=s.readFloat(),r.shearY=s.readFloat(),r.length=s.readFloat()*e,r.transformMode=s.readInt(!0),r.skinRequired=s.readBoolean(),o&&O.rgba8888ToColor(r.color,s.readInt32()),n.bones.push(r)}l=s.readInt(!0);for(let c=0;c<l;c++){const t=s.readString();if(!t)throw new Error("Slot name must not be null.");const e=n.bones[s.readInt(!0)],a=new La(c,t,e);O.rgba8888ToColor(a.color,s.readInt32());const r=s.readInt32();-1!=r&&O.rgb888ToColor(a.darkColor=new O,r),a.attachmentName=s.readStringRef(),a.blendMode=s.readInt(!0),n.slots.push(a)}l=s.readInt(!0);for(let c,d=0;d<l;d++){const t=s.readString();if(!t)throw new Error("IK constraint data name must not be null.");const a=new Ca(t);a.order=s.readInt(!0),a.skinRequired=s.readBoolean(),c=s.readInt(!0);for(let e=0;e<c;e++)a.bones.push(n.bones[s.readInt(!0)]);a.target=n.bones[s.readInt(!0)],a.mix=s.readFloat(),a.softness=s.readFloat()*e,a.bendDirection=s.readByte(),a.compress=s.readBoolean(),a.stretch=s.readBoolean(),a.uniform=s.readBoolean(),n.ikConstraints.push(a)}l=s.readInt(!0);for(let c,d=0;d<l;d++){const t=s.readString();if(!t)throw new Error("Transform constraint data name must not be null.");const a=new _a(t);a.order=s.readInt(!0),a.skinRequired=s.readBoolean(),c=s.readInt(!0);for(let e=0;e<c;e++)a.bones.push(n.bones[s.readInt(!0)]);a.target=n.bones[s.readInt(!0)],a.local=s.readBoolean(),a.relative=s.readBoolean(),a.offsetRotation=s.readFloat(),a.offsetX=s.readFloat()*e,a.offsetY=s.readFloat()*e,a.offsetScaleX=s.readFloat(),a.offsetScaleY=s.readFloat(),a.offsetShearY=s.readFloat(),a.mixRotate=s.readFloat(),a.mixX=s.readFloat(),a.mixY=s.readFloat(),a.mixScaleX=s.readFloat(),a.mixScaleY=s.readFloat(),a.mixShearY=s.readFloat(),n.transformConstraints.push(a)}l=s.readInt(!0);for(let c,d=0;d<l;d++){const t=s.readString();if(!t)throw new Error("Path constraint data name must not be null.");const a=new Va(t);a.order=s.readInt(!0),a.skinRequired=s.readBoolean(),c=s.readInt(!0);for(let e=0;e<c;e++)a.bones.push(n.bones[s.readInt(!0)]);a.target=n.slots[s.readInt(!0)],a.positionMode=s.readInt(!0),a.spacingMode=s.readInt(!0),a.rotateMode=s.readInt(!0),a.offsetRotation=s.readFloat(),a.position=s.readFloat(),a.positionMode==T.Fixed&&(a.position*=e),a.spacing=s.readFloat(),a.spacingMode!=va.Length&&a.spacingMode!=va.Fixed||(a.spacing*=e),a.mixRotate=s.readFloat(),a.mixX=s.readFloat(),a.mixY=s.readFloat(),n.pathConstraints.push(a)}const h=this.readSkin(s,n,!0,o);h&&(n.defaultSkin=h,n.skins.push(h));{let t=n.skins.length;for(j.setArraySize(n.skins,l=t+s.readInt(!0));t<l;t++){const e=this.readSkin(s,n,!1,o);if(!e)throw new Error("readSkin() should not have returned null.");n.skins[t]=e}}l=this.linkedMeshes.length;for(let c=0;c<l;c++){const t=this.linkedMeshes[c],e=t.skin?n.findSkin(t.skin):n.defaultSkin;if(!e)throw new Error("Not skin found for linked mesh.");if(!t.parent)throw new Error("Linked mesh parent must not be null");const s=e.getAttachment(t.slotIndex,t.parent);if(!s)throw new Error(`Parent mesh not found: ${t.parent}`);t.mesh.timelineAttachment=t.inheritTimeline?s:t.mesh,t.mesh.setParentMesh(s)}this.linkedMeshes.length=0,l=s.readInt(!0);for(let c=0;c<l;c++){const t=s.readStringRef();if(!t)throw new Error;const e=new ka(t);e.intValue=s.readInt(!1),e.floatValue=s.readFloat(),e.stringValue=s.readString(),e.audioPath=s.readString(),e.audioPath&&(e.volume=s.readFloat(),e.balance=s.readFloat()),n.events.push(e)}l=s.readInt(!0);for(let c=0;c<l;c++){const t=s.readString();if(!t)throw new Error("Animatio name must not be null.");n.animations.push(this.readAnimation(s,t,n))}return n}readSkin(t,e,n,s){let a=null,r=0;if(n){if(r=t.readInt(!0),0==r)return null;a=new Wa("default")}else{const n=t.readStringRef();if(!n)throw new Error("Skin name must not be null.");a=new Wa(n),a.bones.length=t.readInt(!0);for(let s=0,r=a.bones.length;s<r;s++)a.bones[s]=e.bones[t.readInt(!0)];for(let s=0,r=t.readInt(!0);s<r;s++)a.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let s=0,r=t.readInt(!0);s<r;s++)a.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let s=0,r=t.readInt(!0);s<r;s++)a.constraints.push(e.pathConstraints[t.readInt(!0)]);r=t.readInt(!0)}for(let i=0;i<r;i++){const n=t.readInt(!0);for(let r=0,i=t.readInt(!0);r<i;r++){const r=t.readStringRef();if(!r)throw new Error("Attachment name must not be null");const i=this.readAttachment(t,e,a,n,r,s);i&&a.setAttachment(n,r,i)}}return a}readAttachment(t,e,n,s,a,r){const i=this.scale;let o=t.readStringRef();switch(o||(o=a),t.readByte()){case S.Region:{let e=t.readStringRef();const s=t.readFloat(),a=t.readFloat(),r=t.readFloat(),l=t.readFloat(),h=t.readFloat(),c=t.readFloat(),d=t.readFloat(),u=t.readInt32(),m=this.readSequence(t);e||(e=o);const f=this.attachmentLoader.newRegionAttachment(n,o,e,m);return f?(f.path=e,f.x=a*i,f.y=r*i,f.scaleX=l,f.scaleY=h,f.rotation=s,f.width=c*i,f.height=d*i,O.rgba8888ToColor(f.color,u),f.sequence=m,null==m&&f.updateRegion(),f):null}case S.BoundingBox:{const e=t.readInt(!0),s=this.readVertices(t,e),a=r?t.readInt32():0,i=this.attachmentLoader.newBoundingBoxAttachment(n,o);return i?(i.worldVerticesLength=e<<1,i.vertices=s.vertices,i.bones=s.bones,r&&O.rgba8888ToColor(i.color,a),i):null}case S.Mesh:{let e=t.readStringRef();const s=t.readInt32(),a=t.readInt(!0),l=this.readFloatArray(t,a<<1,1),h=this.readShortArray(t),c=this.readVertices(t,a),d=t.readInt(!0),u=this.readSequence(t);let m=[],f=0,g=0;r&&(m=this.readShortArray(t),f=t.readFloat(),g=t.readFloat()),e||(e=o);const p=this.attachmentLoader.newMeshAttachment(n,o,e,u);return p?(p.path=e,O.rgba8888ToColor(p.color,s),p.bones=c.bones,p.vertices=c.vertices,p.worldVerticesLength=a<<1,p.triangles=h,p.regionUVs=new Float32Array(l),p.hullLength=d<<1,p.sequence=u,r&&(p.edges=m,p.width=f*i,p.height=g*i),p):null}case S.LinkedMesh:{let e=t.readStringRef();const a=t.readInt32(),l=t.readStringRef(),h=t.readStringRef(),c=t.readBoolean(),d=this.readSequence(t);let u=0,m=0;r&&(u=t.readFloat(),m=t.readFloat()),e||(e=o);const f=this.attachmentLoader.newMeshAttachment(n,o,e,d);return f?(f.path=e,O.rgba8888ToColor(f.color,a),f.sequence=d,r&&(f.width=u*i,f.height=m*i),this.linkedMeshes.push(new $a(f,l,s,h,c)),f):null}case S.Path:{const e=t.readBoolean(),s=t.readBoolean(),a=t.readInt(!0),l=this.readVertices(t,a),h=j.newArray(a/3,0);for(let n=0,r=h.length;n<r;n++)h[n]=t.readFloat()*i;const c=r?t.readInt32():0,d=this.attachmentLoader.newPathAttachment(n,o);return d?(d.closed=e,d.constantSpeed=s,d.worldVerticesLength=a<<1,d.vertices=l.vertices,d.bones=l.bones,d.lengths=h,r&&O.rgba8888ToColor(d.color,c),d):null}case S.Point:{const e=t.readFloat(),s=t.readFloat(),a=t.readFloat(),l=r?t.readInt32():0,h=this.attachmentLoader.newPointAttachment(n,o);return h?(h.x=s*i,h.y=a*i,h.rotation=e,r&&O.rgba8888ToColor(h.color,l),h):null}case S.Clipping:{const s=t.readInt(!0),a=t.readInt(!0),i=this.readVertices(t,a),l=r?t.readInt32():0,h=this.attachmentLoader.newClippingAttachment(n,o);return h?(h.endSlot=e.slots[s],h.worldVerticesLength=a<<1,h.vertices=i.vertices,h.bones=i.bones,r&&O.rgba8888ToColor(h.color,l),h):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const e=new is(t.readInt(!0));return e.start=t.readInt(!0),e.digits=t.readInt(!0),e.setupIndex=t.readInt(!0),e}readDeformTimelineType(t){return this.ver40?dr:t.readByte()}readVertices(t,e){const n=this.scale,s=e<<1,a=new Ua;if(!t.readBoolean())return a.vertices=this.readFloatArray(t,s,n),a;const r=new Array,i=new Array;for(let o=0;o<e;o++){const e=t.readInt(!0);i.push(e);for(let s=0;s<e;s++)i.push(t.readInt(!0)),r.push(t.readFloat()*n),r.push(t.readFloat()*n),r.push(t.readFloat())}return a.vertices=j.toFloatArray(r),a.bones=i,a}readFloatArray(t,e,n){const s=new Array(e);if(1==n)for(let a=0;a<e;a++)s[a]=t.readFloat();else for(let a=0;a<e;a++)s[a]=t.readFloat()*n;return s}readShortArray(t){const e=t.readInt(!0),n=new Array(e);for(let s=0;s<e;s++)n[s]=t.readShort();return n}readAnimation(t,e,n){t.readInt(!0);const s=new Array,a=this.scale;for(let l=0,h=t.readInt(!0);l<h;l++){const e=t.readInt(!0);for(let n=0,a=t.readInt(!0);n<a;n++){const n=t.readByte(),a=t.readInt(!0),r=a-1;switch(n){case rr:{const n=new Gs(a,e);for(let e=0;e<a;e++)n.setFrame(e,t.readFloat(),t.readStringRef());s.push(n);break}case ir:{const n=t.readInt(!0),i=new $s(a,n,e);let o=t.readFloat(),l=t.readUnsignedByte()/255,h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255;for(let e=0,s=0;i.setFrame(e,o,l,h,c,d),e!=r;e++){const n=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,u=t.readUnsignedByte()/255,m=t.readUnsignedByte()/255;switch(t.readByte()){case pr:i.setStepped(e);break;case xr:ja(t,i,s++,e,0,o,n,l,a,1),ja(t,i,s++,e,1,o,n,h,r,1),ja(t,i,s++,e,2,o,n,c,u,1),ja(t,i,s++,e,3,o,n,d,m,1)}o=n,l=a,h=r,c=u,d=m}s.push(i);break}case or:{const n=t.readInt(!0),i=new Us(a,n,e);let o=t.readFloat(),l=t.readUnsignedByte()/255,h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255;for(let e=0,s=0;i.setFrame(e,o,l,h,c),e!=r;e++){const n=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255;switch(t.readByte()){case pr:i.setStepped(e);break;case xr:ja(t,i,s++,e,0,o,n,l,a,1),ja(t,i,s++,e,1,o,n,h,r,1),ja(t,i,s++,e,2,o,n,c,d,1)}o=n,l=a,h=r,c=d}s.push(i);break}case lr:{const n=t.readInt(!0),i=new Hs(a,n,e);let o=t.readFloat(),l=t.readUnsignedByte()/255,h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255,u=t.readUnsignedByte()/255,m=t.readUnsignedByte()/255,f=t.readUnsignedByte()/255;for(let e=0,s=0;i.setFrame(e,o,l,h,c,d,u,m,f),e!=r;e++){const n=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,g=t.readUnsignedByte()/255,p=t.readUnsignedByte()/255,x=t.readUnsignedByte()/255,w=t.readUnsignedByte()/255,b=t.readUnsignedByte()/255;switch(t.readByte()){case pr:i.setStepped(e);break;case xr:ja(t,i,s++,e,0,o,n,l,a,1),ja(t,i,s++,e,1,o,n,h,r,1),ja(t,i,s++,e,2,o,n,c,g,1),ja(t,i,s++,e,3,o,n,d,p,1),ja(t,i,s++,e,4,o,n,u,x,1),ja(t,i,s++,e,5,o,n,m,w,1),ja(t,i,s++,e,6,o,n,f,b,1)}o=n,l=a,h=r,c=g,d=p,u=x,m=w,f=b}s.push(i);break}case hr:{const n=t.readInt(!0),i=new js(a,n,e);let o=t.readFloat(),l=t.readUnsignedByte()/255,h=t.readUnsignedByte()/255,c=t.readUnsignedByte()/255,d=t.readUnsignedByte()/255,u=t.readUnsignedByte()/255,m=t.readUnsignedByte()/255;for(let e=0,s=0;i.setFrame(e,o,l,h,c,d,u,m),e!=r;e++){const n=t.readFloat(),a=t.readUnsignedByte()/255,r=t.readUnsignedByte()/255,f=t.readUnsignedByte()/255,g=t.readUnsignedByte()/255,p=t.readUnsignedByte()/255,x=t.readUnsignedByte()/255;switch(t.readByte()){case pr:i.setStepped(e);break;case xr:ja(t,i,s++,e,0,o,n,l,a,1),ja(t,i,s++,e,1,o,n,h,r,1),ja(t,i,s++,e,2,o,n,c,f,1),ja(t,i,s++,e,3,o,n,d,g,1),ja(t,i,s++,e,4,o,n,u,p,1),ja(t,i,s++,e,5,o,n,m,x,1)}o=n,l=a,h=r,c=f,d=g,u=p,m=x}s.push(i);break}case cr:{const n=new zs(a,t.readInt(!0),e);let i=t.readFloat(),o=t.readUnsignedByte()/255;for(let e=0,s=0;n.setFrame(e,i,o),e!=r;e++){const a=t.readFloat(),r=t.readUnsignedByte()/255;switch(t.readByte()){case pr:n.setStepped(e);break;case xr:ja(t,n,s++,e,0,i,a,o,r,1)}i=a,o=r}s.push(n)}}}}for(let l=0,h=t.readInt(!0);l<h;l++){const e=t.readInt(!0);for(let n=0,r=t.readInt(!0);n<r;n++){const n=t.readByte(),r=t.readInt(!0),i=t.readInt(!0);switch(n){case Ga:s.push(za(t,new Ys(r,i,e),1));break;case Za:s.push(Ha(t,new Ns(r,i,e),a));break;case Qa:s.push(za(t,new Xs(r,i,e),a));break;case Ka:s.push(za(t,new Ds(r,i,e),a));break;case Ja:s.push(Ha(t,new Bs(r,i,e),1));break;case tr:s.push(za(t,new Ls(r,i,e),1));break;case er:s.push(za(t,new _s(r,i,e),1));break;case nr:s.push(Ha(t,new Os(r,i,e),1));break;case sr:s.push(za(t,new Ws(r,i,e),1));break;case ar:s.push(za(t,new qs(r,i,e),1))}}}for(let l=0,h=t.readInt(!0);l<h;l++){const e=t.readInt(!0),n=t.readInt(!0),r=n-1,i=new ea(n,t.readInt(!0),e);let o=t.readFloat(),l=t.readFloat(),h=t.readFloat()*a;for(let s=0,c=0;i.setFrame(s,o,l,h,t.readByte(),t.readBoolean(),t.readBoolean()),s!=r;s++){const e=t.readFloat(),n=t.readFloat(),r=t.readFloat()*a;switch(t.readByte()){case pr:i.setStepped(s);break;case xr:ja(t,i,c++,s,0,o,e,l,n,1),ja(t,i,c++,s,1,o,e,h,r,a)}o=e,l=n,h=r}s.push(i)}for(let l=0,h=t.readInt(!0);l<h;l++){const e=t.readInt(!0),n=t.readInt(!0),a=n-1,r=new na(n,t.readInt(!0),e);let i=t.readFloat(),o=t.readFloat(),l=t.readFloat(),h=t.readFloat(),c=t.readFloat(),d=t.readFloat(),u=t.readFloat();for(let s=0,m=0;r.setFrame(s,i,o,l,h,c,d,u),s!=a;s++){const e=t.readFloat(),n=t.readFloat(),a=t.readFloat(),f=t.readFloat(),g=t.readFloat(),p=t.readFloat(),x=t.readFloat();switch(t.readByte()){case pr:r.setStepped(s);break;case xr:ja(t,r,m++,s,0,i,e,o,n,1),ja(t,r,m++,s,1,i,e,l,a,1),ja(t,r,m++,s,2,i,e,h,f,1),ja(t,r,m++,s,3,i,e,c,g,1),ja(t,r,m++,s,4,i,e,d,p,1),ja(t,r,m++,s,5,i,e,u,x,1)}i=e,o=n,l=a,h=f,c=g,d=p,u=x}s.push(r)}for(let l=0,h=t.readInt(!0);l<h;l++){const e=t.readInt(!0),r=n.pathConstraints[e];for(let n=0,i=t.readInt(!0);n<i;n++)switch(t.readByte()){case mr:s.push(za(t,new sa(t.readInt(!0),t.readInt(!0),e),r.positionMode==T.Fixed?a:1));break;case fr:s.push(za(t,new aa(t.readInt(!0),t.readInt(!0),e),r.spacingMode==va.Length||r.spacingMode==va.Fixed?a:1));break;case gr:const n=new ra(t.readInt(!0),t.readInt(!0),e);let i=t.readFloat(),o=t.readFloat(),l=t.readFloat(),h=t.readFloat();for(let e=0,s=0,a=n.getFrameCount()-1;n.setFrame(e,i,o,l,h),e!=a;e++){const a=t.readFloat(),r=t.readFloat(),c=t.readFloat(),d=t.readFloat();switch(t.readByte()){case pr:n.setStepped(e);break;case xr:ja(t,n,s++,e,0,i,a,o,r,1),ja(t,n,s++,e,1,i,a,l,c,1),ja(t,n,s++,e,2,i,a,h,d,1)}i=a,o=r,l=c,h=d}s.push(n)}}for(let l=0,h=t.readInt(!0);l<h;l++){const e=n.skins[t.readInt(!0)];for(let n=0,r=t.readInt(!0);n<r;n++){const n=t.readInt(!0);for(let r=0,i=t.readInt(!0);r<i;r++){const r=t.readStringRef();if(!r)throw new Error("attachmentName must not be null.");const i=e.getAttachment(n,r),o=this.readDeformTimelineType(t),l=t.readInt(!0),h=l-1;switch(o){case dr:{const e=i,r=e.bones,o=e.vertices,c=r?o.length/3*2:o.length,d=t.readInt(!0),u=new Zs(l,d,n,e);let m=t.readFloat();for(let n=0,s=0;;n++){let e,i=t.readInt(!0);if(0==i)e=r?j.newFloatArray(c):o;else{e=j.newFloatArray(c);const n=t.readInt(!0);if(i+=n,1==a)for(let s=n;s<i;s++)e[s]=t.readFloat();else for(let s=n;s<i;s++)e[s]=t.readFloat()*a;if(!r)for(let t=0,s=e.length;t<s;t++)e[t]+=o[t]}if(u.setFrame(n,m,e),n==h)break;const l=t.readFloat();switch(t.readByte()){case pr:u.setStepped(n);break;case xr:ja(t,u,s++,n,0,m,l,0,1,1)}m=l}s.push(u);break}case ur:{const e=new oa(l,n,i);for(let n=0;n<l;n++){const s=t.readFloat(),a=t.readInt32();e.setFrame(n,s,ls[15&a],a>>4,t.readFloat())}s.push(e);break}}}}}const r=t.readInt(!0);if(r>0){const e=new ta(r),a=n.slots.length;for(let n=0;n<r;n++){const s=t.readFloat(),r=t.readInt(!0),i=j.newArray(a,0);for(let t=a-1;t>=0;t--)i[t]=-1;const o=j.newArray(a-r,0);let l=0,h=0;for(let e=0;e<r;e++){const e=t.readInt(!0);for(;l!=e;)o[h++]=l++;i[l+t.readInt(!0)]=l++}for(;l<a;)o[h++]=l++;for(let t=a-1;t>=0;t--)-1==i[t]&&(i[t]=o[--h]);e.setFrame(n,s,i)}s.push(e)}const i=t.readInt(!0);if(i>0){const e=new Ks(i);for(let s=0;s<i;s++){const a=t.readFloat(),r=n.events[t.readInt(!0)],i=new Ta(a,r);i.intValue=t.readInt(!1),i.floatValue=t.readFloat(),i.stringValue=t.readBoolean()?t.readString():r.stringValue,i.data.audioPath&&(i.volume=t.readFloat(),i.balance=t.readFloat()),e.setFrame(s,i)}s.push(e)}let o=0;for(let l=0,h=s.length;l<h;l++)o=Math.max(o,s[l].getDuration());return new hs(e,s,o)}}qa.BlendModeValues=[y.NORMAL,y.ADD,y.MULTIPLY,y.SCREEN];let $a=class{constructor(t,e,n,s,a){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=s,this.inheritTimeline=a}};class Ua{constructor(t=null,e=null){this.bones=t,this.vertices=e}}function za(t,e,n){let s=t.readFloat(),a=t.readFloat()*n;for(let r=0,i=0,o=e.getFrameCount()-1;e.setFrame(r,s,a),r!=o;r++){const o=t.readFloat(),l=t.readFloat()*n;switch(t.readByte()){case pr:e.setStepped(r);break;case xr:ja(t,e,i++,r,0,s,o,a,l,n)}s=o,a=l}return e}function Ha(t,e,n){let s=t.readFloat(),a=t.readFloat()*n,r=t.readFloat()*n;for(let i=0,o=0,l=e.getFrameCount()-1;e.setFrame(i,s,a,r),i!=l;i++){const l=t.readFloat(),h=t.readFloat()*n,c=t.readFloat()*n;switch(t.readByte()){case pr:e.setStepped(i);break;case xr:ja(t,e,o++,i,0,s,l,a,h,n),ja(t,e,o++,i,1,s,l,r,c,n)}s=l,a=h,r=c}return e}function ja(t,e,n,s,a,r,i,o,l,h){e.setBezier(n,s,a,r,o,t.readFloat(),t.readFloat()*h,t.readFloat(),t.readFloat()*h,i,l)}const Ga=0,Za=1,Qa=2,Ka=3,Ja=4,tr=5,er=6,nr=7,sr=8,ar=9,rr=0,ir=1,or=2,lr=3,hr=4,cr=5,dr=0,ur=1,mr=0,fr=1,gr=2,pr=1,xr=2;class wr{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,n=new Ba,s="string"==typeof t?JSON.parse(t):t,a=s.skeleton;if(a){n.hash=a.hash,n.version=a.spine;const t=n.version.substr(0,3);if("4.0"!==t&&"4.1"!==t){const t=`Spine 4.1 loader cant load version ${a.spine}. Please configure your pixi-spine bundle`;console.error(t)}n.x=a.x,n.y=a.y,n.width=a.width,n.height=a.height,n.fps=a.fps,n.imagesPath=a.images}if(s.bones)for(let r=0;r<s.bones.length;r++){const t=s.bones[r];let a=null;const i=Mr(t,"parent",null);if(null!=i&&(a=n.findBone(i),null==a))throw new Error(`Parent bone not found: ${i}`);const o=new Aa(n.bones.length,t.name,a);o.length=Mr(t,"length",0)*e,o.x=Mr(t,"x",0)*e,o.y=Mr(t,"y",0)*e,o.rotation=Mr(t,"rotation",0),o.scaleX=Mr(t,"scaleX",1),o.scaleY=Mr(t,"scaleY",1),o.shearX=Mr(t,"shearX",0),o.shearY=Mr(t,"shearY",0),o.transformMode=j.enumValue(R,Mr(t,"transform","Normal")),o.skinRequired=Mr(t,"skin",!1);const l=Mr(t,"color",null);l&&o.color.setFromString(l),n.bones.push(o)}if(s.slots)for(let r=0;r<s.slots.length;r++){const t=s.slots[r],e=n.findBone(t.bone);if(!e)throw new Error(`Couldn't find bone ${t.bone} for slot ${t.name}`);const a=new La(n.slots.length,t.name,e),i=Mr(t,"color",null);i&&a.color.setFromString(i);const o=Mr(t,"dark",null);o&&(a.darkColor=O.fromString(o)),a.attachmentName=Mr(t,"attachment",null),a.blendMode=wr.blendModeFromString(Mr(t,"blend","normal")),n.slots.push(a)}if(s.ik)for(let r=0;r<s.ik.length;r++){const t=s.ik[r],a=new Ca(t.name);a.order=Mr(t,"order",0),a.skinRequired=Mr(t,"skin",!1);for(let e=0;e<t.bones.length;e++){const s=t.bones[e],r=n.findBone(s);if(null==r)throw new Error(`IK bone not found: ${s}`);a.bones.push(r)}a.target=n.findBone(t.target),a.mix=Mr(t,"mix",1),a.softness=Mr(t,"softness",0)*e,a.bendDirection=Mr(t,"bendPositive",!0)?1:-1,a.compress=Mr(t,"compress",!1),a.stretch=Mr(t,"stretch",!1),a.uniform=Mr(t,"uniform",!1),n.ikConstraints.push(a)}if(s.transform)for(let r=0;r<s.transform.length;r++){const t=s.transform[r],a=new _a(t.name);a.order=Mr(t,"order",0),a.skinRequired=Mr(t,"skin",!1);for(let e=0;e<t.bones.length;e++){const s=t.bones[e],r=n.findBone(s);if(!r)throw new Error(`Couldn't find bone ${s} for transform constraint ${t.name}.`);a.bones.push(r)}const i=t.target,o=n.findBone(i);if(!o)throw new Error(`Couldn't find target bone ${i} for transform constraint ${t.name}.`);a.target=o,a.local=Mr(t,"local",!1),a.relative=Mr(t,"relative",!1),a.offsetRotation=Mr(t,"rotation",0),a.offsetX=Mr(t,"x",0)*e,a.offsetY=Mr(t,"y",0)*e,a.offsetScaleX=Mr(t,"scaleX",0),a.offsetScaleY=Mr(t,"scaleY",0),a.offsetShearY=Mr(t,"shearY",0),a.mixRotate=Mr(t,"mixRotate",1),a.mixX=Mr(t,"mixX",1),a.mixY=Mr(t,"mixY",a.mixX),a.mixScaleX=Mr(t,"mixScaleX",1),a.mixScaleY=Mr(t,"mixScaleY",a.mixScaleX),a.mixShearY=Mr(t,"mixShearY",1),n.transformConstraints.push(a)}if(s.path)for(let r=0;r<s.path.length;r++){const t=s.path[r],a=new Va(t.name);a.order=Mr(t,"order",0),a.skinRequired=Mr(t,"skin",!1);for(let e=0;e<t.bones.length;e++){const s=t.bones[e],r=n.findBone(s);if(!r)throw new Error(`Couldn't find bone ${s} for path constraint ${t.name}.`);a.bones.push(r)}const i=t.target,o=n.findSlot(i);if(!o)throw new Error(`Couldn't find target slot ${i} for path constraint ${t.name}.`);a.target=o,a.positionMode=j.enumValue(T,Mr(t,"positionMode","Percent")),a.spacingMode=j.enumValue(va,Mr(t,"spacingMode","Length")),a.rotateMode=j.enumValue(k,Mr(t,"rotateMode","Tangent")),a.offsetRotation=Mr(t,"rotation",0),a.position=Mr(t,"position",0),a.positionMode==T.Fixed&&(a.position*=e),a.spacing=Mr(t,"spacing",0),a.spacingMode!=va.Length&&a.spacingMode!=va.Fixed||(a.spacing*=e),a.mixRotate=Mr(t,"mixRotate",1),a.mixX=Mr(t,"mixX",1),a.mixY=Mr(t,"mixY",a.mixX),n.pathConstraints.push(a)}if(s.skins)for(let r=0;r<s.skins.length;r++){const t=s.skins[r],e=new Wa(t.name);if(t.bones)for(let s=0;s<t.bones.length;s++){const a=t.bones[s],r=n.findBone(a);if(!r)throw new Error(`Couldn't find bone ${a} for skin ${t.name}.`);e.bones.push(r)}if(t.ik)for(let s=0;s<t.ik.length;s++){const a=t.ik[s],r=n.findIkConstraint(a);if(!r)throw new Error(`Couldn't find IK constraint ${a} for skin ${t.name}.`);e.constraints.push(r)}if(t.transform)for(let s=0;s<t.transform.length;s++){const a=t.transform[s],r=n.findTransformConstraint(a);if(!r)throw new Error(`Couldn't find transform constraint ${a} for skin ${t.name}.`);e.constraints.push(r)}if(t.path)for(let s=0;s<t.path.length;s++){const a=t.path[s],r=n.findPathConstraint(a);if(!r)throw new Error(`Couldn't find path constraint ${a} for skin ${t.name}.`);e.constraints.push(r)}for(const s in t.attachments){const a=n.findSlot(s);if(!a)throw new Error(`Couldn't find slot ${s} for skin ${t.name}.`);const r=t.attachments[s];for(const t in r){const s=this.readAttachment(r[t],e,a.index,t,n);s&&e.setAttachment(a.index,t,s)}}n.skins.push(e),"default"==e.name&&(n.defaultSkin=e)}for(let r=0,i=this.linkedMeshes.length;r<i;r++){const t=this.linkedMeshes[r],e=t.skin?n.findSkin(t.skin):n.defaultSkin;if(!e)throw new Error(`Skin not found: ${t.skin}`);const s=e.getAttachment(t.slotIndex,t.parent);if(!s)throw new Error(`Parent mesh not found: ${t.parent}`);t.mesh.timelineAttachment=t.inheritTimeline?s:t.mesh,t.mesh.setParentMesh(s)}if(this.linkedMeshes.length=0,s.events)for(const r in s.events){const t=s.events[r],e=new ka(r);e.intValue=Mr(t,"int",0),e.floatValue=Mr(t,"float",0),e.stringValue=Mr(t,"string",""),e.audioPath=Mr(t,"audio",null),e.audioPath&&(e.volume=Mr(t,"volume",1),e.balance=Mr(t,"balance",0)),n.events.push(e)}if(s.animations)for(const r in s.animations){const t=s.animations[r];this.readAnimation(t,r,n)}return n}readAttachment(t,e,n,s,a){const r=this.scale;switch(s=Mr(t,"name",s),Mr(t,"type","region")){case"region":{const n=Mr(t,"path",s),a=this.readSequence(Mr(t,"sequence",null)),i=this.attachmentLoader.newRegionAttachment(e,s,n,a);if(!i)return null;i.path=n,i.x=Mr(t,"x",0)*r,i.y=Mr(t,"y",0)*r,i.scaleX=Mr(t,"scaleX",1),i.scaleY=Mr(t,"scaleY",1),i.rotation=Mr(t,"rotation",0),i.width=t.width*r,i.height=t.height*r,i.sequence=a;const o=Mr(t,"color",null);return o&&i.color.setFromString(o),i}case"boundingbox":{const n=this.attachmentLoader.newBoundingBoxAttachment(e,s);if(!n)return null;this.readVertices(t,n,t.vertexCount<<1);const a=Mr(t,"color",null);return a&&n.color.setFromString(a),n}case"mesh":case"linkedmesh":{const a=Mr(t,"path",s),i=this.readSequence(Mr(t,"sequence",null)),o=this.attachmentLoader.newMeshAttachment(e,s,a,i);if(!o)return null;o.path=a;const l=Mr(t,"color",null);l&&o.color.setFromString(l),o.width=Mr(t,"width",0)*r,o.height=Mr(t,"height",0)*r,o.sequence=i;const h=Mr(t,"parent",null);if(h)return this.linkedMeshes.push(new br(o,Mr(t,"skin",null),n,h,Mr(t,"timelines",!0))),o;const c=t.uvs;return this.readVertices(t,o,c.length),o.triangles=t.triangles,o.regionUVs=new Float32Array(c),o.edges=Mr(t,"edges",null),o.hullLength=2*Mr(t,"hull",0),o}case"path":{const n=this.attachmentLoader.newPathAttachment(e,s);if(!n)return null;n.closed=Mr(t,"closed",!1),n.constantSpeed=Mr(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,n,a<<1);const i=j.newArray(a/3,0);for(let e=0;e<t.lengths.length;e++)i[e]=t.lengths[e]*r;n.lengths=i;const o=Mr(t,"color",null);return o&&n.color.setFromString(o),n}case"point":{const n=this.attachmentLoader.newPointAttachment(e,s);if(!n)return null;n.x=Mr(t,"x",0)*r,n.y=Mr(t,"y",0)*r,n.rotation=Mr(t,"rotation",0);const a=Mr(t,"color",null);return a&&n.color.setFromString(a),n}case"clipping":{const n=this.attachmentLoader.newClippingAttachment(e,s);if(!n)return null;const r=Mr(t,"end",null);if(null!=r){const t=a.findSlot(r);if(null==t)throw new Error(`Clipping end slot not found: ${r}`);n.endSlot=t}const i=t.vertexCount;this.readVertices(t,n,i<<1);const o=Mr(t,"color",null);return o&&n.color.setFromString(o),n}}return null}readSequence(t){if(null==t)return null;const e=new is(Mr(t,"count",0));return e.start=Mr(t,"start",1),e.digits=Mr(t,"digits",0),e.setupIndex=Mr(t,"setup",0),e}readVertices(t,e,n){const s=this.scale;e.worldVerticesLength=n;const a=t.vertices;if(n==a.length){const t=j.toFloatArray(a);if(1!=s)for(let e=0,n=a.length;e<n;e++)t[e]*=s;return void(e.vertices=t)}const r=new Array,i=new Array;for(let o=0,l=a.length;o<l;){const t=a[o++];i.push(t);for(let e=o+4*t;o<e;o+=4)i.push(a[o]),r.push(a[o+1]*s),r.push(a[o+2]*s),r.push(a[o+3])}e.bones=i,e.vertices=j.toFloatArray(r)}readAnimation(t,e,n){const s=this.scale,a=new Array;if(t.slots)for(const i in t.slots){const e=t.slots[i],s=n.findSlot(i);if(!s)throw new Error(`Slot not found: ${i}`);const r=s.index;for(const t in e){const n=e[t];if(!n)continue;const s=n.length;if("attachment"==t){const t=new Gs(s,r);for(let e=0;e<s;e++){const s=n[e];t.setFrame(e,Mr(s,"time",0),Mr(s,"name",null))}a.push(t)}else if("rgba"==t){const t=new $s(s,s<<2,r);let e=n[0],i=Mr(e,"time",0),o=O.fromString(e.color);for(let s=0,a=0;;s++){t.setFrame(s,i,o.r,o.g,o.b,o.a);const r=n[s+1];if(!r){t.shrink(a);break}const l=Mr(r,"time",0),h=O.fromString(r.color),c=e.curve;c&&(a=Sr(c,t,a,s,0,i,l,o.r,h.r,1),a=Sr(c,t,a,s,1,i,l,o.g,h.g,1),a=Sr(c,t,a,s,2,i,l,o.b,h.b,1),a=Sr(c,t,a,s,3,i,l,o.a,h.a,1)),i=l,o=h,e=r}a.push(t)}else if("rgb"==t){const t=new Us(s,3*s,r);let e=n[0],i=Mr(e,"time",0),o=O.fromString(e.color);for(let s=0,a=0;;s++){t.setFrame(s,i,o.r,o.g,o.b);const r=n[s+1];if(!r){t.shrink(a);break}const l=Mr(r,"time",0),h=O.fromString(r.color),c=e.curve;c&&(a=Sr(c,t,a,s,0,i,l,o.r,h.r,1),a=Sr(c,t,a,s,1,i,l,o.g,h.g,1),a=Sr(c,t,a,s,2,i,l,o.b,h.b,1)),i=l,o=h,e=r}a.push(t)}else if("alpha"==t)a.push(Er(n,new zs(s,s,r),0,1));else if("rgba2"==t){const t=new Hs(s,7*s,r);let e=n[0],i=Mr(e,"time",0),o=O.fromString(e.light),l=O.fromString(e.dark);for(let s=0,a=0;;s++){t.setFrame(s,i,o.r,o.g,o.b,o.a,l.r,l.g,l.b);const r=n[s+1];if(!r){t.shrink(a);break}const h=Mr(r,"time",0),c=O.fromString(r.light),d=O.fromString(r.dark),u=e.curve;u&&(a=Sr(u,t,a,s,0,i,h,o.r,c.r,1),a=Sr(u,t,a,s,1,i,h,o.g,c.g,1),a=Sr(u,t,a,s,2,i,h,o.b,c.b,1),a=Sr(u,t,a,s,3,i,h,o.a,c.a,1),a=Sr(u,t,a,s,4,i,h,l.r,d.r,1),a=Sr(u,t,a,s,5,i,h,l.g,d.g,1),a=Sr(u,t,a,s,6,i,h,l.b,d.b,1)),i=h,o=c,l=d,e=r}a.push(t)}else if("rgb2"==t){const t=new js(s,6*s,r);let e=n[0],i=Mr(e,"time",0),o=O.fromString(e.light),l=O.fromString(e.dark);for(let s=0,a=0;;s++){t.setFrame(s,i,o.r,o.g,o.b,l.r,l.g,l.b);const r=n[s+1];if(!r){t.shrink(a);break}const h=Mr(r,"time",0),c=O.fromString(r.light),d=O.fromString(r.dark),u=e.curve;u&&(a=Sr(u,t,a,s,0,i,h,o.r,c.r,1),a=Sr(u,t,a,s,1,i,h,o.g,c.g,1),a=Sr(u,t,a,s,2,i,h,o.b,c.b,1),a=Sr(u,t,a,s,3,i,h,l.r,d.r,1),a=Sr(u,t,a,s,4,i,h,l.g,d.g,1),a=Sr(u,t,a,s,5,i,h,l.b,d.b,1)),i=h,o=c,l=d,e=r}a.push(t)}}}if(t.bones)for(const i in t.bones){const e=t.bones[i],r=n.findBone(i);if(!r)throw new Error(`Bone not found: ${i}`);const o=r.index;for(const t in e){const n=e[t],r=n.length;if(0!=r)if("rotate"===t)a.push(Er(n,new Ys(r,r,o),0,1));else if("translate"===t){const t=new Ns(r,r<<1,o);a.push(yr(n,t,"x","y",0,s))}else if("translatex"===t){const t=new Xs(r,r,o);a.push(Er(n,t,0,s))}else if("translatey"===t){const t=new Ds(r,r,o);a.push(Er(n,t,0,s))}else if("scale"===t){const t=new Bs(r,r<<1,o);a.push(yr(n,t,"x","y",1,1))}else if("scalex"===t){const t=new Ls(r,r,o);a.push(Er(n,t,1,1))}else if("scaley"===t){const t=new _s(r,r,o);a.push(Er(n,t,1,1))}else if("shear"===t){const t=new Os(r,r<<1,o);a.push(yr(n,t,"x","y",0,1))}else if("shearx"===t){const t=new Ws(r,r,o);a.push(Er(n,t,0,1))}else if("sheary"===t){const t=new qs(r,r,o);a.push(Er(n,t,0,1))}}}if(t.ik)for(const i in t.ik){const e=t.ik[i];let r=e[0];if(!r)continue;const o=n.findIkConstraint(i);if(!o)throw new Error(`IK Constraint not found: ${i}`);const l=n.ikConstraints.indexOf(o),h=new ea(e.length,e.length<<1,l);let c=Mr(r,"time",0),d=Mr(r,"mix",1),u=Mr(r,"softness",0)*s;for(let t=0,n=0;;t++){h.setFrame(t,c,d,u,Mr(r,"bendPositive",!0)?1:-1,Mr(r,"compress",!1),Mr(r,"stretch",!1));const a=e[t+1];if(!a){h.shrink(n);break}const i=Mr(a,"time",0),o=Mr(a,"mix",1),l=Mr(a,"softness",0)*s,m=r.curve;m&&(n=Sr(m,h,n,t,0,c,i,d,o,1),n=Sr(m,h,n,t,1,c,i,u,l,s)),c=i,d=o,u=l,r=a}a.push(h)}if(t.transform)for(const i in t.transform){const e=t.transform[i];let s=e[0];if(!s)continue;const r=n.findTransformConstraint(i);if(!r)throw new Error(`Transform constraint not found: ${i}`);const o=n.transformConstraints.indexOf(r),l=new na(e.length,6*e.length,o);let h=Mr(s,"time",0),c=Mr(s,"mixRotate",1),d=Mr(s,"mixX",1),u=Mr(s,"mixY",d),m=Mr(s,"mixScaleX",1),f=Mr(s,"mixScaleY",m);const g=Mr(s,"mixShearY",1);for(let t=0,n=0;;t++){l.setFrame(t,h,c,d,u,m,f,g);const a=e[t+1];if(!a){l.shrink(n);break}const r=Mr(a,"time",0),i=Mr(a,"mixRotate",1),o=Mr(a,"mixX",1),p=Mr(a,"mixY",o),x=Mr(a,"mixScaleX",1),w=Mr(a,"mixScaleY",x),b=Mr(a,"mixShearY",1),E=s.curve;E&&(n=Sr(E,l,n,t,0,h,r,c,i,1),n=Sr(E,l,n,t,1,h,r,d,o,1),n=Sr(E,l,n,t,2,h,r,u,p,1),n=Sr(E,l,n,t,3,h,r,m,x,1),n=Sr(E,l,n,t,4,h,r,f,w,1),n=Sr(E,l,n,t,5,h,r,g,b,1)),h=r,c=i,d=o,u=p,m=x,f=w,m=x,s=a}a.push(l)}if(t.path)for(const i in t.path){const e=t.path[i],r=n.findPathConstraint(i);if(!r)throw new Error(`Path constraint not found: ${i}`);const o=n.pathConstraints.indexOf(r);for(const t in e){const n=e[t];let i=n[0];if(!i)continue;const l=n.length;if("position"===t){const t=new sa(l,l,o);a.push(Er(n,t,0,r.positionMode==T.Fixed?s:1))}else if("spacing"===t){const t=new aa(l,l,o);a.push(Er(n,t,0,r.spacingMode==va.Length||r.spacingMode==va.Fixed?s:1))}else if("mix"===t){const t=new ra(l,3*l,o);let e=Mr(i,"time",0),s=Mr(i,"mixRotate",1),r=Mr(i,"mixX",1),h=Mr(i,"mixY",r);for(let a=0,o=0;;a++){t.setFrame(a,e,s,r,h);const l=n[a+1];if(!l){t.shrink(o);break}const c=Mr(l,"time",0),d=Mr(l,"mixRotate",1),u=Mr(l,"mixX",1),m=Mr(l,"mixY",u),f=i.curve;f&&(o=Sr(f,t,o,a,0,e,c,s,d,1),o=Sr(f,t,o,a,1,e,c,r,u,1),o=Sr(f,t,o,a,2,e,c,h,m,1)),e=c,s=d,r=u,h=m,i=l}a.push(t)}}}if(t.deform){t.attachments={};for(const e in t.deform){const n=t.deform[e],s=t.attachments[e]={};for(const t in n){const e=n[t],a=s[t]={};for(const t in e)a[t]={deform:e[t]}}}}if(t.attachments)for(const i in t.attachments){const e=t.attachments[i],r=n.findSkin(i);if(null!=r)for(const t in e){const i=e[t],o=n.findSlot(t);if(!o)throw new Error(`Slot not found: ${t}`);const l=o.index;for(const t in i){const e=i[t],n=r.getAttachment(l,t);for(const t in e){const r=e[t];let i=r[0];if(i)if("deform"==t){const t=n.bones,e=n.vertices,o=t?e.length/3*2:e.length,h=new Zs(r.length,r.length,l,n);let c=Mr(i,"time",0);for(let n=0,a=0;;n++){let l;const d=Mr(i,"vertices",null);if(d){l=j.newFloatArray(o);const n=Mr(i,"offset",0);if(j.arrayCopy(d,0,l,n,d.length),1!=s)for(let t=n,e=t+d.length;t<e;t++)l[t]*=s;if(!t)for(let t=0;t<o;t++)l[t]+=e[t]}else l=t?j.newFloatArray(o):e;h.setFrame(n,c,l);const u=r[n+1];if(!u){h.shrink(a);break}const m=Mr(u,"time",0),f=i.curve;f&&(a=Sr(f,h,a,n,0,c,m,0,1,1)),c=m,i=u}a.push(h)}else if("sequence"==t){const t=new oa(r.length,l,n);let e=0;for(let n=0;n<r.length;n++){const s=Mr(i,"delay",e),a=Mr(i,"time",0),o=os[Mr(i,"mode","hold")],l=Mr(i,"index",0);t.setFrame(n,a,o,l,s),e=s,i=r[n+1]}a.push(t)}}}}}if(t.drawOrder){const e=new ta(t.drawOrder.length),s=n.slots.length;let r=0;for(let a=0;a<t.drawOrder.length;a++,r++){const i=t.drawOrder[a];let o=null;const l=Mr(i,"offsets",null);if(l){o=j.newArray(s,-1);const t=j.newArray(s-l.length,0);let e=0,a=0;for(let s=0;s<l.length;s++){const r=l[s],i=n.findSlot(r.slot);if(!i)throw new Error(`Slot not found: ${i}`);const h=i.index;for(;e!=h;)t[a++]=e++;o[e+r.offset]=e++}for(;e<s;)t[a++]=e++;for(let n=s-1;n>=0;n--)-1==o[n]&&(o[n]=t[--a])}e.setFrame(r,Mr(i,"time",0),o)}a.push(e)}if(t.events){const e=new Ks(t.events.length);let s=0;for(let a=0;a<t.events.length;a++,s++){const r=t.events[a],i=n.findEvent(r.name);if(!i)throw new Error(`Event not found: ${r.name}`);const o=new Ta(j.toSinglePrecision(Mr(r,"time",0)),i);o.intValue=Mr(r,"int",i.intValue),o.floatValue=Mr(r,"float",i.floatValue),o.stringValue=Mr(r,"string",i.stringValue),o.data.audioPath&&(o.volume=Mr(r,"volume",1),o.balance=Mr(r,"balance",0)),e.setFrame(s,o)}a.push(e)}let r=0;for(let i=0,o=a.length;i<o;i++)r=Math.max(r,a[i].getDuration());if(isNaN(r))throw new Error("Error while parsing animation, duration is NaN");n.animations.push(new hs(e,a,r))}static blendModeFromString(t){if("normal"==(t=t.toLowerCase()))return y.NORMAL;if("additive"==t)return y.ADD;if("multiply"==t)return y.MULTIPLY;if("screen"==t)return y.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class br{constructor(t,e,n,s,a){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=s,this.inheritTimeline=a}}function Er(t,e,n,s){let a=t[0],r=Mr(a,"time",0),i=Mr(a,"value",n)*s,o=0;for(let l=0;;l++){e.setFrame(l,r,i);const h=t[l+1];if(!h)return e.shrink(o),e;const c=Mr(h,"time",0),d=Mr(h,"value",n)*s;a.curve&&(o=Sr(a.curve,e,o,l,0,r,c,i,d,s)),r=c,i=d,a=h}}function yr(t,e,n,s,a,r){let i=t[0],o=Mr(i,"time",0),l=Mr(i,n,a)*r,h=Mr(i,s,a)*r,c=0;for(let d=0;;d++){e.setFrame(d,o,l,h);const u=t[d+1];if(!u)return e.shrink(c),e;const m=Mr(u,"time",0),f=Mr(u,n,a)*r,g=Mr(u,s,a)*r,p=i.curve;p&&(c=Sr(p,e,c,d,0,o,m,l,f,r),c=Sr(p,e,c,d,1,o,m,h,g,r)),o=m,l=f,h=g,i=u}}function Sr(t,e,n,s,a,r,i,o,l,h){if("stepped"==t)return e.setStepped(s),n;const c=a<<2,d=t[c],u=t[c+1]*h,m=t[c+2],f=t[c+3]*h;return e.setBezier(n,s,a,r,o,d,u,m,f,i,l),n+1}function Mr(t,e,n){return void 0!==t[e]?t[e]:n}const Ar=Object.freeze(Object.defineProperty({__proto__:null,AlphaTimeline:zs,Animation:hs,AnimationState:ha,AnimationStateAdapter:class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}},AnimationStateData:ya,AtlasAttachmentLoader:Sa,Attachment:Gn,AttachmentTimeline:Gs,Bone:Ma,BoneData:Aa,BoundingBoxAttachment:Kn,ClippingAttachment:Jn,ConstraintData:Ia,CurveTimeline:vs,CurveTimeline1:Ps,CurveTimeline2:Fs,DeformTimeline:Zs,DrawOrderTimeline:ta,Event:Ta,EventData:ka,EventQueue:ua,EventTimeline:Ks,EventType:ma,IkConstraint:Ra,IkConstraintData:Ca,IkConstraintTimeline:ea,MeshAttachment:ts,PathAttachment:es,PathConstraint:Fa,PathConstraintData:Va,PathConstraintMixTimeline:ra,PathConstraintPositionTimeline:sa,PathConstraintSpacingTimeline:aa,PointAttachment:ns,RGB2Timeline:js,RGBA2Timeline:Hs,RGBATimeline:$s,RGBTimeline:Us,RegionAttachment:as,RotateTimeline:Ys,ScaleTimeline:Bs,ScaleXTimeline:Ls,ScaleYTimeline:_s,Sequence:is,SequenceMode:os,SequenceModeValues:ls,SequenceTimeline:oa,ShearTimeline:Os,ShearXTimeline:Ws,ShearYTimeline:qs,Skeleton:Da,SkeletonBinary:qa,SkeletonBounds:class extends Q{},SkeletonData:Ba,SkeletonJson:wr,Skin:Wa,SkinEntry:Oa,Slot:Ya,SlotData:La,SpacingMode:va,Spine:class extends st{createSkeleton(t){this.skeleton=new Da(t),this.skeleton.updateWorldTransform(),this.stateData=new ya(t),this.state=new ha(this.stateData)}},Timeline:Vs,TrackEntry:da,TransformConstraint:Na,TransformConstraintData:_a,TransformConstraintTimeline:na,TranslateTimeline:Ns,TranslateXTimeline:Xs,TranslateYTimeline:Ds,VertexAttachment:Qn},Symbol.toStringTag,{value:"Module"}));var Ir=(t=>(t[t.UNKNOWN=0]="UNKNOWN",t[t.VER37=37]="VER37",t[t.VER38=38]="VER38",t[t.VER40=40]="VER40",t[t.VER41=41]="VER41",t))(Ir||{});function Tr(t){const e=t.substr(0,3),n=Math.floor(10*Number(e)+.001);return"3.7"===e?37:"3.8"===e?38:"4.0"===e?40:"4.1"===e?41:n<37?37:0}class kr{constructor(){this.scale=1}readSkeletonData(t,e){let n=null,s=this.readVersionOldFormat(e),a=Tr(s);if(a===Ir.VER38&&(n=new Ie(new ae(t))),s=this.readVersionNewFormat(e),a=Tr(s),a!==Ir.VER40&&a!==Ir.VER41||(n=new qa(new Sa(t))),!n){const t=`Unsupported version of spine model ${s}, please update pixi-spine`;console.error(t)}return n.scale=this.scale,n.readSkeletonData(e)}readVersionOldFormat(t){const e=new M(t);let n;try{e.readString(),n=e.readString()}catch(s){n=""}return n||""}readVersionNewFormat(t){const e=new M(t);let n;e.readInt32(),e.readInt32();try{n=e.readString()}catch(s){n=""}return n||""}}class Rr{constructor(){this.scale=1}readSkeletonData(t,e){const n=e.skeleton.spine,s=Tr(n);let a=null;if(s===Ir.VER37&&(a=new zn(new Rn(t))),s===Ir.VER38&&(a=new Re(new ae(t))),s!==Ir.VER40&&s!==Ir.VER41||(a=new wr(new Sa(t))),!a){const t=`Unsupported version of spine model ${n}, please update pixi-spine`;console.error(t)}return a.scale=this.scale,a.readSkeletonData(e)}}class Cr extends st{createSkeleton(t){const e=Tr(t.version);let n=null;if(e===Ir.VER37&&(n=jn),e===Ir.VER38&&(n=Ve),e!==Ir.VER40&&e!==Ir.VER41||(n=Ar),!n){const e=`Cant detect version of spine model ${t.version}`;console.error(e)}this.skeleton=new n.Skeleton(t),this.skeleton.updateWorldTransform(),this.stateData=new n.AnimationStateData(t),this.state=new n.AnimationState(this.stateData)}}(new class extends ot{createBinaryParser(){return new kr}createJsonParser(){return new Rr}parseData(t,e,n){return{spineData:t.readSkeletonData(e,n),spineAtlas:e}}}).installLoader();export{Cr as S};
